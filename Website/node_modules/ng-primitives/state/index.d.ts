import { FactoryProvider, InjectionToken, InjectOptions, InputSignal, InputSignalWithTransform, ProviderToken, Signal, WritableSignal } from '@angular/core';
/**
 * This converts the state object to a writable state object.
 * This means that inputs become signals which are writable.
 */
export type State<T> = {
    [K in keyof T]: T[K] extends InputSignalWithTransform<infer U, any> ? WritableSignal<U> : T[K] extends InputSignal<infer R> ? WritableSignal<R> : T[K];
};
/**
 * This is similar to the state object, but we don't expose properties that are not
 * inputs.
 */
export type CreatedState<T> = {
    [K in keyof T]: T[K] extends InputSignalWithTransform<infer U, any> ? WritableSignal<U> : T[K] extends InputSignal<infer R> ? WritableSignal<R> : never;
};
export type InjectedState<T> = Signal<State<T>>;
/**
 * Create a new injection token for the state.
 * @param description The description of the token
 */
export declare function createStateToken<T>(description: string): InjectionToken<T>;
export interface CreateStateProviderOptions {
    /**
     * Whether we should check for the state in the parent injector.
     */
    inherit?: boolean;
}
/**
 * Create a new provider for the state. It first tries to inject the state from the parent injector,
 * as this allows for the state to be hoisted to a higher level in the component tree. This can
 * be useful to avoid issues where the injector can't be shared in some cases when ng-content is used.
 * @param token The token for the state
 */
export declare function createStateProvider<T>(token: ProviderToken<T>): (options?: CreateStateProviderOptions) => FactoryProvider;
type CreateStateInjectorOptions = {
    /**
     * Whether the state may not be immediately available. This can happen when the child is instantiated before the parent.
     */
    deferred?: boolean;
};
/**
 * Create a new state injector for the state.
 * @param token The token for the state
 */
export declare function createStateInjector<T>(token: ProviderToken<State<T>>, options: {
    deferred: true;
}): <U = T>(injectOptions?: InjectOptions) => Signal<State<U> | undefined>;
export declare function createStateInjector<T>(token: ProviderToken<State<T>>, options?: CreateStateInjectorOptions): <U = T>(injectOptions?: InjectOptions) => Signal<State<U>>;
/**
 * Convert the original state object into a writable state object.
 * @param token The token for the state
 */
export declare function createState(token: ProviderToken<WritableSignal<State<unknown>>>): <U>(state: U) => CreatedState<U>;
export {};
