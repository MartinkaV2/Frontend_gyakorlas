import { FocusOrigin } from '@angular/cdk/a11y';
import { Injector, Provider, Signal, TemplateRef, Type, ViewContainerRef } from '@angular/core';
import { Middleware, Placement, Strategy } from '@floating-ui/dom';
import { Subject } from 'rxjs';
/**
 * Configuration options for creating an overlay
 * @internal
 */
export interface NgpOverlayConfig<T = unknown> {
    /** Content to display in the overlay (component or template) */
    content: NgpOverlayContent<T>;
    /** The element that triggers the overlay */
    triggerElement: HTMLElement;
    /** The injector to use for creating the portal */
    injector: Injector;
    /** ViewContainerRef to use for creating the portal */
    viewContainerRef: ViewContainerRef;
    /** Context data to pass to the overlay content */
    context?: Signal<T | undefined>;
    /** Container element or selector to attach the overlay to (defaults to document.body) */
    container?: HTMLElement | string | null;
    /** Preferred placement of the overlay relative to the trigger */
    placement?: Placement;
    /** Offset distance between the overlay and trigger in pixels */
    offset?: number;
    /** Whether to enable flip behavior when space is limited */
    flip?: boolean;
    /** Delay before showing the overlay in milliseconds */
    showDelay?: number;
    /** Delay before hiding the overlay in milliseconds */
    hideDelay?: number;
    /** Whether the overlay should be positioned with fixed or absolute strategy */
    strategy?: Strategy;
    /** The scroll strategy to use for the overlay */
    scrollBehaviour?: 'reposition' | 'block';
    /** Whether to close the overlay when clicking outside */
    closeOnOutsideClick?: boolean;
    /** Whether to close the overlay when pressing escape */
    closeOnEscape?: boolean;
    /** Whether to restore focus to the trigger element when hiding the overlay */
    restoreFocus?: boolean;
    /** Additional middleware for floating UI positioning */
    additionalMiddleware?: Middleware[];
    /** Additional providers */
    providers?: Provider[];
}
/** Type for overlay content which can be either a template or component */
export type NgpOverlayContent<T> = TemplateRef<NgpOverlayTemplateContext<T>> | Type<unknown>;
/** Context for template-based overlays */
export type NgpOverlayTemplateContext<T> = {
    $implicit: T;
};
/**
 * NgpOverlay manages the lifecycle and positioning of overlay UI elements.
 * It abstracts the common behavior shared by tooltips, popovers, menus, etc.
 * @internal
 */
export declare class NgpOverlay<T = unknown> {
    private config;
    private readonly disposables;
    private readonly document;
    private readonly destroyRef;
    private readonly viewContainerRef;
    private readonly viewportRuler;
    private readonly focusMonitor;
    /** Access any parent overlays */
    private readonly parentOverlay;
    /** Signal tracking the portal instance */
    private readonly portal;
    /** Signal tracking the overlay position */
    readonly position: import("@angular/core").WritableSignal<{
        x: number | undefined;
        y: number | undefined;
    }>;
    /**
     * Determine if the overlay has been positioned
     * @internal
     */
    readonly isPositioned: Signal<boolean>;
    /** Signal tracking the trigger element width */
    readonly triggerWidth: import("@angular/core").WritableSignal<number | null>;
    /** The transform origin for the overlay */
    readonly transformOrigin: import("@angular/core").WritableSignal<string>;
    /** Signal tracking the final placement of the overlay */
    readonly finalPlacement: import("@angular/core").WritableSignal<Placement | undefined>;
    /** Function to dispose the positioning auto-update */
    private disposePositioning?;
    /** Timeout handle for showing the overlay */
    private openTimeout?;
    /** Timeout handle for hiding the overlay */
    private closeTimeout?;
    /** Signal tracking whether the overlay is open */
    readonly isOpen: import("@angular/core").WritableSignal<boolean>;
    /** A unique id for the overlay */
    readonly id: import("@angular/core").WritableSignal<string>;
    /** The aria-describedby attribute for accessibility */
    readonly ariaDescribedBy: Signal<string | undefined>;
    /** The scroll strategy */
    private scrollStrategy;
    /** An observable that emits when the overlay is closing */
    readonly closing: Subject<void>;
    /** Store the arrow element */
    private arrowElement;
    /** @internal The position of the arrow */
    readonly arrowPosition: import("@angular/core").WritableSignal<{
        x: number | undefined;
        y: number | undefined;
    }>;
    /**
     * Creates a new overlay instance
     * @param config Initial configuration for the overlay
     * @param destroyRef Reference for automatic cleanup
     */
    constructor(config: NgpOverlayConfig<T>);
    /**
     * Show the overlay with the specified delay
     * @param showDelay Optional delay to override the configured showDelay
     */
    show(): Promise<void>;
    /**
     * Stop any pending close operation. This is useful for example, if we move the mouse from the tooltip trigger to the tooltip itself.
     * This will prevent the tooltip from closing immediately when the mouse leaves the trigger.
     * @internal
     */
    cancelPendingClose(): void;
    /**
     * Hide the overlay with the specified delay
     * @param options Optional options for hiding the overlay
     */
    hide(options?: OverlayTriggerOptions): void;
    /**
     * Update the configuration of this overlay
     * @param config New configuration (partial)
     */
    updateConfig(config: Partial<NgpOverlayConfig<T>>): void;
    /**
     * Immediately hide the overlay without any delay
     */
    hideImmediate(): void;
    /**
     * Toggle the overlay open/closed state
     */
    toggle(): void;
    /**
     * Force update the position of the overlay
     */
    updatePosition(): void;
    /**
     * Completely destroy this overlay instance
     */
    destroy(): void;
    /**
     * Get the elements of the overlay
     */
    getElements(): HTMLElement[];
    /**
     * Internal method to create the overlay
     */
    private createOverlay;
    /**
     * Internal method to setup positioning of the overlay
     */
    private setupPositioning;
    /**
     * Compute the overlay position using floating-ui
     */
    private computePosition;
    /**
     * Internal method to destroy the overlay portal
     */
    private destroyOverlay;
    /**
     * Get the transform origin for the overlay
     */
    private getTransformOrigin;
    /**
     * Register the arrow element for positioning
     * @internal
     */
    registerArrow(arrowElement: HTMLElement | null): void;
    /**
     * Remove the registered arrow element
     * @internal
     */
    unregisterArrow(): void;
    /**
     * Resolve the container element from the configuration
     * @internal
     */
    private resolveContainer;
}
/**
 * Helper function to create an overlay in a single call
 * @internal
 */
export declare function createOverlay<T>(config: NgpOverlayConfig<T>): NgpOverlay<T>;
/**
 * Helper function to inject the NgpOverlay instance
 * @internal
 */
export declare function injectOverlay<T>(): NgpOverlay<T>;
export interface OverlayTriggerOptions {
    /**
     * Whether the visibility change should be immediate.
     */
    immediate?: boolean;
    /**
     * The origin of the focus event that triggered the visibility change.
     */
    origin?: FocusOrigin;
}
