import { FocusMonitor, InteractivityChecker } from '@angular/cdk/a11y';
import * as i0 from '@angular/core';
import { inject, Injector, ElementRef, NgZone, input, booleanAttribute, afterNextRender, HostListener, Directive } from '@angular/core';
import { NgpOverlay } from 'ng-primitives/portal';
import { safeTakeUntilDestroyed } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';

/**
 * The state token  for the FocusTrap primitive.
 */
const NgpFocusTrapStateToken = createStateToken('FocusTrap');
/**
 * Provides the FocusTrap state.
 */
const provideFocusTrapState = createStateProvider(NgpFocusTrapStateToken);
/**
 * Injects the FocusTrap state.
 */
const injectFocusTrapState = createStateInjector(NgpFocusTrapStateToken);
/**
 * The FocusTrap state registration function.
 */
const focusTrapState = createState(NgpFocusTrapStateToken);

/**
 * This implementation is based on the Radix UI FocusScope:
 * https://github.com/radix-ui/primitives/blob/main/packages/react/focus-scope/src/FocusScope.tsx#L306
 */
class FocusTrap {
    constructor() {
        /**
         * Whether the focus trap is active.
         */
        this.active = false;
    }
    /**
     * Activates the focus trap.
     */
    activate() {
        this.active = true;
    }
    /**
     * Deactivates the focus trap.
     */
    deactivate() {
        this.active = false;
    }
}
class FocusTrapStack {
    constructor() {
        /**
         * The stack of focus traps.
         */
        this.stack = [];
    }
    /**
     * Adds a focus trap to the stack.
     */
    add(focusTrap) {
        // deactivate the previous focus trap
        this.stack.forEach(t => t.deactivate());
        // add the new focus trap and activate it
        this.stack.push(focusTrap);
        focusTrap.activate();
    }
    /**
     * Removes a focus trap from the stack.
     */
    remove(focusTrap) {
        // remove the focus trap
        const index = this.stack.indexOf(focusTrap);
        if (index >= 0) {
            this.stack.splice(index, 1);
        }
        // activate the previous focus trap
        const previous = this.stack[this.stack.length - 1];
        if (previous) {
            previous.activate();
        }
    }
}
// create a global stack of focus traps
const focusTrapStack = new FocusTrapStack();
/**
 * The `NgpFocusTrap` directive traps focus within the host element.
 */
class NgpFocusTrap {
    constructor() {
        /**
         * Access any parent overlay.
         */
        this.overlay = inject(NgpOverlay, { optional: true });
        /**
         * Create a new focus trap.
         */
        this.focusTrap = new FocusTrap();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the focus monitor.
         */
        this.focusMonitor = inject(FocusMonitor);
        /**
         * Access the interactivity checker.
         */
        this.interactivityChecker = inject(InteractivityChecker);
        /**
         * Get the focus trap container element.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access NgZone to run the focus trap events outside of Angular's zone.
         */
        this.ngZone = inject(NgZone);
        /**
         * Store the mutation observer.
         */
        this.mutationObserver = null;
        /**
         * Store the last focused element.
         */
        this.lastFocusedElement = null;
        /**
         * Whether the focus trap is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpFocusTrapDisabled',
            transform: booleanAttribute,
        });
        /**
         * The focus trap state.
         */
        this.state = focusTrapState(this);
        // if this is used within an overlay we must disable the focus trap as soon as the overlay is closing
        this.overlay?.closing
            .pipe(safeTakeUntilDestroyed())
            .subscribe(() => this.focusTrap.deactivate());
    }
    ngOnInit() {
        focusTrapStack.add(this.focusTrap);
        this.mutationObserver = new MutationObserver(this.handleMutations.bind(this));
        // setup event listeners
        this.ngZone.runOutsideAngular(() => {
            this.mutationObserver.observe(this.elementRef.nativeElement, {
                childList: true,
                subtree: true,
            });
            document.addEventListener('focusin', this.handleFocusIn.bind(this));
            document.addEventListener('focusout', this.handleFocusOut.bind(this));
        });
        const previouslyFocusedElement = document.activeElement;
        const hasFocusedCandidate = this.elementRef.nativeElement.contains(previouslyFocusedElement);
        if (!hasFocusedCandidate) {
            // we do this to ensure the content is rendered before we try to find the first focusable element
            // and focus it
            afterNextRender({
                write: () => {
                    this.focusFirst();
                    // if the focus didn't change, focus the container
                    if (document.activeElement === previouslyFocusedElement) {
                        this.focus(this.elementRef.nativeElement);
                    }
                },
            }, { injector: this.injector });
        }
    }
    ngOnDestroy() {
        focusTrapStack.remove(this.focusTrap);
        this.mutationObserver?.disconnect();
        this.mutationObserver = null;
        this.focusTrap.deactivate();
    }
    handleFocusIn(event) {
        if (!this.focusTrap.active || this.state.disabled()) {
            return;
        }
        const target = event.target;
        if (this.elementRef.nativeElement.contains(target)) {
            this.lastFocusedElement = target;
        }
        else {
            this.focus(this.lastFocusedElement);
        }
    }
    /**
     * Handles the `focusout` event.
     */
    handleFocusOut(event) {
        if (!this.focusTrap.active || this.state.disabled() || event.relatedTarget === null) {
            return;
        }
        const relatedTarget = event.relatedTarget;
        if (!this.elementRef.nativeElement.contains(relatedTarget)) {
            this.focus(this.lastFocusedElement);
        }
    }
    /**
     * If the focused element gets removed from the DOM, browsers move focus back to the document.body.
     * We move focus to the container to keep focus trapped correctly.
     */
    handleMutations(mutations) {
        const focusedElement = document.activeElement;
        if (focusedElement !== document.body) {
            return;
        }
        for (const mutation of mutations) {
            if (mutation.removedNodes.length > 0) {
                this.focus(this.elementRef.nativeElement);
            }
        }
    }
    /**
     * Handles the `keydown` event.
     */
    handleKeyDown(event) {
        if (!this.focusTrap.active || this.state.disabled()) {
            return;
        }
        const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;
        const focusedElement = document.activeElement;
        if (isTabKey && focusedElement) {
            const container = event.currentTarget;
            const [first, last] = this.getTabbableEdges(container);
            const hasTabbableElementsInside = first && last;
            // we can only wrap focus if we have tabbable edges
            if (!hasTabbableElementsInside) {
                if (focusedElement === container) {
                    event.preventDefault();
                }
            }
            else {
                if (!event.shiftKey && focusedElement === last) {
                    event.preventDefault();
                    this.focus(first);
                }
                else if (event.shiftKey && focusedElement === first) {
                    event.preventDefault();
                    this.focus(last);
                }
            }
        }
    }
    /**
     * Returns the first and last tabbable elements inside a container.
     */
    getTabbableEdges(container) {
        const candidates = this.getTabbableCandidates(container);
        const first = this.findVisible(candidates);
        const last = this.findVisible(candidates.reverse());
        return [first, last];
    }
    /**
     * Returns a list of potential focusable elements inside a container.
     */
    getTabbableCandidates(container) {
        const nodes = [];
        const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {
            acceptNode: (node) => this.interactivityChecker.isFocusable(node)
                ? NodeFilter.FILTER_ACCEPT
                : NodeFilter.FILTER_SKIP,
        });
        while (walker.nextNode()) {
            nodes.push(walker.currentNode);
        }
        return nodes;
    }
    /**
     * Returns the first visible element in a list..
     */
    findVisible(elements) {
        return elements.find(element => this.interactivityChecker.isVisible(element)) ?? null;
    }
    focus(element) {
        if (!element) {
            return;
        }
        // Its not great that we are relying on an internal API here, but we need to in order to
        // try and best determine the focus origin when it is programmatically closed by the user.
        this.focusMonitor.focusVia(element, this.focusMonitor._lastFocusOrigin, {
            preventScroll: true,
        });
    }
    focusFirst() {
        const previouslyFocusedElement = document.activeElement;
        for (const candidate of this.getTabbableCandidates(this.elementRef.nativeElement)) {
            this.focus(candidate);
            if (document.activeElement !== previouslyFocusedElement) {
                return;
            }
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocusTrap, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpFocusTrap, isStandalone: true, selector: "[ngpFocusTrap]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpFocusTrapDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keydown": "handleKeyDown($event)" }, properties: { "attr.tabindex": "-1", "attr.data-focus-trap": "!disabled() ? \"\" : null" } }, providers: [provideFocusTrapState()], exportAs: ["ngpFocusTrap"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocusTrap, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpFocusTrap]',
                    exportAs: 'ngpFocusTrap',
                    providers: [provideFocusTrapState()],
                    host: {
                        '[attr.tabindex]': '-1',
                        '[attr.data-focus-trap]': '!disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handleKeyDown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpFocusTrap, injectFocusTrapState, provideFocusTrapState };
//# sourceMappingURL=ng-primitives-focus-trap.mjs.map
