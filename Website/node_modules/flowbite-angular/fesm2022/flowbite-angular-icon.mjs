import { createTheme, mergeDeep, colorToTheme } from 'flowbite-angular';
import * as i0 from '@angular/core';
import { InjectionToken, inject, Injector, Renderer2, PLATFORM_ID, ElementRef, input, computed, effect, HostAttributeToken, runInInjectionContext, ChangeDetectionStrategy, ViewEncapsulation, Component } from '@angular/core';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { isPlatformServer } from '@angular/common';
import { injectNgIcons, injectNgIconLoader, injectNgIconLoaderCache } from '@ng-icons/core';
import { isObservable, firstValueFrom } from 'rxjs';
import { twMerge } from 'tailwind-merge';

const flowbiteIconTheme = createTheme({
    host: {
        base: 'self-center overflow-hidden',
        transition: '',
        color: {
            default: {
                light: '',
                dark: '',
            },
            info: {
                light: 'text-blue-500',
                dark: 'dark:text-blue-500',
            },
            failure: {
                light: 'text-red-500',
                dark: 'dark:text-red-500',
            },
            success: {
                light: 'text-green-500',
                dark: 'dark:text-green-500',
            },
            warning: {
                light: 'text-yellow-500',
                dark: 'dark:text-yellow-500',
            },
            primary: {
                light: 'text-primary-500',
                dark: 'dark:text-primary-500',
            },
            dark: {
                light: 'text-gray-700',
                dark: 'dark:text-gray-700',
            },
            light: {
                light: 'text-gray-300',
                dark: 'dark:text-gray-300',
            },
            blue: {
                light: 'text-blue-500',
                dark: 'dark:text-blue-500',
            },
            cyan: {
                light: 'text-cyan-500',
                dark: 'dark:text-cyan-500',
            },
            gray: {
                light: 'text-gray-500',
                dark: 'dark:text-gray-500',
            },
            green: {
                light: 'text-green-500',
                dark: 'dark:text-green-500',
            },
            indigo: {
                light: 'text-indigo-500',
                dark: 'dark:text-indigo-500',
            },
            lime: {
                light: 'text-lime-500',
                dark: 'dark:text-lime-500',
            },
            pink: {
                light: 'text-pink-500',
                dark: 'dark:text-pink-500',
            },
            purple: {
                light: 'text-purple-500',
                dark: 'dark:text-purple-500',
            },
            red: {
                light: 'text-red-500',
                dark: 'dark:text-red-500',
            },
            teal: {
                light: 'text-teal-500',
                dark: 'dark:text-teal-500',
            },
            yellow: {
                light: 'text-yellow-500',
                dark: 'dark:text-yellow-500',
            },
        },
    },
});

const defaultFlowbiteIconConfig = {
    baseTheme: flowbiteIconTheme,
    color: 'default',
    customTheme: {},
};
const FlowbiteIconConfigToken = new InjectionToken('FlowbiteIconConfigToken');
/**
 * Provide the default Icon configuration
 * @param config The Icon configuration
 * @returns The provider
 */
const provideFlowbiteIconConfig = (config) => [
    {
        provide: FlowbiteIconConfigToken,
        useValue: { ...defaultFlowbiteIconConfig, ...config },
    },
];
/**
 * Inject the Icon configuration
 * @see {@link defaultFlowbiteIconConfig}
 * @returns The configuration
 */
const injectFlowbiteIconConfig = () => inject(FlowbiteIconConfigToken, { optional: true }) ?? defaultFlowbiteIconConfig;

const FlowbiteIconStateToken = createStateToken('Flowbite Icon');
const provideFlowbiteIconState = createStateProvider(FlowbiteIconStateToken);
const injectFlowbiteIconState = createStateInjector(FlowbiteIconStateToken);
const flowbiteIconState = createState(FlowbiteIconStateToken);
const NgIconPreProcessorToken = new InjectionToken('Ng Icon Pre Processor');
const NgIconPostProcessorToken = new InjectionToken('Ng Icon Post Processor');
function injectNgIconPreProcessor() {
    return inject(NgIconPreProcessorToken, { optional: true }) ?? ((icon) => icon);
}
function injectNgIconPostProcessor() {
    // eslint-disable-next-line @typescript-eslint/no-empty-function
    return inject(NgIconPostProcessorToken, { optional: true }) ?? (() => { });
}

/* https://github.com/ng-icons/ng-icons/blob/main/packages/core/src/lib/components/icon/icon.component.ts */
let uniqueId = 0;
class Icon {
    constructor() {
        this.config = injectFlowbiteIconConfig();
        /** Access the icons */
        this.icons = injectNgIcons();
        /** Access the icon loader if defined */
        this.loader = injectNgIconLoader();
        /** Access the icon cache if defined */
        this.cache = injectNgIconLoaderCache();
        /** Access the pre-processor */
        this.preProcessor = injectNgIconPreProcessor();
        /** Access the post-processor */
        this.postProcessor = injectNgIconPostProcessor();
        /** Access the injector */
        this.injector = inject(Injector);
        /** Access the renderer */
        this.renderer = inject(Renderer2);
        /** Determine the platform we are rendering on */
        this.platform = inject(PLATFORM_ID);
        /** Access the element ref */
        this.elementRef = inject(ElementRef);
        /** A unique id for this instance */
        this.uniqueId = uniqueId++;
        /** Define the name of the icon to display */
        this.name = input();
        /** Define the svg of the icon to display */
        this.svg = input();
        /**
         * @see {@link injectFlowbiteIconConfig}
         */
        this.color = input(this.config.color);
        /**
         * @see {@link injectFlowbiteIconConfig}
         */
        this.customTheme = input(this.config.customTheme);
        this.theme = computed(() => {
            const mergedTheme = mergeDeep(this.config.baseTheme, this.state.customTheme());
            return {
                host: {
                    root: twMerge(mergedTheme.host.base, mergedTheme.host.transition, this.state.color() && colorToTheme(mergedTheme.host.color, this.state.color())),
                },
            };
        });
        this.state = flowbiteIconState(this);
        // update the icon anytime the name or svg changes
        effect(() => this.updateIcon());
        const ariaHidden = inject(new HostAttributeToken('aria-hidden'), {
            optional: true,
        });
        // If the user has not explicitly set aria-hidden, mark the icon as hidden, as this is
        // the right thing to do for the majority of icon use-cases.
        if (!ariaHidden) {
            this.elementRef.nativeElement.setAttribute('aria-hidden', 'true');
        }
    }
    ngOnDestroy() {
        this.svgElement = undefined;
    }
    async updateIcon() {
        const toPropertyName = (str) => str
            .replace(/([^a-zA-Z0-9])+(.)?/g, (_, __, chr) => (chr ? chr.toUpperCase() : ''))
            .replace(/[^a-zA-Z\d]/g, '')
            .replace(/^([A-Z])/, (m) => m.toLowerCase());
        const name = this.name();
        const svg = this.svg();
        // if the svg is defined, insert it into the template
        if (svg !== undefined) {
            this.setSvg(svg);
            return;
        }
        if (name === undefined) {
            return;
        }
        const propertyName = toPropertyName(name);
        for (const icons of [...this.icons].reverse()) {
            if (icons[propertyName]) {
                // insert the SVG into the template
                this.setSvg(icons[propertyName]);
                return;
            }
        }
        // if there is a loader defined, use it to load the icon
        if (this.loader) {
            const result = await this.requestIconFromLoader(name);
            // if the result is a string, insert the SVG into the template
            if (result !== null) {
                this.setSvg(result);
                return;
            }
        }
        // if there is no icon with this name warn the user as they probably forgot to import it
        console.warn(`No icon named ${name} was found. You may need to import it using the withIcons function.`);
    }
    setSvg(svg) {
        // if we are on the server, simply innerHTML the svg as we don't have the
        // level of control over the DOM that we do on the client, in otherwords
        // the approach we take to insert the svg on the client will not work on the server
        if (isPlatformServer(this.platform)) {
            this.elementRef.nativeElement.innerHTML = svg;
            // mark this component as server side rendered
            this.elementRef.nativeElement.setAttribute('data-ng-icon-ssr', '');
            return;
        }
        // if this was previously server side rendered, we should check if the svg is the same
        // if it is, we don't need to do anything
        if (this.elementRef.nativeElement.hasAttribute('data-ng-icon-ssr')) {
            // if it is different, we need to remove the server side rendered flag
            this.elementRef.nativeElement.removeAttribute('data-ng-icon-ssr');
            // retrieve the svg element
            this.svgElement = this.elementRef.nativeElement.querySelector('svg') ?? undefined;
            if (this.elementRef.nativeElement.innerHTML === svg) {
                return;
            }
        }
        // remove the old element
        if (this.svgElement) {
            this.renderer.removeChild(this.elementRef.nativeElement, this.svgElement);
        }
        // if the svg is empty, don't insert anything
        if (svg === '') {
            return;
        }
        const template = this.renderer.createElement('template');
        svg = this.replaceIds(svg);
        this.renderer.setProperty(template, 'innerHTML', this.preProcessor(svg));
        this.svgElement = template.content.firstElementChild;
        this.postProcessor(this.svgElement);
        // insert the element into the dom
        this.renderer.appendChild(this.elementRef.nativeElement, this.svgElement);
    }
    replaceIds(svg) {
        // ids are defined like ID_PLACEHOLDER_0, ID_PLACEHOLDER_1, etc.
        // we need to replace these with the actual ids e.g. ng-icon-0-0, ng-icon-0-1, etc.
        // if there are no ids, we don't need to do anything
        if (!svg.includes('ID_PLACEHOLDER_')) {
            return svg;
        }
        // we can just retain the trailing number as the prefix is always the same
        const regex = /ID_PLACEHOLDER_(\d+)/g;
        // we need to keep track of the ids we have replaced
        const idMap = new Map();
        // find all the matches
        const matches = new Set(svg.match(regex));
        if (matches === null) {
            return svg;
        }
        // replace the ids
        for (const match of matches) {
            const id = match.replace('ID_PLACEHOLDER_', '');
            const placeholder = `ng-icon-${this.uniqueId}-${idMap.size}`;
            idMap.set(id, placeholder);
            svg = svg.replace(new RegExp(match, 'g'), placeholder);
        }
        return svg;
    }
    /**
     * Request the icon from the loader.
     * @param name The name of the icon to load.
     * @returns The SVG content for a given icon name.
     */
    requestIconFromLoader(name) {
        const coerceLoaderResult = (result) => {
            if (typeof result === 'string') {
                return Promise.resolve(result);
            }
            if (isObservable(result)) {
                // toPromise is deprecated, but we can't use lastValueFrom because it's not available in RxJS 6
                // so for now we'll just use toPromise
                return firstValueFrom(result);
            }
            return result;
        };
        return new Promise((resolve) => {
            runInInjectionContext(this.injector, async () => {
                // if we have a cache, check if the icon is already loaded (i.e, it is a string)
                if (this.cache) {
                    const cachedResult = this.cache.get(name);
                    if (typeof cachedResult === 'string') {
                        resolve(cachedResult);
                        return;
                    }
                    // it may be a promise, so we need to await it
                    if (cachedResult instanceof Promise) {
                        const result = await cachedResult;
                        resolve(result);
                        return;
                    }
                }
                const promise = coerceLoaderResult(this.loader(name));
                // store the promise in the cache so if we get repeated calls (e.g. in a loop) before the loader has resolved
                // then don't call the loader function multiple times
                this.cache?.set(name, promise);
                // await the result of the promise
                const result = await promise;
                // if we have a cache, store the result
                this.cache?.set(name, result);
                resolve(result);
            });
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "20.0.6", ngImport: i0, type: Icon, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "17.1.0", version: "20.0.6", type: Icon, isStandalone: true, selector: "flowbite-icon", inputs: { name: { classPropertyName: "name", publicName: "name", isSignal: true, isRequired: false, transformFunction: null }, svg: { classPropertyName: "svg", publicName: "svg", isSignal: true, isRequired: false, transformFunction: null }, color: { classPropertyName: "color", publicName: "color", isSignal: true, isRequired: false, transformFunction: null }, customTheme: { classPropertyName: "customTheme", publicName: "customTheme", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "img" }, properties: { "class": "theme().host.root" } }, providers: [provideFlowbiteIconState()], exportAs: ["flowbiteIcon"], ngImport: i0, template: ``, isInline: true, styles: [":host{display:inline-block;line-height:initial;vertical-align:initial;overflow:hidden}\n", ":host ::ng-deep svg{width:inherit;height:inherit;vertical-align:inherit}\n"], changeDetection: i0.ChangeDetectionStrategy.OnPush, encapsulation: i0.ViewEncapsulation.None }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "20.0.6", ngImport: i0, type: Icon, decorators: [{
            type: Component,
            args: [{ standalone: true, selector: `flowbite-icon`, exportAs: 'flowbiteIcon', hostDirectives: [], imports: [], providers: [provideFlowbiteIconState()], host: {
                        '[class]': `theme().host.root`,
                        role: 'img',
                    }, template: ``, encapsulation: ViewEncapsulation.None, changeDetection: ChangeDetectionStrategy.OnPush, styles: [":host{display:inline-block;line-height:initial;vertical-align:initial;overflow:hidden}\n", ":host ::ng-deep svg{width:inherit;height:inherit;vertical-align:inherit}\n"] }]
        }], ctorParameters: () => [] });

/* Icon */

/**
 * Generated bundle index. Do not edit.
 */

export { FlowbiteIconConfigToken, FlowbiteIconStateToken, Icon, NgIconPostProcessorToken, NgIconPreProcessorToken, defaultFlowbiteIconConfig, flowbiteIconState, flowbiteIconTheme, injectFlowbiteIconConfig, injectFlowbiteIconState, injectNgIconPostProcessor, injectNgIconPreProcessor, provideFlowbiteIconConfig, provideFlowbiteIconState };
//# sourceMappingURL=flowbite-angular-icon.mjs.map
