import { FocusOrigin } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import { NgpDatePickerDateButton } from '../date-picker-date-button/date-picker-date-button';
import * as i0 from "@angular/core";
export declare class NgpDateRangePicker<T> {
    private readonly dateAdapter;
    /**
     * Access the date range picker config.
     */
    private readonly config;
    /**
     * Access the injector.
     */
    private readonly injector;
    /**
     * The minimum date that can be selected.
     */
    readonly min: import("@angular/core").InputSignal<T | undefined>;
    /**
     * The maximum date that can be selected.
     */
    readonly max: import("@angular/core").InputSignal<T | undefined>;
    /**
     * Determine if the date picker is disabled.
     */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * A function that is called to determine if a specific date should be disabled.
     */
    readonly dateDisabled: import("@angular/core").InputSignal<(date: T) => boolean>;
    /**
     * Sets which day starts the week in the calendar.
     * Accepts 0-7 where 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday.
     * Defaults to NgpDatePickerConfig.firstDayOfWeek (default 7 if not overridden).
     * Note: Update calendar header column order when changing from Sunday start.
     * @default 7 (Sunday)
     */
    readonly firstDayOfWeek: import("@angular/core").InputSignalWithTransform<import("../date-picker/date-picker-first-day-of-week").NgpDatePickerFirstDayOfWeekNumber, import("../date-picker/date-picker-first-day-of-week").NgpDatePickerFirstDayOfWeekNumberInput>;
    /**
     * The selected start date
     */
    readonly startDate: import("@angular/core").InputSignal<T | undefined>;
    /**
     * Emit when the date changes.
     */
    readonly startDateChange: import("@angular/core").OutputEmitterRef<T | undefined>;
    /**
     * The selected end date
     */
    readonly endDate: import("@angular/core").InputSignal<T | undefined>;
    /**
     * Emit when the end date changes.
     */
    readonly endDateChange: import("@angular/core").OutputEmitterRef<T | undefined>;
    /**
     * The focused value.
     */
    readonly focusedDate: import("@angular/core").InputSignal<T>;
    /**
     * Emit when the focused date changes.
     */
    readonly focusedDateChange: import("@angular/core").OutputEmitterRef<T>;
    /**
     * Detect the label element.
     * @internal
     */
    readonly label: import("@angular/core").Signal<import("ng-primitives/date-picker").NgpDatePickerLabel<unknown> | undefined>;
    /**
     * Access all the date picker buttons
     */
    private readonly buttons;
    /**
     * The date range picker state.
     */
    private readonly state;
    /**
     * Set the focused date.
     * @param date The date to focus.
     * @internal
     */
    setFocusedDate(date: T, origin: FocusOrigin | undefined, direction: 'forward' | 'backward'): void;
    /**
     * Register a date button.
     * @param button The date button to register.
     * @internal
     */
    registerButton(button: NgpDatePickerDateButton<T>): void;
    /**
     * Unregister a date button.
     * @param button The date button to unregister.
     * @internal
     */
    unregisterButton(button: NgpDatePickerDateButton<T>): void;
    /**
     * Select a date.
     * @param date The date to select.
     * @internal
     */
    /**
     * Handles the selection of a date within the date range picker.
     *
     * Selection logic:
     * - If neither a start date nor an end date is selected:
     *   - Sets the selected date as the start date.
     * - If a start date is selected but no end date:
     *   - If the selected date is after the start date, sets it as the end date.
     *   - If the selected date is before the start date, sets the selected date as the start date
     *     and the previous start date as the end date.
     *   - If the selected date is the same as the start date, sets the selected date as the end date
     *     to select a single date.
     * - If both start and end dates are already selected:
     *   - Resets the selection, setting the selected date as the new start date and clearing the end date.
     *
     * @param date The date to select.
     */
    select(date: T): void;
    /**
     * Determine if a date is selected. A date is selected if it is either the start date or the end date.
     * @param date The date to check.
     * @returns True if the date is selected, false otherwise.
     * @internal
     */
    isSelected(date: T): boolean;
    /**
     * Determine if a date is the start of a range.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isStartOfRange(date: T): boolean;
    /**
     * Determine if a date is the end of a range.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isEndOfRange(date: T): boolean;
    /**
     * Determine if a date is between the start and end dates.
     * @param date The date to check.
     * @returns True if the date is between the start and end dates, false otherwise.
     * @internal
     */
    isBetweenRange(date: T): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgpDateRangePicker<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgpDateRangePicker<any>, "[ngpDateRangePicker]", ["ngpDateRangePicker"], { "min": { "alias": "ngpDateRangePickerMin"; "required": false; "isSignal": true; }; "max": { "alias": "ngpDateRangePickerMax"; "required": false; "isSignal": true; }; "disabled": { "alias": "ngpDateRangePickerDisabled"; "required": false; "isSignal": true; }; "dateDisabled": { "alias": "ngpDateRangePickerDateDisabled"; "required": false; "isSignal": true; }; "firstDayOfWeek": { "alias": "ngpDateRangePickerFirstDayOfWeek"; "required": false; "isSignal": true; }; "startDate": { "alias": "ngpDateRangePickerStartDate"; "required": false; "isSignal": true; }; "endDate": { "alias": "ngpDateRangePickerEndDate"; "required": false; "isSignal": true; }; "focusedDate": { "alias": "ngpDateRangePickerFocusedDate"; "required": false; "isSignal": true; }; }, { "startDateChange": "ngpDateRangePickerStartDateChange"; "endDateChange": "ngpDateRangePickerEndDateChange"; "focusedDateChange": "ngpDateRangePickerFocusedDateChange"; }, ["label"], never, true, never>;
}
