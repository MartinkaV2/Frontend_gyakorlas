import * as i0 from '@angular/core';
import { input, output, booleanAttribute, Directive, computed, HostListener } from '@angular/core';
import { setupFormControl } from 'ng-primitives/form-field';
import * as i1 from 'ng-primitives/roving-focus';
import { injectRovingFocusGroupState, NgpRovingFocusGroup, NgpRovingFocusItem } from 'ng-primitives/roving-focus';
import { uniqueId } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import * as i2 from 'ng-primitives/interactions';
import { NgpHover, NgpPress, NgpFocusVisible } from 'ng-primitives/interactions';

/**
 * The state token  for the RadioGroup primitive.
 */
const NgpRadioGroupStateToken = createStateToken('RadioGroup');
/**
 * Provides the RadioGroup state.
 */
const provideRadioGroupState = createStateProvider(NgpRadioGroupStateToken);
/**
 * Injects the RadioGroup state.
 */
const injectRadioGroupState = createStateInjector(NgpRadioGroupStateToken);
/**
 * The RadioGroup state registration function.
 */
const radioGroupState = createState(NgpRadioGroupStateToken);

/**
 * Apply the `ngpRadioGroup` directive to an element that represents the group of radio items.
 */
class NgpRadioGroup {
    constructor() {
        /**
         * Access the roving focus group state.
         */
        this.rovingFocusGroupState = injectRovingFocusGroupState();
        /**
         * The id of the radio group. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-radio-group'));
        /**
         * The value of the radio group.
         */
        this.value = input(null, { alias: 'ngpRadioGroupValue' });
        /**
         * Event emitted when the radio group value changes.
         */
        this.valueChange = output({
            alias: 'ngpRadioGroupValueChange',
        });
        /**
         * Whether the radio group is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpRadioGroupDisabled',
            transform: booleanAttribute,
        });
        /**
         * The orientation of the radio group.
         * @default 'horizontal'
         */
        this.orientation = input('horizontal', {
            alias: 'ngpRadioGroupOrientation',
        });
        /**
         * The comparator function for the radio group. This is useful if values are objects and you want to compare them by value, not by reference.
         * @default (a, b) => a === b
         */
        this.compareWith = input((a, b) => a === b, {
            alias: 'ngpRadioGroupCompareWith',
        });
        /**
         * The state of the radio group.
         * @internal
         */
        this.state = radioGroupState(this);
        setupFormControl({ id: this.state.id, disabled: this.state.disabled });
    }
    ngOnInit() {
        // the roving focus group defaults to vertical orientation whereas we want to default to vertical
        this.rovingFocusGroupState().orientation.set(this.state.orientation());
    }
    /**
     * Select a radio item.
     * @param value The value of the radio item to select.
     */
    select(value) {
        // if the value is already selected, do nothing
        if (this.state.compareWith()(this.state.value(), value)) {
            return;
        }
        this.state.value.set(value);
        this.valueChange.emit(value);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRadioGroup, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpRadioGroup, isStandalone: true, selector: "[ngpRadioGroup]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpRadioGroupValue", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpRadioGroupDisabled", isSignal: true, isRequired: false, transformFunction: null }, orientation: { classPropertyName: "orientation", publicName: "ngpRadioGroupOrientation", isSignal: true, isRequired: false, transformFunction: null }, compareWith: { classPropertyName: "compareWith", publicName: "ngpRadioGroupCompareWith", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { valueChange: "ngpRadioGroupValueChange" }, host: { attributes: { "role": "radiogroup" }, properties: { "id": "id()", "attr.aria-orientation": "state.orientation()", "attr.data-orientation": "state.orientation()", "attr.data-disabled": "state.disabled() ? \"\" : null" } }, providers: [provideRadioGroupState()], hostDirectives: [{ directive: i1.NgpRovingFocusGroup, inputs: ["ngpRovingFocusGroupOrientation", "ngpRadioGroupOrientation", "ngpRovingFocusGroupDisabled", "ngpRadioGroupDisabled"] }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRadioGroup, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRadioGroup]',
                    providers: [provideRadioGroupState()],
                    hostDirectives: [
                        {
                            directive: NgpRovingFocusGroup,
                            inputs: [
                                'ngpRovingFocusGroupOrientation:ngpRadioGroupOrientation',
                                'ngpRovingFocusGroupDisabled:ngpRadioGroupDisabled',
                            ],
                        },
                    ],
                    host: {
                        role: 'radiogroup',
                        '[id]': 'id()',
                        '[attr.aria-orientation]': 'state.orientation()',
                        '[attr.data-orientation]': 'state.orientation()',
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * The state token  for the RadioItem primitive.
 */
const NgpRadioItemStateToken = createStateToken('RadioItem');
/**
 * Provides the RadioItem state.
 */
const provideRadioItemState = createStateProvider(NgpRadioItemStateToken);
/**
 * Injects the RadioItem state.
 */
const injectRadioItemState = createStateInjector(NgpRadioItemStateToken);
/**
 * The RadioItem state registration function.
 */
const radioItemState = createState(NgpRadioItemStateToken);

/**
 * Apply the `ngpRadioIndicator` directive to an element that represents the radio indicator (i.e. the dot).
 */
class NgpRadioIndicator {
    constructor() {
        /**
         * Access the radio group state.
         */
        this.radioGroupState = injectRadioGroupState();
        /**
         * Access the radio group item state
         */
        this.radioItemState = injectRadioItemState();
        /**
         * Determine if the radio indicator is checked.
         */
        this.checked = computed(() => this.radioGroupState().value() === this.radioItemState().value());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRadioIndicator, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpRadioIndicator, isStandalone: true, selector: "[ngpRadioIndicator]", host: { properties: { "attr.data-checked": "checked() ? \"\" : null", "attr.data-disabled": "radioItemState().disabled() ? \"\" : null" } }, hostDirectives: [{ directive: i2.NgpHover }, { directive: i2.NgpPress }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRadioIndicator, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRadioIndicator]',
                    host: {
                        '[attr.data-checked]': 'checked() ? "" : null',
                        '[attr.data-disabled]': 'radioItemState().disabled() ? "" : null',
                    },
                    hostDirectives: [NgpHover, NgpPress],
                }]
        }] });

/**
 * Apply the `ngpRadioItem` directive to an element that represents a radio item. This would typically be a `button` element.
 */
class NgpRadioItem {
    constructor() {
        /**
         * Access the radio group state.
         */
        this.radioGroupState = injectRadioGroupState();
        /**
         * The value of the radio item.
         * @required
         */
        this.value = input(undefined, { alias: 'ngpRadioItemValue' });
        /**
         * Whether the radio item is disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpRadioItemDisabled',
            transform: booleanAttribute,
        });
        /**
         * Whether the radio item is checked.
         */
        this.checked = computed(() => this.radioGroupState().compareWith()(this.radioGroupState().value(), this.state.value()));
        /**
         * The state of the radio item.
         */
        this.state = radioItemState(this);
    }
    ngOnInit() {
        if (this.state.value() === undefined) {
            throw new Error('The `ngpRadioItem` directive requires a `value` input.');
        }
    }
    /**
     * When the item receives focus, select it.
     * @internal
     */
    onFocus() {
        this.radioGroupState().select(this.state.value());
    }
    /**
     * When the item receives a click, select it.
     * @internal
     */
    onClick() {
        this.radioGroupState().select(this.state.value());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRadioItem, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpRadioItem, isStandalone: true, selector: "[ngpRadioItem]", inputs: { value: { classPropertyName: "value", publicName: "ngpRadioItemValue", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpRadioItemDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "radio" }, listeners: { "focus": "onFocus()", "click": "onClick()" }, properties: { "attr.aria-checked": "checked() ? \"true\" : \"false\"", "attr.data-disabled": "state.disabled() ? \"\" : null", "attr.data-checked": "checked() ? \"\" : null" } }, providers: [provideRadioItemState()], hostDirectives: [{ directive: i1.NgpRovingFocusItem }, { directive: i2.NgpHover }, { directive: i2.NgpFocusVisible }, { directive: i2.NgpPress }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRadioItem, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRadioItem]',
                    hostDirectives: [NgpRovingFocusItem, NgpHover, NgpFocusVisible, NgpPress],
                    providers: [provideRadioItemState()],
                    host: {
                        role: 'radio',
                        '[attr.aria-checked]': 'checked() ? "true" : "false"',
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                        '[attr.data-checked]': 'checked() ? "" : null',
                    },
                }]
        }], propDecorators: { onFocus: [{
                type: HostListener,
                args: ['focus']
            }], onClick: [{
                type: HostListener,
                args: ['click']
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpRadioGroup, NgpRadioIndicator, NgpRadioItem, injectRadioGroupState, injectRadioItemState, provideRadioGroupState, provideRadioItemState };
//# sourceMappingURL=ng-primitives-radio.mjs.map
