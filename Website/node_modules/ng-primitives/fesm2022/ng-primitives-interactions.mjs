import * as i0 from '@angular/core';
import { InjectionToken, inject, signal, ElementRef, Renderer2, PLATFORM_ID, Injectable, effect, input, booleanAttribute, output, Directive, HostListener } from '@angular/core';
import { onDomRemoval, injectElementRef } from 'ng-primitives/internal';
import { FocusMonitor } from '@angular/cdk/a11y';
import { safeTakeUntilDestroyed, onBooleanChange, injectDisposables } from 'ng-primitives/utils';
import { DOCUMENT, isPlatformBrowser } from '@angular/common';

const defaultInteractionsConfig = {
    disabled: false,
    hover: true,
    focus: true,
    focusVisible: true,
    press: true,
};
const NgpInteractionsConfigToken = new InjectionToken('NgpInteractionsConfigToken');
/**
 * Provide the default Interactions configuration
 * @param config The Interactions configuration
 * @returns The provider
 */
function provideInteractionsConfig(config) {
    return [
        {
            provide: NgpInteractionsConfigToken,
            useValue: { ...defaultInteractionsConfig, ...config },
        },
    ];
}
/**
 * Inject the Interactions configuration
 * @returns The global Interactions configuration
 */
function injectInteractionsConfig() {
    return inject(NgpInteractionsConfigToken, { optional: true }) ?? defaultInteractionsConfig;
}
function isHoverEnabled() {
    const config = injectInteractionsConfig();
    return !config.disabled && !!config.hover;
}
function isFocusEnabled() {
    const config = injectInteractionsConfig();
    return !config.disabled && !!config.focus;
}
function isFocusVisibleEnabled() {
    const config = injectInteractionsConfig();
    return !config.disabled && !!config.focusVisible;
}
function isPressEnabled() {
    const config = injectInteractionsConfig();
    return !config.disabled && !!config.press;
}

/**
 * @internal
 */
function ngpFocusVisibleInteraction({ focusChange, disabled = signal(false), }) {
    const canFocusVisible = isFocusVisibleEnabled();
    if (!canFocusVisible) {
        return { isFocused: signal(false) };
    }
    const elementRef = inject(ElementRef);
    const renderer = inject(Renderer2);
    const focusMonitor = inject(FocusMonitor);
    // Whether the element is currently focused.
    const isFocused = signal(false);
    // handle focus state
    focusMonitor
        .monitor(elementRef.nativeElement)
        .pipe(safeTakeUntilDestroyed())
        .subscribe(origin => 
    // null indicates the element was blurred
    origin === null ? onBlur() : onFocus(origin));
    // if the component becomes disabled and it is focused, hide the focus
    onBooleanChange(disabled, () => focus(false));
    function onFocus(origin) {
        if (disabled() || isFocused()) {
            return;
        }
        // for some elements the focus visible state should always appear on focus
        if (alwaysShowFocus()) {
            focus(true);
            return;
        }
        // if the focus origin is keyboard or program(focused programmatically), then the focus is visible
        if (origin === 'keyboard') {
            focus(true);
            return;
        }
    }
    function onBlur() {
        if (disabled() || !isFocused()) {
            return;
        }
        focus(false);
    }
    /**
     * Trigger the focus signal along with the focusChange event.
     */
    function focus(value) {
        if (isFocused() === value) {
            return;
        }
        isFocused.set(value);
        focusChange?.(value);
        if (value) {
            renderer.setAttribute(elementRef.nativeElement, 'data-focus-visible', '');
        }
        else {
            renderer.removeAttribute(elementRef.nativeElement, 'data-focus-visible');
        }
    }
    function alwaysShowFocus() {
        const nonTextInputTypes = [
            'checkbox',
            'radio',
            'range',
            'color',
            'file',
            'image',
            'button',
            'submit',
            'reset',
        ];
        // if this is an input element and it is a text input
        if (elementRef.nativeElement instanceof HTMLInputElement &&
            !nonTextInputTypes.includes(elementRef.nativeElement.type)) {
            return true;
        }
        // if this is a textarea
        if (elementRef.nativeElement instanceof HTMLTextAreaElement) {
            return true;
        }
        // if this is an element with contenteditable
        if (elementRef.nativeElement.isContentEditable ||
            elementRef.nativeElement.hasAttribute('contenteditable')) {
            return true;
        }
        return false;
    }
    return {
        isFocused,
    };
}

/**
 * @internal
 */
function ngpFocusInteraction({ focus, blur, focusWithin = false, disabled = signal(false), }) {
    const canFocus = isFocusEnabled();
    if (!canFocus) {
        return { isFocused: signal(false) };
    }
    /**
     * Access the element reference.
     */
    const elementRef = inject(ElementRef);
    /**
     * Access the focus monitor.
     */
    const focusMonitor = inject(FocusMonitor);
    /**
     * Access the renderer.
     */
    const renderer = inject(Renderer2);
    /**
     * Whether the element is currently focused.
     */
    const isFocused = signal(false);
    focusMonitor
        .monitor(elementRef, focusWithin)
        .pipe(safeTakeUntilDestroyed())
        .subscribe(focusOrigin => {
        if (disabled()) {
            return;
        }
        isFocused.set(focusOrigin !== null);
        if (focusOrigin !== null) {
            if (focus) {
                focus();
            }
            renderer.setAttribute(elementRef.nativeElement, 'data-focus', '');
        }
        else {
            if (blur) {
                blur();
            }
            renderer.removeAttribute(elementRef.nativeElement, 'data-focus');
        }
    });
    return { isFocused };
}

/**
 * We use a service here as this value is a singleton
 * and allows us to register the dom events once.
 */
class GlobalPointerEvents {
    constructor() {
        /**
         * Whether global mouse events should be ignored.
         */
        this.ignoreEmulatedMouseEvents = false;
        /**
         * Access the document.
         */
        this.document = inject(DOCUMENT);
        /**
         * Determine the platform id.
         */
        this.platformId = inject(PLATFORM_ID);
        // we only want to setup events on the client
        if (isPlatformBrowser(this.platformId)) {
            this.setupGlobalTouchEvents();
        }
    }
    setupGlobalTouchEvents() {
        this.document.addEventListener('pointerup', this.handleGlobalPointerEvent.bind(this));
        this.document.addEventListener('touchend', this.setGlobalIgnoreEmulatedMouseEvents.bind(this));
    }
    setGlobalIgnoreEmulatedMouseEvents() {
        this.ignoreEmulatedMouseEvents = true;
        // Clear globalIgnoreEmulatedMouseEvents after a short timeout. iOS fires onPointerEnter
        // with pointerType="mouse" immediately after onPointerUp and before onFocus. On other
        // devices that don't have this quirk, we don't want to ignore a mouse hover sometime in
        // the distant future because a user previously touched the element.
        setTimeout(() => (this.ignoreEmulatedMouseEvents = false), 50);
    }
    handleGlobalPointerEvent(event) {
        if (event.pointerType === 'touch') {
            this.setGlobalIgnoreEmulatedMouseEvents();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: GlobalPointerEvents, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: GlobalPointerEvents, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: GlobalPointerEvents, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });
/**
 * Programatically add the hover functionality to an element.
 * This is useful in cases where we can't necessarily use a HostDirective,
 * because there is a chance the directive has already been used.
 * @internal
 */
function ngpHoverInteraction({ hoverStart, hoverEnd, disabled = signal(false), }) {
    const canHover = isHoverEnabled();
    if (!canHover) {
        return { hovered: signal(false) };
    }
    /**
     * Access the element.
     */
    const elementRef = inject(ElementRef);
    /**
     * Access the global pointer events handler.
     */
    const globalPointerEvents = inject(GlobalPointerEvents);
    /**
     * Access the disposable helper.
     */
    const disposables = injectDisposables();
    /**
     * Store the current hover state.
     */
    const hovered = signal(false);
    /**
     * Whether this element should ignore emulated mouse events.
     */
    let ignoreEmulatedMouseEvents = false;
    /**
     * Setup event listeners.
     */
    disposables.addEventListener(elementRef.nativeElement, 'pointerenter', onPointerEnter);
    disposables.addEventListener(elementRef.nativeElement, 'pointerleave', onPointerLeave);
    disposables.addEventListener(elementRef.nativeElement, 'touchstart', onTouchStart);
    disposables.addEventListener(elementRef.nativeElement, 'mouseenter', onMouseEnter);
    disposables.addEventListener(elementRef.nativeElement, 'mouseleave', onMouseLeave);
    // anytime the disabled state changes to true, we must reset the hover state
    if (disabled) {
        onBooleanChange(disabled, reset);
    }
    // if the element is removed from the dom, we want to reset the hover state
    onDomRemoval(elementRef.nativeElement, reset);
    // anytime the hover state changes we want to update the attribute
    effect(() => hovered()
        ? elementRef.nativeElement.setAttribute('data-hover', '')
        : elementRef.nativeElement.removeAttribute('data-hover'));
    /**
     * Reset the hover state.
     */
    function reset() {
        onHoverEnd('mouse');
    }
    /**
     * Trigger the hover start events.
     * @param event
     * @param pointerType
     */
    function onHoverStart(event, pointerType) {
        if (disabled() ||
            pointerType === 'touch' ||
            hovered() ||
            !event.currentTarget?.contains(event.target)) {
            return;
        }
        hovered.set(true);
        hoverStart?.();
    }
    /**
     * Trigger the hover end events.
     * @param pointerType
     */
    function onHoverEnd(pointerType) {
        if (pointerType === 'touch' || !hovered()) {
            return;
        }
        hovered.set(false);
        hoverEnd?.();
    }
    function onPointerEnter(event) {
        if (globalPointerEvents.ignoreEmulatedMouseEvents && event.pointerType === 'mouse') {
            return;
        }
        onHoverStart(event, event.pointerType);
    }
    function onPointerLeave(event) {
        if (!disabled() && event.currentTarget?.contains(event.target)) {
            onHoverEnd(event.pointerType);
        }
    }
    function onTouchStart() {
        ignoreEmulatedMouseEvents = true;
    }
    function onMouseEnter(event) {
        if (!ignoreEmulatedMouseEvents && !globalPointerEvents.ignoreEmulatedMouseEvents) {
            onHoverStart(event, 'mouse');
        }
        ignoreEmulatedMouseEvents = false;
    }
    function onMouseLeave(event) {
        if (!disabled() && event.currentTarget?.contains(event.target)) {
            onHoverEnd('mouse');
        }
    }
    return { hovered };
}

/**
 * @internal
 */
function ngpPressInteraction({ pressStart, pressEnd, disabled = signal(false), }) {
    const canPress = isPressEnabled();
    if (!canPress) {
        return { pressed: signal(false) };
    }
    const elementRef = inject(ElementRef);
    const disposables = injectDisposables();
    /**
     * Whether the element is currently pressed.
     */
    const pressed = signal(false);
    // setup event listeners
    disposables.addEventListener(elementRef.nativeElement, 'pointerdown', onPointerDown);
    // anytime the press state changes we want to update the attribute
    effect(() => pressed() && !disabled()
        ? elementRef.nativeElement.setAttribute('data-press', '')
        : elementRef.nativeElement.removeAttribute('data-press'));
    /**
     * Reset the press state.
     */
    function reset() {
        // if we are not pressing, then do nothing
        if (!pressed()) {
            return;
        }
        // clear any existing disposables
        disposableListeners.forEach(dispose => dispose());
        pressed.set(false);
        pressEnd?.();
    }
    /**
     * Store the list of disposables.
     */
    let disposableListeners = [];
    function onPointerDown() {
        if (disabled()) {
            return;
        }
        // clear any existing disposables
        disposableListeners.forEach(dispose => dispose());
        // update the press state
        pressed.set(true);
        pressStart?.();
        // setup global event listeners to catch events on elements outside the directive
        const ownerDocument = elementRef.nativeElement.ownerDocument ?? document;
        // if the pointer up event happens on any elements, then we are no longer pressing on this element
        const pointerUp = disposables.addEventListener(ownerDocument, 'pointerup', () => reset(), false);
        // Instead of relying on the `pointerleave` event, which is not consistently called on iOS Safari,
        // we use the `pointermove` event to determine if we are still "pressing".
        // By checking if the target is still within the element, we can determine if the press is ongoing.
        const pointerMove = disposables.addEventListener(ownerDocument, 'pointermove', () => onPointerMove, false);
        // if the pointer is cancelled, then we are no longer pressing on this element
        const pointerCancel = disposables.addEventListener(ownerDocument, 'pointercancel', () => reset(), false);
        disposableListeners = [pointerUp, pointerMove, pointerCancel];
    }
    function onPointerMove(event) {
        if (elementRef.nativeElement !== event.target &&
            !elementRef.nativeElement.contains(event.target)) {
            reset();
        }
    }
    return { pressed };
}

/**
 * Setup the interactions without relying on HostDirectives.
 * @internal
 */
function ngpInteractions({ focus, hover, press, focusWithin, focusVisible, disabled = signal(false), }) {
    const elementRef = injectElementRef();
    // If the interaction has already been setup, we can skip the setup.
    if (hasInteraction(elementRef.nativeElement, 'interactions')) {
        return;
    }
    if (hover) {
        ngpHoverInteraction({ disabled });
    }
    if (press) {
        ngpPressInteraction({ disabled });
    }
    if (focus) {
        ngpFocusInteraction({ focusWithin, disabled });
    }
    if (focusVisible) {
        ngpFocusVisibleInteraction({ disabled });
    }
}
/**
 * This function checks to see if a given interaction has already been setup on a given element.
 * If it has, it returns the existing interaction state.
 * If it has not, it sets up the interaction state for future checks.
 */
function hasInteraction(element, interaction) {
    const hasInteraction = `__ngp-${interaction}` in element;
    // if the interaction has not been setup, we mark it as setup for future checks
    if (!hasInteraction) {
        element[`__ngp-${interaction}`] = true;
    }
    return hasInteraction;
}

/**
 * Apply the `ngpFocusVisible` directive to an element that should be visually focused. This is similar to `ngpFocus`
 * but it will only apply the focus visible styles when the element is focused via keyboard navigation.
 */
class NgpFocusVisible {
    constructor() {
        /**
         * Whether focus events are listened to.
         */
        this.disabled = input(false, {
            alias: 'ngpFocusVisibleDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the element is visually focused.
         */
        this.focusChange = output({
            alias: 'ngpFocusVisible',
        });
        // setup the focus visible listener
        ngpFocusVisibleInteraction({
            disabled: this.disabled,
            focusChange: value => this.focusChange.emit(value),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocusVisible, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpFocusVisible, isStandalone: true, selector: "[ngpFocusVisible]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpFocusVisibleDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { focusChange: "ngpFocusVisible" }, exportAs: ["ngpFocusVisible"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocusVisible, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpFocusVisible]',
                    exportAs: 'ngpFocusVisible',
                }]
        }], ctorParameters: () => [] });

/**
 * This was inspired by the React Aria useFocus hook.
 * https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useFocus.ts#L20
 */
class NgpFocus {
    constructor() {
        /**
         * Whether listening for focus events is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpFocusDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the focus state changes.
         */
        this.focus = output({ alias: 'ngpFocus' });
        // setup the focus listener
        ngpFocusInteraction({
            disabled: this.disabled,
            focus: () => this.focus.emit(true),
            blur: () => this.focus.emit(false),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocus, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpFocus, isStandalone: true, selector: "[ngpFocus]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpFocusDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { focus: "ngpFocus" }, exportAs: ["ngpFocus"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocus, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpFocus]',
                    exportAs: 'ngpFocus',
                }]
        }], ctorParameters: () => [] });

// This is an Angular port of the useHover hook from react-aria: https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useHover.ts
/**
 * Apply the `ngpHover` directive to an element that you want to listen for hover events. T
 * his is particulaly useful for supporting hover events on touch devices, where hover events are not handled consistently.
 * On iOS relying on the `:hover` pseudo-class can result in the hover state being stuck until the user taps elsewhere on the screen.
 */
class NgpHover {
    /**
     * Setup the hover state.
     */
    constructor() {
        /**
         * Whether hoving should be disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpHoverDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit an event when hovering starts.
         */
        this.hoverStart = output({ alias: 'ngpHoverStart' });
        /**
         * Emit an event when hovering ends.
         */
        this.hoverEnd = output({ alias: 'ngpHoverEnd' });
        /**
         * Emit an event when the hover state changes.
         */
        this.hoverChange = output({ alias: 'ngpHover' });
        // setup the hover listener
        ngpHoverInteraction({
            hoverStart: () => {
                this.hoverStart.emit();
                this.hoverChange.emit(true);
            },
            hoverEnd: () => {
                this.hoverEnd.emit();
                this.hoverChange.emit(false);
            },
            disabled: this.disabled,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpHover, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpHover, isStandalone: true, selector: "[ngpHover]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpHoverDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { hoverStart: "ngpHoverStart", hoverEnd: "ngpHoverEnd", hoverChange: "ngpHover" }, exportAs: ["ngpHover"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpHover, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpHover]',
                    exportAs: 'ngpHover',
                }]
        }], ctorParameters: () => [] });

// Inspired by react-aria useMove hook: https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useMove.ts
/**
 * The `NgpMove` directive is used to enable the pointer and keyboard move interactions on an element.
 */
class NgpMove {
    constructor() {
        /**
         * Access the disposable helper.
         */
        this.disposables = injectDisposables();
        /**
         * Whether movement is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpMoveDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the move event begins.
         */
        this.start = output({
            alias: 'ngpMoveStart',
        });
        /**
         * Emit when the element is moved.
         */
        this.move = output({
            alias: 'ngpMove',
        });
        /**
         * Emit when the move event ends.
         */
        this.end = output({
            alias: 'ngpMoveEnd',
        });
        /**
         * Whether the element is currently being moved.
         */
        this.isMoving = signal(false);
        /**
         * Store the last x position of the element.
         */
        this.x = null;
        /**
         * Store the last y position of the element.
         */
        this.y = null;
        /**
         * Store the id of the last pointer.
         */
        this.pointerId = null;
        /**
         * Store the disposable event listeners.
         */
        this.disposableListeners = [];
    }
    /**
     * Handle a move start.
     */
    onMoveStart(event, pointerType) {
        this.start.emit({
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
        this.isMoving.set(true);
    }
    /**
     * Handle a move event.
     */
    onMove(event, pointerType, deltaX, deltaY) {
        if (deltaX === 0 && deltaY === 0) {
            return;
        }
        this.move.emit({
            deltaX,
            deltaY,
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
    }
    /**
     * Handle a move end.
     */
    onMoveEnd(event, pointerType) {
        this.end.emit({
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
        this.isMoving.set(false);
    }
    /**
     * Handle the pointer down event.
     */
    onPointerDown(event) {
        // ignore right-click or additional pointers
        if (event.button !== 0 || this.pointerId !== null || this.disabled()) {
            return;
        }
        // prevent the default behavior
        event.preventDefault();
        event.stopPropagation();
        this.onMoveStart(event, event.pointerType);
        // store the pointer id and initial position
        this.pointerId = event.pointerId;
        this.x = event.pageX;
        this.y = event.pageY;
        // add global event listeners
        const pointerMove = this.disposables.addEventListener(window, 'pointermove', this.onPointerMove.bind(this), false);
        const pointerUp = this.disposables.addEventListener(window, 'pointerup', this.onPointerUp.bind(this), false);
        const pointerCancel = this.disposables.addEventListener(window, 'pointercancel', this.onPointerUp.bind(this), false);
        // store the disposable event listeners
        this.disposableListeners = [pointerMove, pointerUp, pointerCancel];
    }
    /**
     * Handle the pointer up event.
     */
    onPointerUp(event) {
        if (this.pointerId !== event.pointerId) {
            return;
        }
        const pointerType = (event.pointerType ?? 'mouse');
        this.onMoveEnd(event, pointerType);
        this.pointerId = null;
        this.disposableListeners.forEach(dispose => dispose());
    }
    /**
     * Handle the pointer move event.
     */
    onPointerMove(event) {
        if (this.pointerId !== event.pointerId) {
            return;
        }
        // Problems with PointerEvent#movementX/movementY:
        // 1. it is always 0 on macOS Safari.
        // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
        this.onMove(event, event.pointerType, event.pageX - (this.x ?? 0), event.pageY - (this.y ?? 0));
        this.x = event.pageX;
        this.y = event.pageY;
    }
    triggerKeyboardMove(event, deltaX, deltaY) {
        if (this.disabled()) {
            return;
        }
        this.onMoveStart(event, 'keyboard');
        this.onMove(event, 'keyboard', deltaX, deltaY);
        this.onMoveEnd(event, 'keyboard');
    }
    onArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 0, -1);
    }
    onArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 0, 1);
    }
    onArrowLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, -1, 0);
    }
    onArrowRight(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 1, 0);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMove, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpMove, isStandalone: true, selector: "[ngpMove]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpMoveDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { start: "ngpMoveStart", move: "ngpMove", end: "ngpMoveEnd" }, host: { listeners: { "pointerdown": "onPointerDown($event)", "keydown.ArrowUp": "onArrowUp($event)", "keydown.ArrowDown": "onArrowDown($event)", "keydown.ArrowLeft": "onArrowLeft($event)", "keydown.ArrowRight": "onArrowRight($event)" }, properties: { "attr.data-move": "isMoving() ? \"\" : null" } }, exportAs: ["ngpMove"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMove, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMove]',
                    exportAs: 'ngpMove',
                    host: {
                        '[attr.data-move]': 'isMoving() ? "" : null',
                    },
                }]
        }], propDecorators: { onPointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }], onArrowUp: [{
                type: HostListener,
                args: ['keydown.ArrowUp', ['$event']]
            }], onArrowDown: [{
                type: HostListener,
                args: ['keydown.ArrowDown', ['$event']]
            }], onArrowLeft: [{
                type: HostListener,
                args: ['keydown.ArrowLeft', ['$event']]
            }], onArrowRight: [{
                type: HostListener,
                args: ['keydown.ArrowRight', ['$event']]
            }] } });

// This was inpsired by Headless UI's active-press hook: https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-react/src/hooks/use-active-press.tsx
/**
 * The `ngpPress` directive listens for press events on an element. This is particularly useful for supporting press events on touch devices, where press events are not handled consistently.
 */
class NgpPress {
    constructor() {
        /**
         * Whether listening for press events is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpPressDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the press begins.
         */
        this.pressStart = output({
            alias: 'ngpPressStart',
        });
        /**
         * Emit when the press ends.
         */
        this.pressEnd = output({
            alias: 'ngpPressEnd',
        });
        /**
         * Emit when the press changes.
         */
        this.pressChange = output({
            alias: 'ngpPress',
        });
        // setup the press listener
        ngpPressInteraction({
            pressStart: () => {
                this.pressStart.emit();
                this.pressChange.emit(true);
            },
            pressEnd: () => {
                this.pressEnd.emit();
                this.pressChange.emit(false);
            },
            disabled: this.disabled,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPress, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPress, isStandalone: true, selector: "[ngpPress]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpPressDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { pressStart: "ngpPressStart", pressEnd: "ngpPressEnd", pressChange: "ngpPress" }, exportAs: ["ngpPress"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPress, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPress]',
                    exportAs: 'ngpPress',
                }]
        }], ctorParameters: () => [] });

// re-export ngpInteractions as setupInteractions for backwards compatibility

/**
 * Generated bundle index. Do not edit.
 */

export { NgpFocus, NgpFocusVisible, NgpHover, NgpMove, NgpPress, ngpFocusInteraction, ngpFocusVisibleInteraction, ngpHoverInteraction, ngpInteractions, ngpPressInteraction, provideInteractionsConfig, ngpInteractions as setupInteractions };
//# sourceMappingURL=ng-primitives-interactions.mjs.map
