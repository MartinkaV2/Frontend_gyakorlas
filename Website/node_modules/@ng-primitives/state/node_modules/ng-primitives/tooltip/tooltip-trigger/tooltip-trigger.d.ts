import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { OnDestroy, Signal } from '@angular/core';
import { NgpOverlay, NgpOverlayContent } from 'ng-primitives/portal';
import * as i0 from "@angular/core";
type TooltipInput<T> = NgpOverlayContent<T> | string | null | undefined;
/**
 * Apply the `ngpTooltipTrigger` directive to an element that triggers the tooltip to show.
 */
export declare class NgpTooltipTrigger<T = null> implements OnDestroy {
    /**
     * Access the trigger element
     */
    private readonly trigger;
    /**
     * Access the injector.
     */
    private readonly injector;
    /**
     * Access the view container reference.
     */
    private readonly viewContainerRef;
    /**
     * Access the global tooltip configuration.
     */
    private readonly config;
    /**
     * Access the tooltip template ref.
     */
    readonly tooltip: import("@angular/core").InputSignalWithTransform<string | NgpOverlayContent<T> | null, TooltipInput<T>>;
    /**
     * Define if the trigger should be disabled.
     * @default false
     */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Define the placement of the tooltip relative to the trigger.
     * @default 'top'
     */
    readonly placement: import("@angular/core").InputSignal<NgpTooltipPlacement>;
    /**
     * Define the offset of the tooltip relative to the trigger.
     * @default 0
     */
    readonly offset: import("@angular/core").InputSignalWithTransform<number, NumberInput>;
    /**
     * Define the delay before the tooltip is displayed.
     * @default 500
     */
    readonly showDelay: import("@angular/core").InputSignalWithTransform<number, NumberInput>;
    /**
     * Define the delay before the tooltip is hidden.
     * @default 0
     */
    readonly hideDelay: import("@angular/core").InputSignalWithTransform<number, NumberInput>;
    /**
     * Define whether the tooltip should flip when there is not enough space for the tooltip.
     * @default true
     */
    readonly flip: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Define the container in which the tooltip should be attached.
     * @default document.body
     */
    readonly container: import("@angular/core").InputSignal<string | HTMLElement | null>;
    /**
     * Define whether the tooltip should only show when the trigger element overflows.
     * @default false
     */
    readonly showOnOverflow: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Provide context to the tooltip. This can be used to pass data to the tooltip content.
     */
    readonly context: import("@angular/core").InputSignal<T | undefined>;
    /**
     * Define whether to use the text content of the trigger element as the tooltip content.
     * When enabled, the tooltip will display the text content of the trigger element.
     * @default true
     */
    readonly useTextContent: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * The overlay that manages the tooltip
     * @internal
     */
    readonly overlay: import("@angular/core").WritableSignal<NgpOverlay<string | T> | null>;
    /**
     * The unique id of the tooltip.
     */
    readonly tooltipId: import("@angular/core").WritableSignal<string | undefined>;
    /**
     * The open state of the tooltip.
     * @internal
     */
    readonly open: Signal<boolean>;
    /**
     * Determine if the trigger element has overflow.
     */
    private readonly hasOverflow;
    /**
     * Store the state of the tooltip.
     * @internal
     */
    readonly state: import("ng-primitives/state").CreatedState<NgpTooltipTrigger<T>>;
    constructor();
    ngOnDestroy(): void;
    /**
     * Show the tooltip.
     */
    show(): void;
    /**
     * Hide the tooltip.
     */
    hide(): void;
    /**
     * Create the overlay that will contain the tooltip
     */
    private createOverlay;
    /**
     * Set the tooltip id.
     */
    setTooltipId(id: string): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgpTooltipTrigger<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgpTooltipTrigger<any>, "[ngpTooltipTrigger]", ["ngpTooltipTrigger"], { "tooltip": { "alias": "ngpTooltipTrigger"; "required": false; "isSignal": true; }; "disabled": { "alias": "ngpTooltipTriggerDisabled"; "required": false; "isSignal": true; }; "placement": { "alias": "ngpTooltipTriggerPlacement"; "required": false; "isSignal": true; }; "offset": { "alias": "ngpTooltipTriggerOffset"; "required": false; "isSignal": true; }; "showDelay": { "alias": "ngpTooltipTriggerShowDelay"; "required": false; "isSignal": true; }; "hideDelay": { "alias": "ngpTooltipTriggerHideDelay"; "required": false; "isSignal": true; }; "flip": { "alias": "ngpTooltipTriggerFlip"; "required": false; "isSignal": true; }; "container": { "alias": "ngpTooltipTriggerContainer"; "required": false; "isSignal": true; }; "showOnOverflow": { "alias": "ngpTooltipTriggerShowOnOverflow"; "required": false; "isSignal": true; }; "context": { "alias": "ngpTooltipTriggerContext"; "required": false; "isSignal": true; }; "useTextContent": { "alias": "ngpTooltipTriggerUseTextContent"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
export type NgpTooltipPlacement = 'top' | 'right' | 'bottom' | 'left' | 'top-start' | 'top-end' | 'right-start' | 'right-end' | 'bottom-start' | 'bottom-end' | 'left-start' | 'left-end';
export {};
