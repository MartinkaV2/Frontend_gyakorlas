import * as i0 from '@angular/core';
import { InjectionToken, inject, input, Directive, booleanAttribute, HostListener, ApplicationRef, ViewContainerRef, isDevMode, TemplateRef, Injector, Injectable, output, signal } from '@angular/core';
import { uniqueId, onChange } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import * as i1 from 'ng-primitives/internal';
import { NgpExitAnimationManager, NgpExitAnimation } from 'ng-primitives/internal';
import { hasModifierKey } from '@angular/cdk/keycodes';
import { Subject, defer } from 'rxjs';
import { FocusMonitor } from '@angular/cdk/a11y';
import { Overlay, OverlayContainer, OverlayConfig } from '@angular/cdk/overlay';
import { TemplatePortal, ComponentPortal } from '@angular/cdk/portal';
import { DOCUMENT } from '@angular/common';
import { startWith } from 'rxjs/operators';
import * as i1$1 from 'ng-primitives/focus-trap';
import { NgpFocusTrap } from 'ng-primitives/focus-trap';

const defaultDialogConfig = {
    role: 'dialog',
    modal: true,
    closeOnNavigation: true,
    closeOnEscape: true,
    closeOnClick: true,
};
const NgpDialogConfigToken = new InjectionToken('NgpDialogConfigToken');
/**
 * Provide the default Dialog configuration
 * @param config The Dialog configuration
 * @returns The provider
 */
function provideDialogConfig(config) {
    return [
        {
            provide: NgpDialogConfigToken,
            useValue: { ...defaultDialogConfig, ...config },
        },
    ];
}
/**
 * Inject the Dialog configuration
 * @returns The global Dialog configuration
 */
function injectDialogConfig() {
    return inject(NgpDialogConfigToken, { optional: true }) ?? defaultDialogConfig;
}

/**
 * The state token  for the Dialog primitive.
 */
const NgpDialogStateToken = createStateToken('Dialog');
/**
 * Provides the Dialog state.
 */
const provideDialogState = createStateProvider(NgpDialogStateToken);
/**
 * Injects the Dialog state.
 */
const injectDialogState = createStateInjector(NgpDialogStateToken);
/**
 * The Dialog state registration function.
 */
const dialogState = createState(NgpDialogStateToken);

class NgpDialogDescription {
    constructor() {
        /** Access the dialog */
        this.dialog = injectDialogState();
        /** The id of the descriptions. */
        this.id = input(uniqueId('ngp-dialog-description'));
        onChange(this.id, (id, prevId) => {
            if (prevId) {
                this.dialog().removeDescribedBy(prevId);
            }
            if (id) {
                this.dialog().setDescribedBy(id);
            }
        });
    }
    ngOnDestroy() {
        this.dialog().removeDescribedBy(this.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogDescription, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpDialogDescription, isStandalone: true, selector: "[ngpDialogDescription]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "id": "id()" } }, exportAs: ["ngpDialogDescription"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogDescription, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDialogDescription]',
                    exportAs: 'ngpDialogDescription',
                    host: {
                        '[id]': 'id()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Reference to a dialog opened via the Dialog service.
 */
class NgpDialogRef {
    constructor(overlayRef, config) {
        this.overlayRef = overlayRef;
        this.config = config;
        /** Emits when the dialog has been closed. */
        this.closed = new Subject();
        /** Whether the dialog is closing. */
        this.closing = false;
        this.data = config.data;
        this.keydownEvents = overlayRef.keydownEvents();
        this.outsidePointerEvents = overlayRef.outsidePointerEvents();
        this.id = config.id; // By the time the dialog is created we are guaranteed to have an ID.
        this.closeOnEscape = config.closeOnEscape ?? true;
        this.keydownEvents.subscribe(event => {
            if (event.key === 'Escape' &&
                !this.disableClose &&
                this.closeOnEscape !== false &&
                !hasModifierKey(event)) {
                event.preventDefault();
                this.close(undefined, 'keyboard');
            }
        });
        this.detachSubscription = overlayRef.detachments().subscribe(() => this.close());
    }
    /**
     * Close the dialog.
     * @param result Optional result to return to the dialog opener.
     * @param options Additional options to customize the closing behavior.
     */
    async close(result, focusOrigin) {
        // If the dialog is already closed, do nothing.
        if (this.closing) {
            return;
        }
        this.closing = true;
        const exitAnimationManager = this.injector?.get(NgpExitAnimationManager, undefined, {
            optional: true,
        });
        if (exitAnimationManager) {
            await exitAnimationManager.exit();
        }
        this.overlayRef.dispose();
        this.detachSubscription.unsubscribe();
        this.closed.next({ focusOrigin, result });
        this.closed.complete();
    }
    /** Updates the position of the dialog based on the current position strategy. */
    updatePosition() {
        this.overlayRef.updatePosition();
        return this;
    }
}
function injectDialogRef() {
    return inject(NgpDialogRef);
}

class NgpDialogOverlay {
    constructor() {
        /** Access the global configuration */
        this.config = injectDialogConfig();
        /** Access the dialog ref. */
        this.dialogRef = injectDialogRef();
        /**
         * Whether the dialog should close on backdrop click.
         * @default `true`
         */
        this.closeOnClick = input(this.config.closeOnClick, {
            alias: 'ngpDialogOverlayCloseOnClick',
            transform: booleanAttribute,
        });
    }
    close() {
        if (this.closeOnClick() && !this.dialogRef.disableClose) {
            this.dialogRef.close(undefined, 'mouse');
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogOverlay, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpDialogOverlay, isStandalone: true, selector: "[ngpDialogOverlay]", inputs: { closeOnClick: { classPropertyName: "closeOnClick", publicName: "ngpDialogOverlayCloseOnClick", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "close()" } }, exportAs: ["ngpDialogOverlay"], hostDirectives: [{ directive: i1.NgpExitAnimation }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogOverlay, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDialogOverlay]',
                    exportAs: 'ngpDialogOverlay',
                    hostDirectives: [NgpExitAnimation],
                }]
        }], propDecorators: { close: [{
                type: HostListener,
                args: ['click']
            }] } });

class NgpDialogTitle {
    constructor() {
        /** Access the dialog. */
        this.dialog = injectDialogState();
        /** The id of the title. */
        this.id = input(uniqueId('ngp-dialog-title'));
        onChange(this.id, (id, prevId) => {
            if (prevId) {
                this.dialog().removeLabelledBy(prevId);
            }
            if (id) {
                this.dialog().setLabelledBy(id);
            }
        });
    }
    ngOnDestroy() {
        this.dialog().removeLabelledBy(this.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogTitle, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpDialogTitle, isStandalone: true, selector: "[ngpDialogTitle]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "id": "id()" } }, exportAs: ["ngpDialogTitle"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogTitle, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDialogTitle]',
                    exportAs: 'ngpDialogTitle',
                    host: {
                        '[id]': 'id()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * This is based on the Angular CDK Dialog service.
 * https://github.com/angular/components/blob/main/src/cdk/dialog/dialog.ts
 */
class NgpDialogManager {
    constructor() {
        this.applicationRef = inject(ApplicationRef);
        this.document = inject(DOCUMENT);
        this.overlay = inject(Overlay);
        this.focusMonitor = inject(FocusMonitor);
        this.defaultOptions = injectDialogConfig();
        this.parentDialogManager = inject(NgpDialogManager, {
            optional: true,
            skipSelf: true,
        });
        this.overlayContainer = inject(OverlayContainer);
        this.scrollStrategy = this.defaultOptions.scrollStrategy ?? this.overlay.scrollStrategies.block();
        this.openDialogsAtThisLevel = [];
        this.afterAllClosedAtThisLevel = new Subject();
        this.afterOpenedAtThisLevel = new Subject();
        this.ariaHiddenElements = new Map();
        /**
         * Stream that emits when all open dialog have finished closing.
         * Will emit on subscribe if there are no open dialogs to begin with.
         */
        this.afterAllClosed = defer(() => this.openDialogs.length
            ? this.getAfterAllClosed()
            : this.getAfterAllClosed().pipe(startWith(undefined)));
    }
    /** Keeps track of the currently-open dialogs. */
    get openDialogs() {
        return this.parentDialogManager
            ? this.parentDialogManager.openDialogs
            : this.openDialogsAtThisLevel;
    }
    /** Stream that emits when a dialog has been opened. */
    get afterOpened() {
        return this.parentDialogManager
            ? this.parentDialogManager.afterOpened
            : this.afterOpenedAtThisLevel;
    }
    /**
     * Opens a modal dialog containing the given template.
     */
    open(templateRefOrComponentType, config) {
        // store the current active element so we can focus it after the dialog is closed
        const activeElement = this.document.activeElement;
        // this is not ideal, but there is a case where a dialog trigger is within an overlay (e.g. menu),
        // which may be removed before the dialog is closed. This is not desired, so we need to access a view container ref
        // that is not within the overlay. To solve this we use the view container ref of the root component.
        // Could this have any unintended side effects? For example, the dialog would not be closed during route changes?
        const viewContainerRef = this.applicationRef.components[0]?.injector.get(ViewContainerRef) ??
            config?.viewContainerRef ??
            config?.injector?.get(ViewContainerRef);
        const defaults = this.defaultOptions;
        config = { ...defaults, viewContainerRef, ...config };
        config.id = config.id ?? uniqueId('ngp-dialog');
        if (config.id && this.getDialogById(config.id) && isDevMode()) {
            throw Error(`Dialog with id "${config.id}" exists already. The dialog id must be unique.`);
        }
        const overlayConfig = this.getOverlayConfig(config);
        const overlayRef = this.overlay.create(overlayConfig);
        const dialogRef = new NgpDialogRef(overlayRef, config);
        const injector = this.createInjector(config, dialogRef, undefined);
        // store the injector in the dialog ref - this is so we can access the exit animation manager
        dialogRef.injector = injector;
        const context = {
            $implicit: dialogRef,
            close: dialogRef.close.bind(dialogRef),
        };
        if (templateRefOrComponentType instanceof TemplateRef) {
            overlayRef.attach(new TemplatePortal(templateRefOrComponentType, config.viewContainerRef, context, injector));
        }
        else {
            overlayRef.attach(new ComponentPortal(templateRefOrComponentType, config.viewContainerRef, injector));
        }
        // If this is the first dialog that we're opening, hide all the non-overlay content.
        if (!this.openDialogs.length) {
            this.hideNonDialogContentFromAssistiveTechnology();
        }
        this.openDialogs.push(dialogRef);
        this.afterOpened.next(dialogRef);
        dialogRef.closed.subscribe(closeResult => {
            this.removeOpenDialog(dialogRef, true);
            // Focus the trigger element after the dialog closes.
            if (activeElement instanceof HTMLElement && this.document.body.contains(activeElement)) {
                // Its not great that we are relying on an internal API here, but we need to in order to
                // try and best determine the focus origin when it is programmatically closed by the user.
                this.focusMonitor.focusVia(activeElement, closeResult.focusOrigin ?? this.focusMonitor._lastFocusOrigin);
            }
        });
        return dialogRef;
    }
    /**
     * Closes all of the currently-open dialogs.
     */
    closeAll() {
        reverseForEach(this.openDialogs, dialog => dialog.close());
    }
    /**
     * Finds an open dialog by its id.
     * @param id ID to use when looking up the dialog.
     */
    getDialogById(id) {
        return this.openDialogs.find(dialog => dialog.id === id);
    }
    ngOnDestroy() {
        // Make one pass over all the dialogs that need to be untracked, but should not be closed. We
        // want to stop tracking the open dialog even if it hasn't been closed, because the tracking
        // determines when `aria-hidden` is removed from elements outside the dialog.
        reverseForEach(this.openDialogsAtThisLevel, dialog => {
            // Check for `false` specifically since we want `undefined` to be interpreted as `true`.
            this.removeOpenDialog(dialog, false);
        });
        // Make a second pass and close the remaining dialogs. We do this second pass in order to
        // correctly dispatch the `afterAllClosed` event in case we have a mixed array of dialogs
        // that should be closed and dialogs that should not.
        reverseForEach(this.openDialogsAtThisLevel, dialog => dialog.close());
        this.afterAllClosedAtThisLevel.complete();
        this.afterOpenedAtThisLevel.complete();
        this.openDialogsAtThisLevel = [];
    }
    /**
     * Creates an overlay config from a dialog config.
     */
    getOverlayConfig(config) {
        const state = new OverlayConfig({
            positionStrategy: this.overlay.position().global().centerHorizontally().centerVertically(),
            scrollStrategy: config.scrollStrategy || this.scrollStrategy,
            hasBackdrop: false,
            disposeOnNavigation: config.closeOnNavigation,
        });
        return state;
    }
    /**
     * Creates a custom injector to be used inside the dialog. This allows a component loaded inside
     * of a dialog to close itself and, optionally, to return a value.
     */
    createInjector(config, dialogRef, fallbackInjector) {
        const userInjector = config.injector || config.viewContainerRef?.injector;
        const providers = [
            { provide: NgpDialogRef, useValue: dialogRef },
            { provide: NgpExitAnimationManager, useClass: NgpExitAnimationManager },
        ];
        return Injector.create({ parent: userInjector || fallbackInjector, providers });
    }
    /**
     * Removes a dialog from the array of open dialogs.
     */
    removeOpenDialog(dialogRef, emitEvent) {
        const index = this.openDialogs.indexOf(dialogRef);
        if (index > -1) {
            this.openDialogs.splice(index, 1);
            // If all the dialogs were closed, remove/restore the `aria-hidden`
            // to a the siblings and emit to the `afterAllClosed` stream.
            if (!this.openDialogs.length) {
                this.ariaHiddenElements.forEach((previousValue, element) => {
                    if (previousValue) {
                        element.setAttribute('aria-hidden', previousValue);
                    }
                    else {
                        element.removeAttribute('aria-hidden');
                    }
                });
                this.ariaHiddenElements.clear();
                if (emitEvent) {
                    this.getAfterAllClosed().next();
                }
            }
        }
    }
    /** Hides all of the content that isn't an overlay from assistive technology. */
    hideNonDialogContentFromAssistiveTechnology() {
        const overlayContainer = this.overlayContainer.getContainerElement();
        // Ensure that the overlay container is attached to the DOM.
        if (overlayContainer.parentElement) {
            const siblings = overlayContainer.parentElement.children;
            for (let i = siblings.length - 1; i > -1; i--) {
                const sibling = siblings[i];
                if (sibling !== overlayContainer &&
                    sibling.nodeName !== 'SCRIPT' &&
                    sibling.nodeName !== 'STYLE' &&
                    !sibling.hasAttribute('aria-live')) {
                    this.ariaHiddenElements.set(sibling, sibling.getAttribute('aria-hidden'));
                    sibling.setAttribute('aria-hidden', 'true');
                }
            }
        }
    }
    getAfterAllClosed() {
        const parent = this.parentDialogManager;
        return parent ? parent.getAfterAllClosed() : this.afterAllClosedAtThisLevel;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogManager, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogManager, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }] });
/**
 * Executes a callback against all elements in an array while iterating in reverse.
 * Useful if the array is being modified as it is being iterated.
 */
function reverseForEach(items, callback) {
    let i = items.length;
    while (i--) {
        callback(items[i]);
    }
}
function injectDialogManager() {
    return inject(NgpDialogManager);
}

class NgpDialogTrigger {
    constructor() {
        /** Access the global configuration */
        this.config = injectDialogConfig();
        /** Access the dialog manager. */
        this.dialogManager = inject(NgpDialogManager);
        /** The template to launch. */
        this.template = input.required({
            alias: 'ngpDialogTrigger',
        });
        /** Emits whenever the dialog is closed with the given result. */
        this.closed = output({ alias: 'ngpDialogTriggerClosed' });
        /**
         * Whether the dialog should close on escape.
         * @default `true`
         */
        this.closeOnEscape = input(this.config.closeOnEscape, {
            alias: 'ngpDialogTriggerCloseOnEscape',
        });
        /**
         * Store the dialog ref.
         * @internal
         */
        this.dialogRef = null;
    }
    launch() {
        this.dialogRef = this.dialogManager.open(this.template(), {
            closeOnEscape: this.closeOnEscape(),
        });
        this.dialogRef.closed.subscribe(({ result }) => {
            this.closed.emit(result);
            return (this.dialogRef = null);
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpDialogTrigger, isStandalone: true, selector: "[ngpDialogTrigger]", inputs: { template: { classPropertyName: "template", publicName: "ngpDialogTrigger", isSignal: true, isRequired: true, transformFunction: null }, closeOnEscape: { classPropertyName: "closeOnEscape", publicName: "ngpDialogTriggerCloseOnEscape", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { closed: "ngpDialogTriggerClosed" }, host: { listeners: { "click": "launch()" } }, exportAs: ["ngpDialogTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialogTrigger, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDialogTrigger]',
                    exportAs: 'ngpDialogTrigger',
                }]
        }], propDecorators: { launch: [{
                type: HostListener,
                args: ['click']
            }] } });

class NgpDialog {
    constructor() {
        this.config = injectDialogConfig();
        /** Access the dialog ref */
        this.dialogRef = injectDialogRef();
        /** The id of the dialog */
        this.id = input(uniqueId('ngp-dialog'));
        /** The dialog role. */
        this.role = input(this.config.role, {
            alias: 'ngpDialogRole',
        });
        /** Whether the dialog is a modal. */
        this.modal = input(this.config.modal ?? false, {
            alias: 'ngpDialogModal',
            transform: booleanAttribute,
        });
        /** The labelledby ids */
        this.labelledBy = signal([]);
        /** The describedby ids */
        this.describedBy = signal([]);
        /** The dialog state */
        this.state = dialogState(this);
    }
    ngOnDestroy() {
        this.close();
    }
    /** Close the dialog. */
    close(result) {
        this.dialogRef.close(result);
    }
    /** Stop click events from propagating to the overlay */
    onClick(event) {
        event.stopPropagation();
    }
    /** @internal register a labelledby id */
    setLabelledBy(id) {
        this.labelledBy.update(ids => [...ids, id]);
    }
    /** @internal register a describedby id */
    setDescribedBy(id) {
        this.describedBy.update(ids => [...ids, id]);
    }
    /** @internal remove a labelledby id */
    removeLabelledBy(id) {
        this.labelledBy.update(ids => ids.filter(i => i !== id));
    }
    /** @internal remove a describedby id */
    removeDescribedBy(id) {
        this.describedBy.update(ids => ids.filter(i => i !== id));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialog, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpDialog, isStandalone: true, selector: "[ngpDialog]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, role: { classPropertyName: "role", publicName: "ngpDialogRole", isSignal: true, isRequired: false, transformFunction: null }, modal: { classPropertyName: "modal", publicName: "ngpDialogModal", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "tabindex": "-1" }, listeners: { "click": "onClick($event)" }, properties: { "id": "state.id()", "attr.role": "state.role()", "attr.aria-modal": "state.modal()", "attr.aria-labelledby": "labelledBy().join(\" \")", "attr.aria-describedby": "describedBy().join(\" \")" } }, providers: [provideDialogState()], exportAs: ["ngpDialog"], hostDirectives: [{ directive: i1$1.NgpFocusTrap }, { directive: i1.NgpExitAnimation }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDialog, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDialog]',
                    exportAs: 'ngpDialog',
                    providers: [provideDialogState()],
                    hostDirectives: [NgpFocusTrap, NgpExitAnimation],
                    host: {
                        tabindex: '-1',
                        '[id]': 'state.id()',
                        '[attr.role]': 'state.role()',
                        '[attr.aria-modal]': 'state.modal()',
                        '[attr.aria-labelledby]': 'labelledBy().join(" ")',
                        '[attr.aria-describedby]': 'describedBy().join(" ")',
                    },
                }]
        }], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpDialog, NgpDialogDescription, NgpDialogManager, NgpDialogOverlay, NgpDialogRef, NgpDialogTitle, NgpDialogTrigger, injectDialogRef, injectDialogState, provideDialogConfig, provideDialogState };
//# sourceMappingURL=ng-primitives-dialog.mjs.map
