import * as i0 from '@angular/core';
import { input, computed, afterRenderEffect, Directive, booleanAttribute, signal, inject, HOST_TAG_NAME, HostListener, InjectionToken, output } from '@angular/core';
import { injectElementRef, injectDimensions, fromMutationObserver } from 'ng-primitives/internal';
import { uniqueId, safeTakeUntilDestroyed } from 'ng-primitives/utils';
import { debounceTime } from 'rxjs/operators';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';

/**
 * The state token  for the AccordionItem primitive.
 */
const NgpAccordionItemStateToken = createStateToken('AccordionItem');
/**
 * Provides the AccordionItem state.
 */
const provideAccordionItemState = createStateProvider(NgpAccordionItemStateToken);
/**
 * Injects the AccordionItem state.
 */
const injectAccordionItemState = createStateInjector(NgpAccordionItemStateToken);
/**
 * The AccordionItem state registration function.
 */
const accordionItemState = createState(NgpAccordionItemStateToken);

/**
 * The state token  for the Accordion primitive.
 */
const NgpAccordionStateToken = createStateToken('Accordion');
/**
 * Provides the Accordion state.
 */
const provideAccordionState = createStateProvider(NgpAccordionStateToken);
/**
 * Injects the Accordion state.
 */
const injectAccordionState = createStateInjector(NgpAccordionStateToken);
/**
 * The Accordion state registration function.
 */
const accordionState = createState(NgpAccordionStateToken);

/**
 * Apply the `ngpAccordionContent` directive to an element that represents the content of an accordion item.
 */
class NgpAccordionContent {
    constructor() {
        /**
         * Access the accordion content element reference
         */
        this.elementRef = injectElementRef();
        /**
         * Access the accordion
         */
        this.accordion = injectAccordionState();
        /**
         * Access the accordion item
         */
        this.accordionItem = injectAccordionItemState();
        /**
         * The id of the content region
         */
        this.id = input(uniqueId('ngp-accordion-content'));
        /**
         * The dimensions of the content
         */
        this.dimensions = injectDimensions();
        /**
         * The hidden until-found state of the content
         */
        this.hidden = computed(() => !this.accordionItem().open() && this.dimensions().height === 0 ? 'until-found' : null);
        this.accordionItem().content.set(this);
        // any time the open state of the accordion item changes, update the dimensions
        afterRenderEffect(() => this.updateDimensions());
        // update dimensions when the content changes
        fromMutationObserver(this.elementRef.nativeElement, {
            childList: true,
            subtree: true,
            disabled: computed(() => !this.accordionItem().open()),
        })
            .pipe(debounceTime(0), safeTakeUntilDestroyed())
            .subscribe(() => this.updateDimensions());
    }
    /**
     * Handle the beforematch event to automatically open the accordion item
     * when the browser's find-in-page functionality tries to reveal hidden content.
     */
    onBeforeMatch() {
        const isDisabled = this.accordion().disabled() || this.accordionItem().disabled();
        if (isDisabled)
            return;
        this.accordion().toggle(this.accordionItem().value());
    }
    updateDimensions() {
        if (this.accordionItem().open()) {
            // remove the inline styles to reset them
            this.elementRef.nativeElement.style.removeProperty('--ngp-accordion-content-width');
            this.elementRef.nativeElement.style.removeProperty('--ngp-accordion-content-height');
            // set the dimensions based on the content
            this.elementRef.nativeElement.style.setProperty('--ngp-accordion-content-width', `${this.elementRef.nativeElement.scrollWidth}px`);
            this.elementRef.nativeElement.style.setProperty('--ngp-accordion-content-height', `${this.elementRef.nativeElement.scrollHeight}px`);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordionContent, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpAccordionContent, isStandalone: true, selector: "[ngpAccordionContent]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "region" }, listeners: { "beforematch": "onBeforeMatch()" }, properties: { "id": "id()", "attr.data-orientation": "accordion().orientation()", "attr.data-open": "accordionItem().open() ? \"\" : null", "attr.data-closed": "accordionItem().open() ? null : \"\"", "attr.aria-labelledby": "accordionItem().triggerId()", "attr.hidden": "hidden()" } }, exportAs: ["ngpAccordionContent"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordionContent, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpAccordionContent]',
                    exportAs: 'ngpAccordionContent',
                    host: {
                        role: 'region',
                        '[id]': 'id()',
                        '[attr.data-orientation]': 'accordion().orientation()',
                        '[attr.data-open]': 'accordionItem().open() ? "" : null',
                        '[attr.data-closed]': 'accordionItem().open() ? null : ""',
                        '[attr.aria-labelledby]': 'accordionItem().triggerId()',
                        '(beforematch)': 'onBeforeMatch()',
                        '[attr.hidden]': 'hidden()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Apply the `ngpAccordionItem` directive to an element that represents an accordion item.
 */
class NgpAccordionItem {
    constructor() {
        /**
         * Access the accordion.
         */
        this.accordion = injectAccordionState();
        /**
         * The value of the accordion item.
         */
        this.value = input(uniqueId('ngp-accordion-item'), {
            alias: 'ngpAccordionItemValue',
        });
        /**
         * Whether the accordion item is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpAccordionItemDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the accordion trigger
         * @internal
         */
        this.trigger = signal(undefined);
        /**
         * Access the accordion content
         * @internal
         */
        this.content = signal(undefined);
        /**
         * Whether the accordion item is expanded.
         */
        this.open = computed(() => this.accordion().isOpen(this.state.value()));
        /**
         * The trigger id.
         */
        this.triggerId = computed(() => this.trigger()?.id());
        /**
         * The content id.
         */
        this.contentId = computed(() => this.content()?.id());
        /**
         * The accordion item state.
         */
        this.state = accordionItemState(this);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordionItem, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpAccordionItem, isStandalone: true, selector: "[ngpAccordionItem]", inputs: { value: { classPropertyName: "value", publicName: "ngpAccordionItemValue", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpAccordionItemDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.data-orientation": "accordion().orientation()", "attr.data-open": "state.open() ? \"\" : null", "attr.data-disabled": "state.disabled() || accordion().disabled() ? \"\" : null" } }, providers: [provideAccordionItemState()], exportAs: ["ngpAccordionItem"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordionItem, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpAccordionItem]',
                    exportAs: 'ngpAccordionItem',
                    providers: [provideAccordionItemState()],
                    host: {
                        '[attr.data-orientation]': 'accordion().orientation()',
                        '[attr.data-open]': 'state.open() ? "" : null',
                        '[attr.data-disabled]': 'state.disabled() || accordion().disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * Apply the `ngpAccordionTrigger` directive to an element that represents the trigger for an accordion item, such as a button.
 */
class NgpAccordionTrigger {
    constructor() {
        /**
         * The tag name of the element.
         */
        this.tagName = inject(HOST_TAG_NAME);
        /**
         * Access the parent accordion.
         */
        this.accordion = injectAccordionState();
        /**
         * The item instance.
         */
        this.accordionItem = injectAccordionItemState();
        /**
         * The id of the trigger.
         */
        this.id = input(uniqueId('ngp-accordion-trigger'));
        this.accordionItem().trigger.set(this);
    }
    /**
     * Toggle the accordion item.
     */
    toggle() {
        if (this.accordionItem().disabled() || this.accordion().disabled()) {
            return;
        }
        this.accordion().toggle(this.accordionItem().value());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordionTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpAccordionTrigger, isStandalone: true, selector: "[ngpAccordionTrigger]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "toggle()" }, properties: { "id": "id()", "attr.type": "tagName === \"button\" ? \"button\" : null", "attr.data-orientation": "accordion().orientation()", "attr.data-open": "accordionItem().open() ? \"\" : null", "attr.data-disabled": "accordionItem().disabled() || accordion().disabled() ? \"\" : null", "attr.aria-controls": "accordionItem().contentId()", "attr.aria-expanded": "accordionItem().open()" } }, exportAs: ["ngpAccordionTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordionTrigger, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpAccordionTrigger]',
                    exportAs: 'ngpAccordionTrigger',
                    host: {
                        '[id]': 'id()',
                        '[attr.type]': 'tagName === "button" ? "button" : null',
                        '[attr.data-orientation]': 'accordion().orientation()',
                        '[attr.data-open]': 'accordionItem().open() ? "" : null',
                        '[attr.data-disabled]': 'accordionItem().disabled() || accordion().disabled() ? "" : null',
                        '[attr.aria-controls]': 'accordionItem().contentId()',
                        '[attr.aria-expanded]': 'accordionItem().open()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { toggle: [{
                type: HostListener,
                args: ['click']
            }] } });

const defaultAccordionConfig = {
    type: 'single',
    collapsible: false,
    orientation: 'vertical',
};
const NgpAccordionConfigToken = new InjectionToken('NgpAccordionConfigToken');
/**
 * Provide the default Accordion configuration
 * @param config The Accordion configuration
 * @returns The provider
 */
function provideAccordionConfig(config) {
    return [
        {
            provide: NgpAccordionConfigToken,
            useValue: { ...defaultAccordionConfig, ...config },
        },
    ];
}
/**
 * Inject the Accordion configuration
 * @returns The global Accordion configuration
 */
function injectAccordionConfig() {
    return inject(NgpAccordionConfigToken, { optional: true }) ?? defaultAccordionConfig;
}

/**
 * Apply the `ngpAccordion` directive to an element that represents the group of accordion items.
 */
class NgpAccordion {
    constructor() {
        /**
         * Access the global accordion configuration.
         */
        this.config = injectAccordionConfig();
        /**
         * The type of the accordion.
         */
        this.type = input(this.config.type, {
            alias: 'ngpAccordionType',
        });
        /**
         * Whether the accordion is collapsible.
         */
        this.collapsible = input(this.config.collapsible, {
            alias: 'ngpAccordionCollapsible',
            transform: booleanAttribute,
        });
        /**
         * The value of the accordion.
         */
        this.value = input(null, {
            alias: 'ngpAccordionValue',
        });
        /**
         * Event emitted when the accordion value changes.
         */
        this.valueChange = output({
            alias: 'ngpAccordionValueChange',
        });
        /**
         * Whether the accordion is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpAccordionDisabled',
            transform: booleanAttribute,
        });
        /**
         * The accordion orientation.
         */
        this.orientation = input(this.config.orientation, {
            alias: 'ngpAccordionOrientation',
        });
        /**
         * The accordion state.
         */
        this.state = accordionState(this);
    }
    /**
     * @param value The value to check.
     * @returns Whether the value is open.
     * @internal
     */
    isOpen(value) {
        if (this.state.type() === 'multiple') {
            return this.state.value()?.includes(value) ?? false;
        }
        return this.state.value() === value;
    }
    toggle(value) {
        const isOpen = this.isOpen(value);
        // if we are in single mode and the value is already open and the accordion is not collapsible, do nothing
        if (this.state.type() === 'single' && isOpen && !this.state.collapsible()) {
            return;
        }
        // if we are in single mode then toggle the value
        if (this.state.type() === 'single') {
            const newValue = isOpen ? null : value;
            this.state.value.set(newValue);
            this.valueChange.emit(newValue);
            return;
        }
        // if we are in multiple mode then toggle the value
        let values = this.state.value() ?? [];
        if (isOpen) {
            values = values.filter(v => v !== value);
        }
        else {
            values = [...values, value];
        }
        this.state.value.set(values);
        this.valueChange.emit(values);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordion, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpAccordion, isStandalone: true, selector: "[ngpAccordion]", inputs: { type: { classPropertyName: "type", publicName: "ngpAccordionType", isSignal: true, isRequired: false, transformFunction: null }, collapsible: { classPropertyName: "collapsible", publicName: "ngpAccordionCollapsible", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpAccordionValue", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpAccordionDisabled", isSignal: true, isRequired: false, transformFunction: null }, orientation: { classPropertyName: "orientation", publicName: "ngpAccordionOrientation", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { valueChange: "ngpAccordionValueChange" }, host: { properties: { "attr.data-orientation": "state.orientation()", "attr.data-disabled": "state.disabled() ? \"\" : null" } }, providers: [provideAccordionState()], exportAs: ["ngpAccordion"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAccordion, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpAccordion]',
                    exportAs: 'ngpAccordion',
                    providers: [provideAccordionState()],
                    host: {
                        '[attr.data-orientation]': 'state.orientation()',
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpAccordion, NgpAccordionContent, NgpAccordionItem, NgpAccordionTrigger, injectAccordionItemState, injectAccordionState, provideAccordionConfig, provideAccordionItemState, provideAccordionState };
//# sourceMappingURL=ng-primitives-accordion.mjs.map
