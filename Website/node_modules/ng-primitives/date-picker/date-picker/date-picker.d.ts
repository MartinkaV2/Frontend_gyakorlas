import { FocusOrigin } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import type { NgpDatePickerDateButton } from '../date-picker-date-button/date-picker-date-button';
import * as i0 from "@angular/core";
/**
 * The outermost container for the date picker.
 */
export declare class NgpDatePicker<T> {
    /**
     * Access the date adapter.
     */
    private readonly dateAdapter;
    /**
     * Access the date picker config.
     */
    private readonly config;
    /**
     * Access the injector.
     */
    private readonly injector;
    /**
     * The minimum date that can be selected.
     */
    readonly min: import("@angular/core").InputSignal<T | undefined>;
    /**
     * The maximum date that can be selected.
     */
    readonly max: import("@angular/core").InputSignal<T | undefined>;
    /**
     * Determine if the date picker is disabled.
     */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * A function that is called to determine if a specific date should be disabled.
     */
    readonly dateDisabled: import("@angular/core").InputSignal<(date: T) => boolean>;
    /**
     * Sets which day starts the week in the calendar.
     * Accepts 0-7 where 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday.
     * Defaults to NgpDatePickerConfig.firstDayOfWeek (default 7 if not overridden).
     * Note: Update calendar header column order when changing from Sunday start.
     * @default 7 (Sunday)
     */
    readonly firstDayOfWeek: import("@angular/core").InputSignalWithTransform<import("./date-picker-first-day-of-week").NgpDatePickerFirstDayOfWeekNumber, import("./date-picker-first-day-of-week").NgpDatePickerFirstDayOfWeekNumberInput>;
    /**
     * The selected value.
     */
    readonly date: import("@angular/core").InputSignal<T | undefined>;
    /**
     * Emit when the date changes.
     */
    readonly dateChange: import("@angular/core").OutputEmitterRef<T | undefined>;
    /**
     * The focused value.
     */
    readonly focusedDate: import("@angular/core").InputSignal<T>;
    /**
     * Emit when the focused date changes.
     */
    readonly focusedDateChange: import("@angular/core").OutputEmitterRef<T>;
    /**
     * Detect the label element.
     * @internal
     */
    readonly label: import("@angular/core").Signal<import("ng-primitives/date-picker").NgpDatePickerLabel<unknown> | undefined>;
    /**
     * Access all the date picker buttons
     */
    private readonly buttons;
    /**
     * The date picker state.
     */
    protected readonly state: import("ng-primitives/state").CreatedState<NgpDatePicker<T>>;
    /**
     * Set the focused date.
     * @param date The date to focus.
     * @internal
     */
    setFocusedDate(date: T, origin: FocusOrigin | undefined, direction: 'forward' | 'backward'): void;
    /**
     * Register a date button.
     * @param button The date button to register.
     * @internal
     */
    registerButton(button: NgpDatePickerDateButton<T>): void;
    /**
     * Unregister a date button.
     * @param button The date button to unregister.
     * @internal
     */
    unregisterButton(button: NgpDatePickerDateButton<T>): void;
    /**
     * Select a date.
     * @param date The date to select.
     * @internal
     */
    select(date: T): void;
    /**
     * Determine if a date is selected.
     * @param date The date to check.
     * @returns True if the date is selected, false otherwise.
     * @internal
     */
    isSelected(date: T): boolean;
    /**
     * Determine if a date is the start of a range. In a date picker, this is always false.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isStartOfRange(_: T): boolean;
    /**
     * Determine if a date is the end of a range. In a date picker, this is always false.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isEndOfRange(_: T): boolean;
    /**
     * Determine if a date is between the start and end dates. In a date picker, this is always false.
     * @param date The date to check.
     * @returns True if the date is between the start and end dates, false otherwise.
     * @internal
     */
    isBetweenRange(_: T): boolean;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgpDatePicker<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgpDatePicker<any>, "[ngpDatePicker]", ["ngpDatePicker"], { "min": { "alias": "ngpDatePickerMin"; "required": false; "isSignal": true; }; "max": { "alias": "ngpDatePickerMax"; "required": false; "isSignal": true; }; "disabled": { "alias": "ngpDatePickerDisabled"; "required": false; "isSignal": true; }; "dateDisabled": { "alias": "ngpDatePickerDateDisabled"; "required": false; "isSignal": true; }; "firstDayOfWeek": { "alias": "ngpDatePickerFirstDayOfWeek"; "required": false; "isSignal": true; }; "date": { "alias": "ngpDatePickerDate"; "required": false; "isSignal": true; }; "focusedDate": { "alias": "ngpDatePickerFocusedDate"; "required": false; "isSignal": true; }; }, { "dateChange": "ngpDatePickerDateChange"; "focusedDateChange": "ngpDatePickerFocusedDateChange"; }, ["label"], never, true, never>;
}
