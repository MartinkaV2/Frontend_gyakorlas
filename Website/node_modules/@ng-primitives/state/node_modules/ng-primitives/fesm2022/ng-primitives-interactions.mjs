import * as i0 from '@angular/core';
import { input, booleanAttribute, output, Directive, signal, HostListener } from '@angular/core';
import { setupFocusVisible, setupFocus, setupHover, setupPress, injectElementRef } from 'ng-primitives/internal';
import { injectDisposables } from 'ng-primitives/utils';

/**
 * Apply the `ngpFocusVisible` directive to an element that should be visually focused. This is similar to `ngpFocus`
 * but it will only apply the focus visible styles when the element is focused via keyboard navigation.
 */
class NgpFocusVisible {
    constructor() {
        /**
         * Whether focus events are listened to.
         */
        this.disabled = input(false, {
            alias: 'ngpFocusVisibleDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the element is visually focused.
         */
        this.focusChange = output({
            alias: 'ngpFocusVisible',
        });
        // setup the focus visible listener
        setupFocusVisible({
            disabled: this.disabled,
            focusChange: value => this.focusChange.emit(value),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocusVisible, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpFocusVisible, isStandalone: true, selector: "[ngpFocusVisible]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpFocusVisibleDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { focusChange: "ngpFocusVisible" }, exportAs: ["ngpFocusVisible"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocusVisible, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpFocusVisible]',
                    exportAs: 'ngpFocusVisible',
                }]
        }], ctorParameters: () => [] });

/**
 * This was inspired by the React Aria useFocus hook.
 * https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useFocus.ts#L20
 */
class NgpFocus {
    constructor() {
        /**
         * Whether listening for focus events is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpFocusDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the focus state changes.
         */
        this.focus = output({ alias: 'ngpFocus' });
        // setup the focus listener
        setupFocus({
            disabled: this.disabled,
            focus: () => this.focus.emit(true),
            blur: () => this.focus.emit(false),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocus, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpFocus, isStandalone: true, selector: "[ngpFocus]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpFocusDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { focus: "ngpFocus" }, exportAs: ["ngpFocus"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFocus, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpFocus]',
                    exportAs: 'ngpFocus',
                }]
        }], ctorParameters: () => [] });

// This is an Angular port of the useHover hook from react-aria: https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useHover.ts
/**
 * Apply the `ngpHover` directive to an element that you want to listen for hover events. T
 * his is particulaly useful for supporting hover events on touch devices, where hover events are not handled consistently.
 * On iOS relying on the `:hover` pseudo-class can result in the hover state being stuck until the user taps elsewhere on the screen.
 */
class NgpHover {
    /**
     * Setup the hover state.
     */
    constructor() {
        /**
         * Whether hoving should be disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpHoverDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit an event when hovering starts.
         */
        this.hoverStart = output({ alias: 'ngpHoverStart' });
        /**
         * Emit an event when hovering ends.
         */
        this.hoverEnd = output({ alias: 'ngpHoverEnd' });
        /**
         * Emit an event when the hover state changes.
         */
        this.hoverChange = output({ alias: 'ngpHover' });
        // setup the hover listener
        setupHover({
            hoverStart: () => {
                this.hoverStart.emit();
                this.hoverChange.emit(true);
            },
            hoverEnd: () => {
                this.hoverEnd.emit();
                this.hoverChange.emit(false);
            },
            disabled: this.disabled,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpHover, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpHover, isStandalone: true, selector: "[ngpHover]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpHoverDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { hoverStart: "ngpHoverStart", hoverEnd: "ngpHoverEnd", hoverChange: "ngpHover" }, exportAs: ["ngpHover"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpHover, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpHover]',
                    exportAs: 'ngpHover',
                }]
        }], ctorParameters: () => [] });

// Inspired by react-aria useMove hook: https://github.com/adobe/react-spectrum/blob/main/packages/%40react-aria/interactions/src/useMove.ts
/**
 * The `NgpMove` directive is used to enable the pointer and keyboard move interactions on an element.
 */
class NgpMove {
    constructor() {
        /**
         * Access the disposable helper.
         */
        this.disposables = injectDisposables();
        /**
         * Whether movement is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpMoveDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the move event begins.
         */
        this.start = output({
            alias: 'ngpMoveStart',
        });
        /**
         * Emit when the element is moved.
         */
        this.move = output({
            alias: 'ngpMove',
        });
        /**
         * Emit when the move event ends.
         */
        this.end = output({
            alias: 'ngpMoveEnd',
        });
        /**
         * Whether the element is currently being moved.
         */
        this.isMoving = signal(false);
        /**
         * Store the last x position of the element.
         */
        this.x = null;
        /**
         * Store the last y position of the element.
         */
        this.y = null;
        /**
         * Store the id of the last pointer.
         */
        this.pointerId = null;
        /**
         * Store the disposable event listeners.
         */
        this.disposableListeners = [];
    }
    /**
     * Handle a move start.
     */
    onMoveStart(event, pointerType) {
        this.start.emit({
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
        this.isMoving.set(true);
    }
    /**
     * Handle a move event.
     */
    onMove(event, pointerType, deltaX, deltaY) {
        if (deltaX === 0 && deltaY === 0) {
            return;
        }
        this.move.emit({
            deltaX,
            deltaY,
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
    }
    /**
     * Handle a move end.
     */
    onMoveEnd(event, pointerType) {
        this.end.emit({
            pointerType,
            shiftKey: event.shiftKey,
            ctrlKey: event.ctrlKey,
            metaKey: event.metaKey,
            altKey: event.altKey,
        });
        this.isMoving.set(false);
    }
    /**
     * Handle the pointer down event.
     */
    onPointerDown(event) {
        // ignore right-click or additional pointers
        if (event.button !== 0 || this.pointerId !== null || this.disabled()) {
            return;
        }
        // prevent the default behavior
        event.preventDefault();
        event.stopPropagation();
        this.onMoveStart(event, event.pointerType);
        // store the pointer id and initial position
        this.pointerId = event.pointerId;
        this.x = event.pageX;
        this.y = event.pageY;
        // add global event listeners
        const pointerMove = this.disposables.addEventListener(window, 'pointermove', this.onPointerMove.bind(this), false);
        const pointerUp = this.disposables.addEventListener(window, 'pointerup', this.onPointerUp.bind(this), false);
        const pointerCancel = this.disposables.addEventListener(window, 'pointercancel', this.onPointerUp.bind(this), false);
        // store the disposable event listeners
        this.disposableListeners = [pointerMove, pointerUp, pointerCancel];
    }
    /**
     * Handle the pointer up event.
     */
    onPointerUp(event) {
        if (this.pointerId !== event.pointerId) {
            return;
        }
        const pointerType = (event.pointerType ?? 'mouse');
        this.onMoveEnd(event, pointerType);
        this.pointerId = null;
        this.disposableListeners.forEach(dispose => dispose());
    }
    /**
     * Handle the pointer move event.
     */
    onPointerMove(event) {
        if (this.pointerId !== event.pointerId) {
            return;
        }
        // Problems with PointerEvent#movementX/movementY:
        // 1. it is always 0 on macOS Safari.
        // 2. On Chrome Android, it's scaled by devicePixelRatio, but not on Chrome macOS
        this.onMove(event, event.pointerType, event.pageX - (this.x ?? 0), event.pageY - (this.y ?? 0));
        this.x = event.pageX;
        this.y = event.pageY;
    }
    triggerKeyboardMove(event, deltaX, deltaY) {
        if (this.disabled()) {
            return;
        }
        this.onMoveStart(event, 'keyboard');
        this.onMove(event, 'keyboard', deltaX, deltaY);
        this.onMoveEnd(event, 'keyboard');
    }
    onArrowUp(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 0, -1);
    }
    onArrowDown(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 0, 1);
    }
    onArrowLeft(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, -1, 0);
    }
    onArrowRight(event) {
        event.preventDefault();
        event.stopPropagation();
        this.triggerKeyboardMove(event, 1, 0);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMove, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpMove, isStandalone: true, selector: "[ngpMove]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpMoveDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { start: "ngpMoveStart", move: "ngpMove", end: "ngpMoveEnd" }, host: { listeners: { "pointerdown": "onPointerDown($event)", "keydown.ArrowUp": "onArrowUp($event)", "keydown.ArrowDown": "onArrowDown($event)", "keydown.ArrowLeft": "onArrowLeft($event)", "keydown.ArrowRight": "onArrowRight($event)" }, properties: { "attr.data-move": "isMoving() ? \"\" : null" } }, exportAs: ["ngpMove"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMove, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMove]',
                    exportAs: 'ngpMove',
                    host: {
                        '[attr.data-move]': 'isMoving() ? "" : null',
                    },
                }]
        }], propDecorators: { onPointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }], onArrowUp: [{
                type: HostListener,
                args: ['keydown.ArrowUp', ['$event']]
            }], onArrowDown: [{
                type: HostListener,
                args: ['keydown.ArrowDown', ['$event']]
            }], onArrowLeft: [{
                type: HostListener,
                args: ['keydown.ArrowLeft', ['$event']]
            }], onArrowRight: [{
                type: HostListener,
                args: ['keydown.ArrowRight', ['$event']]
            }] } });

// This was inpsired by Headless UI's active-press hook: https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-react/src/hooks/use-active-press.tsx
/**
 * The `ngpPress` directive listens for press events on an element. This is particularly useful for supporting press events on touch devices, where press events are not handled consistently.
 */
class NgpPress {
    constructor() {
        /**
         * Whether listening for press events is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpPressDisabled',
            transform: booleanAttribute,
        });
        /**
         * Emit when the press begins.
         */
        this.pressStart = output({
            alias: 'ngpPressStart',
        });
        /**
         * Emit when the press ends.
         */
        this.pressEnd = output({
            alias: 'ngpPressEnd',
        });
        /**
         * Emit when the press changes.
         */
        this.pressChange = output({
            alias: 'ngpPress',
        });
        // setup the press listener
        setupPress({
            pressStart: () => {
                this.pressStart.emit();
                this.pressChange.emit(true);
            },
            pressEnd: () => {
                this.pressEnd.emit();
                this.pressChange.emit(false);
            },
            disabled: this.disabled,
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPress, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPress, isStandalone: true, selector: "[ngpPress]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpPressDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { pressStart: "ngpPressStart", pressEnd: "ngpPressEnd", pressChange: "ngpPress" }, exportAs: ["ngpPress"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPress, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPress]',
                    exportAs: 'ngpPress',
                }]
        }], ctorParameters: () => [] });

/**
 * This function checks to see if a given interaction has already been setup on a given element.
 * If it has, it returns the existing interaction state.
 * If it has not, it sets up the interaction state for future checks.
 */
function hasInteraction(element, interaction) {
    const hasInteraction = `__ngp-${interaction}` in element;
    // if the interaction has not been setup, we mark it as setup for future checks
    if (!hasInteraction) {
        element[`__ngp-${interaction}`] = true;
    }
    return hasInteraction;
}

/**
 * Setup the interactions without relying on HostDirectives.
 */
function setupInteractions({ focus, hover, press, focusWithin, focusVisible, disabled = signal(false), }) {
    const elementRef = injectElementRef();
    // If the interaction has already been setup, we can skip the setup.
    if (hasInteraction(elementRef.nativeElement, 'interactions')) {
        return;
    }
    if (hover) {
        setupHover({ disabled });
    }
    if (press) {
        setupPress({ disabled });
    }
    if (focus) {
        setupFocus({ focusWithin, disabled });
    }
    if (focusVisible) {
        setupFocusVisible({ disabled });
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { NgpFocus, NgpFocusVisible, NgpHover, NgpMove, NgpPress, setupInteractions };
//# sourceMappingURL=ng-primitives-interactions.mjs.map
