import * as i0 from '@angular/core';
import { signal, computed, inject, ChangeDetectorRef, Directive } from '@angular/core';
import { explicitEffect } from 'ng-primitives/internal';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';

function activeDescendantManager(options) {
    const sortedOptions = () => options
        .items()
        .slice()
        .sort((a, b) => {
        const aElement = a.elementRef.nativeElement;
        const bElement = b.elementRef.nativeElement;
        return aElement.compareDocumentPosition(bElement) & Node.DOCUMENT_POSITION_FOLLOWING
            ? -1
            : 1;
    });
    const activeIndex = signal(0);
    const activeItem = computed(() => sortedOptions()?.[activeIndex()]);
    const disabled = computed(() => options.disabled?.() || options.items().every(item => item.disabled?.()));
    // any time the item list changes, check if the active index is still valid
    explicitEffect([sortedOptions], ([items]) => {
        if (activeIndex() >= items.length || activeIndex() < 0) {
            activeIndex.set(items.findIndex(item => !item.disabled?.()));
        }
        if (activeIndex() === -1 && items.length > 0) {
            activeIndex.set(0);
        }
        if (disabled() || items.length === 0) {
            activeIndex.set(-1);
        }
    });
    const activeDescendant = computed(() => {
        const item = activeItem();
        if (disabled() || !item) {
            return undefined;
        }
        return item.id();
    });
    /**
     * Activate an item in the active descendant group.
     * @param item The item to activate.
     */
    const activate = (item) => {
        if (item === undefined) {
            activeIndex.set(-1);
            return;
        }
        if (disabled() || item.disabled?.()) {
            return;
        }
        activeIndex.set(sortedOptions().indexOf(item));
    };
    /**
     * Activate the first enabled item in the active descendant group.
     */
    const first = () => {
        const item = sortedOptions().findIndex(item => !item.disabled?.());
        if (item !== -1) {
            activeIndex.set(item);
        }
    };
    /**
     * Activate the last enabled item in the active descendant group.
     */
    const last = () => {
        const item = sortedOptions()
            .reverse()
            .findIndex(item => !item.disabled?.());
        if (item !== -1) {
            activeIndex.set(sortedOptions().length - 1 - item);
        }
    };
    const findNextIndex = (items, currentIndex, direction, wrap) => {
        let index = (currentIndex + direction + items.length) % items.length;
        while (index !== currentIndex) {
            const item = items[index];
            if (item && !item.disabled?.()) {
                return index;
            }
            index = (index + direction + items.length) % items.length;
            if (!wrap &&
                ((direction === 1 && index === 0) || (direction === -1 && index === items.length - 1))) {
                break;
            }
        }
        return undefined;
    };
    /**
     * Activate the next enabled item in the active descendant group.
     */
    const next = () => {
        const items = sortedOptions();
        const nextIndex = findNextIndex(items, activeIndex(), 1, options.wrap?.() ?? false);
        if (nextIndex !== undefined) {
            activeIndex.set(nextIndex);
        }
    };
    /**
     * Activate the previous enabled item in the active descendant group.
     */
    const previous = () => {
        const items = sortedOptions();
        const prevIndex = findNextIndex(items, activeIndex(), -1, options.wrap?.() ?? false);
        if (prevIndex !== undefined) {
            activeIndex.set(prevIndex);
        }
    };
    /**
     * Reset the active descendant group, clearing the active index.
     */
    const reset = () => {
        activeIndex.set(-1);
    };
    return {
        activeDescendant,
        activeItem,
        activate,
        first,
        last,
        next,
        previous,
        reset,
    };
}

/**
 * The state token  for the VisuallyHidden primitive.
 */
const NgpVisuallyHiddenStateToken = createStateToken('VisuallyHidden');
/**
 * Provides the VisuallyHidden state.
 */
const provideVisuallyHiddenState = createStateProvider(NgpVisuallyHiddenStateToken);
/**
 * Injects the VisuallyHidden state.
 */
const injectVisuallyHiddenState = createStateInjector(NgpVisuallyHiddenStateToken);
/**
 * The VisuallyHidden state registration function.
 */
const visuallyHiddenState = createState(NgpVisuallyHiddenStateToken);

/**
 * Hide an element visually while keeping it present in the DOM.
 */
class NgpVisuallyHidden {
    constructor() {
        this.changeDetector = inject(ChangeDetectorRef);
        /**
         * Whether the element is hidden.
         */
        this.hidden = signal(true);
        this.style = computed(() => {
            if (!this.hidden()) {
                return {};
            }
            return {
                position: 'absolute',
                width: '1px',
                height: '1px',
                margin: '-1px',
                padding: '0',
                overflow: 'hidden',
                clip: 'rect(0, 0, 0, 0)',
                whiteSpace: 'nowrap',
                border: '0',
                wordWrap: 'normal',
                outline: '0',
                '-webkit-appearance': 'none',
                '-moz-appearance': 'none',
                'inset-inline-start': '0',
            };
        });
        this.state = visuallyHiddenState(this);
    }
    /**
     * Set the element visibility.
     * @param visible
     */
    setVisibility(visible) {
        this.hidden.set(!visible);
        this.changeDetector.detectChanges();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpVisuallyHidden, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpVisuallyHidden, isStandalone: true, selector: "[ngpVisuallyHidden]", host: { properties: { "style": "style()" } }, providers: [provideVisuallyHiddenState()], exportAs: ["ngpVisuallyHidden"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpVisuallyHidden, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpVisuallyHidden]',
                    exportAs: 'ngpVisuallyHidden',
                    providers: [provideVisuallyHiddenState()],
                    host: {
                        '[style]': 'style()',
                    },
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpVisuallyHidden, activeDescendantManager, injectVisuallyHiddenState, provideVisuallyHiddenState };
//# sourceMappingURL=ng-primitives-a11y.mjs.map
