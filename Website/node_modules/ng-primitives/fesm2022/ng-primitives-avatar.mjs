import * as i0 from '@angular/core';
import { signal, Directive, InjectionToken, inject, input, numberAttribute, computed, ElementRef, HostListener } from '@angular/core';
import { injectDisposables } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import * as i1 from 'ng-primitives/a11y';
import { injectVisuallyHiddenState, NgpVisuallyHidden } from 'ng-primitives/a11y';

/**
 * The state token  for the Avatar primitive.
 */
const NgpAvatarStateToken = createStateToken('Avatar');
/**
 * Provides the Avatar state.
 */
const provideAvatarState = createStateProvider(NgpAvatarStateToken);
/**
 * Injects the Avatar state.
 */
const injectAvatarState = createStateInjector(NgpAvatarStateToken);
/**
 * The Avatar state registration function.
 */
const avatarState = createState(NgpAvatarStateToken);

/**
 * Apply the `ngpAvatar` directive to an element that represents the avatar. This directive is a container for the image and/or fallback.
 */
class NgpAvatar {
    constructor() {
        /**
         * Store the current status of the avatar.
         * @internal
         */
        this.status = signal(NgpAvatarStatus.Idle);
        /**
         * The avatar state.
         */
        this.state = avatarState(this);
    }
    /**
     * Set the avatar status.
     * @param status The status to set.
     * @internal
     */
    setStatus(status) {
        this.status.set(status);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAvatar, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpAvatar, isStandalone: true, selector: "[ngpAvatar]", host: { properties: { "attr.data-status": "status()" } }, providers: [provideAvatarState()], exportAs: ["ngpAvatar"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAvatar, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpAvatar]',
                    exportAs: 'ngpAvatar',
                    providers: [provideAvatarState()],
                    host: {
                        '[attr.data-status]': 'status()',
                    },
                }]
        }] });
var NgpAvatarStatus;
(function (NgpAvatarStatus) {
    NgpAvatarStatus["Idle"] = "idle";
    NgpAvatarStatus["Loading"] = "loading";
    NgpAvatarStatus["Loaded"] = "loaded";
    NgpAvatarStatus["Error"] = "error";
})(NgpAvatarStatus || (NgpAvatarStatus = {}));

const defaultAvatarConfig = {
    delay: 0,
};
const NgpAvatarConfigToken = new InjectionToken('NgpAvatarConfigToken');
/**
 * Provide the avatar config
 * @param config The avatar config
 * @returns The provider
 */
function provideAvatarConfig(config) {
    return [
        {
            provide: NgpAvatarConfigToken,
            useValue: { ...defaultAvatarConfig, ...config },
        },
    ];
}
/**
 * Inject the avatar config
 * @returns The global avatar config
 */
function injectAvatarConfig() {
    return inject(NgpAvatarConfigToken, { optional: true }) ?? defaultAvatarConfig;
}

/**
 * Apply the `ngpAvatarFallback` directive to an element that represents the user in the absence of an image. This is typically the user's initials.
 */
class NgpAvatarFallback {
    constructor() {
        /**
         * Access the avatar
         */
        this.avatar = injectAvatarState();
        /**
         * Access the global configuration.
         */
        this.config = injectAvatarConfig();
        /**
         * Access the disposable utilities.
         */
        this.disposables = injectDisposables();
        /**
         * Define a delay before the fallback is shown. This is useful to only show the fallback for those with slower connections.
         * @default 0
         */
        this.delay = input(this.config.delay, {
            alias: 'ngpAvatarFallbackDelay',
            transform: numberAttribute,
        });
        /**
         * Determine if this element should be hidden.
         * @returns True if the element should be visible
         */
        this.visible = computed(() => 
        // we need to check if the element can render and if the avatar is not in a loaded state
        this.delayElapsed() && this.avatar().status() !== NgpAvatarStatus.Loaded);
        /**
         * Determine the delay has elapsed, and we can show the fallback.
         */
        this.delayElapsed = signal(false);
    }
    ngOnInit() {
        this.disposables.setTimeout(() => this.delayElapsed.set(true), this.delay());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAvatarFallback, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpAvatarFallback, isStandalone: true, selector: "[ngpAvatarFallback]", inputs: { delay: { classPropertyName: "delay", publicName: "ngpAvatarFallbackDelay", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "style.display": "visible() ? null : \"none\"" } }, exportAs: ["ngpAvatarFallback"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAvatarFallback, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpAvatarFallback]',
                    exportAs: 'ngpAvatarFallback',
                    host: {
                        '[style.display]': 'visible() ? null : "none"',
                    },
                }]
        }] });

/**
 * Apply the `ngpAvatarImage` directive to an element that represents the avatar image. This would typically be an `img` element or a `div` with a background image.
 */
class NgpAvatarImage {
    constructor() {
        /**
         * Control the visibility of the image.
         */
        this.visuallyHidden = injectVisuallyHiddenState();
        /**
         * Access the avatar
         */
        this.avatar = injectAvatarState();
        /**
         * Access the image element ref.
         */
        this.elementRef = inject(ElementRef);
    }
    ngOnInit() {
        // mark the avatar as loading
        this.setState(NgpAvatarStatus.Loading);
        // if there is no src, we can report this as an error
        if (!this.elementRef.nativeElement.src) {
            this.setState(NgpAvatarStatus.Error);
        }
        // if the image has already loaded, we can report this to the avatar
        if (this.elementRef.nativeElement.complete) {
            this.setState(NgpAvatarStatus.Loaded);
        }
    }
    onLoad() {
        this.setState(NgpAvatarStatus.Loaded);
    }
    onError() {
        this.setState(NgpAvatarStatus.Error);
    }
    setState(state) {
        this.avatar().setStatus(state);
        // if the state is loaded then we should make the image visible
        this.visuallyHidden().setVisibility(state === NgpAvatarStatus.Loaded);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAvatarImage, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpAvatarImage, isStandalone: true, selector: "img[ngpAvatarImage]", host: { listeners: { "load": "onLoad()", "error": "onError()" } }, exportAs: ["ngpAvatarImage"], hostDirectives: [{ directive: i1.NgpVisuallyHidden }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpAvatarImage, decorators: [{
            type: Directive,
            args: [{
                    selector: 'img[ngpAvatarImage]',
                    exportAs: 'ngpAvatarImage',
                    hostDirectives: [NgpVisuallyHidden],
                }]
        }], propDecorators: { onLoad: [{
                type: HostListener,
                args: ['load']
            }], onError: [{
                type: HostListener,
                args: ['error']
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpAvatar, NgpAvatarFallback, NgpAvatarImage, NgpAvatarStatus, injectAvatarState, provideAvatarConfig, provideAvatarState };
//# sourceMappingURL=ng-primitives-avatar.mjs.map
