{"version":3,"file":"ng-primitives-state.mjs","sources":["../../../../packages/ng-primitives/state/src/index.ts","../../../../packages/ng-primitives/state/src/ng-primitives-state.ts"],"sourcesContent":["import {\n  computed,\n  FactoryProvider,\n  inject,\n  InjectionToken,\n  InjectOptions,\n  InputSignal,\n  InputSignalWithTransform,\n  isSignal,\n  linkedSignal,\n  ProviderToken,\n  signal,\n  Signal,\n  WritableSignal,\n} from '@angular/core';\nimport { isFunction } from 'ng-primitives/utils';\n\n/**\n * This converts the state object to a writable state object.\n * This means that inputs become signals which are writable.\n */\nexport type State<T> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof T]: T[K] extends InputSignalWithTransform<infer U, any>\n    ? WritableSignal<U>\n    : T[K] extends InputSignal<infer R>\n      ? WritableSignal<R>\n      : T[K];\n};\n\n/**\n * This is similar to the state object, but we don't expose properties that are not\n * inputs.\n */\nexport type CreatedState<T> = {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  [K in keyof T]: T[K] extends InputSignalWithTransform<infer U, any>\n    ? WritableSignal<U>\n    : T[K] extends InputSignal<infer R>\n      ? WritableSignal<R>\n      : never;\n};\n\nexport type InjectedState<T> = Signal<State<T>>;\n\n/**\n * Create a new injection token for the state.\n * @param description The description of the token\n */\nexport function createStateToken<T>(description: string): InjectionToken<T> {\n  return new InjectionToken<Signal<State<T>>>(`Ngp${description}StateToken`);\n}\n\nexport interface CreateStateProviderOptions {\n  /**\n   * Whether we should check for the state in the parent injector.\n   */\n  inherit?: boolean;\n}\n\n/**\n * Create a new provider for the state. It first tries to inject the state from the parent injector,\n * as this allows for the state to be hoisted to a higher level in the component tree. This can\n * be useful to avoid issues where the injector can't be shared in some cases when ng-content is used.\n * @param token The token for the state\n */\nexport function createStateProvider<T>(\n  token: ProviderToken<T>,\n): (options?: CreateStateProviderOptions) => FactoryProvider {\n  return ({ inherit }: CreateStateProviderOptions = {}) => ({\n    provide: token,\n    useFactory: () => {\n      if (inherit === false) {\n        // if we are not checking the parent, we want to create a new state\n        return signal({});\n      }\n      // if we are checking the parent, we want to check if the state is already defined\n      return inject(token, { optional: true, skipSelf: true }) ?? signal({});\n    },\n  });\n}\n\ntype CreateStateInjectorOptions = {\n  /**\n   * Whether the state may not be immediately available. This can happen when the child is instantiated before the parent.\n   */\n  deferred?: boolean;\n};\n\n/**\n * Create a new state injector for the state.\n * @param token The token for the state\n */\nexport function createStateInjector<T>(\n  token: ProviderToken<State<T>>,\n  options: { deferred: true },\n): <U = T>(injectOptions?: InjectOptions) => Signal<State<U> | undefined>;\nexport function createStateInjector<T>(\n  token: ProviderToken<State<T>>,\n  options?: CreateStateInjectorOptions,\n): <U = T>(injectOptions?: InjectOptions) => Signal<State<U>>;\nexport function createStateInjector<T>(\n  token: ProviderToken<State<T>>,\n  options: CreateStateInjectorOptions = {},\n): <U = T>(injectOptions?: InjectOptions) => Signal<State<U> | undefined> {\n  return <U = T>(injectOptions: InjectOptions = {}) => {\n    const value = inject(token, injectOptions) as Signal<State<U> | undefined> | null;\n\n    if (options.deferred) {\n      return computed(() =>\n        value && Object.keys(value() ?? {}).length === 0 ? undefined : value?.(),\n      ) as Signal<State<U> | undefined>;\n    }\n\n    return (value as Signal<State<U>>) ?? signal(undefined);\n  };\n}\n\n/**\n * Convert the original state object into a writable state object.\n * @param token The token for the state\n */\nexport function createState(token: ProviderToken<WritableSignal<State<unknown>>>) {\n  return <U>(state: U): CreatedState<U> => {\n    const internalState = inject(token);\n\n    internalState.update(obj => {\n      // Iterating over properties\n      for (const key in state) {\n        const value = state[key as keyof U];\n\n        // We want to make this a controlled input if it is an InputSignal or InputSignalWithTransform\n        if (isSignalInput(value)) {\n          // @ts-ignore\n          obj[key] = createControlledInput(value);\n        } else {\n          // @ts-ignore\n          obj[key] = value;\n        }\n      }\n\n      // Iterating over prototype methods\n      const prototype = Object.getPrototypeOf(state);\n\n      for (const key of Object.getOwnPropertyNames(prototype)) {\n        const descriptor = Object.getOwnPropertyDescriptor(prototype, key);\n\n        // if this is a getter or setter, we need to define it on the object\n        if (descriptor?.get || descriptor?.set) {\n          Object.defineProperty(obj, key, descriptor);\n        } else if (isFunction(prototype[key as keyof U])) {\n          (obj as Record<string, unknown>)[key] = prototype[key as keyof U].bind(state);\n        } else {\n          // @ts-ignore\n          obj[key] = prototype[key as keyof U];\n        }\n      }\n\n      return { ...obj };\n    });\n\n    return internalState() as unknown as CreatedState<U>;\n  };\n}\n\n// this is a bit hacky, but we need to do it to track whether this is controlled\nfunction createControlledInput(\n  property: InputSignal<unknown> | InputSignalWithTransform<unknown, unknown>,\n): WritableSignal<unknown> {\n  const value = signal(property());\n  let isControlled = false;\n\n  const symbol = Object.getOwnPropertySymbols(property).find(s => s.description === 'SIGNAL');\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const inputDefinition = symbol ? (property as any)[symbol] : undefined;\n\n  if (!symbol || !inputDefinition || !isFunction(inputDefinition.applyValueToInputSignal)) {\n    console.warn(\n      'Angular has changed its internal Input implementation, report this issue to ng-primitives.',\n    );\n    // fallback to a linked signal which is partially controlled\n    return linkedSignal(() => property());\n  }\n\n  const originalApply = inputDefinition.applyValueToInputSignal.bind(inputDefinition);\n  const originalSet = value.set.bind(value);\n  const originalUpdate = value.update.bind(value);\n\n  inputDefinition.applyValueToInputSignal = (inputSignalNode: unknown, newValue: unknown) => {\n    isControlled = true;\n    originalSet(newValue);\n    originalApply(inputSignalNode, newValue);\n  };\n\n  value.set = (newValue: unknown) => {\n    if (!isControlled) {\n      originalSet(newValue);\n    }\n  };\n\n  value.update = (updateFn: (value: unknown) => unknown) => {\n    if (!isControlled) {\n      originalUpdate(updateFn);\n    }\n  };\n\n  return value;\n}\n\nfunction isSignalInput(\n  property: unknown,\n): property is InputSignal<unknown> | InputSignalWithTransform<unknown, unknown> {\n  if (!isSignal(property)) {\n    return false;\n  }\n\n  const symbol = Object.getOwnPropertySymbols(property).find(s => s.description === 'SIGNAL');\n\n  if (!symbol) {\n    return false;\n  }\n\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  const inputDefinition = symbol ? (property as any)[symbol] : undefined;\n\n  if (!inputDefinition) {\n    return false;\n  }\n\n  return 'transformFn' in inputDefinition || 'applyValueToInputSignal' in inputDefinition;\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}