import { coerceOffset, createOverlay, injectOverlay } from 'ng-primitives/portal';
export { injectOverlayContext as injectMenuContext } from 'ng-primitives/portal';
import * as i0 from '@angular/core';
import { InjectionToken, inject, Injector, ViewContainerRef, input, booleanAttribute, signal, computed, HostListener, Directive } from '@angular/core';
import { setupButton } from 'ng-primitives/button';
import { injectElementRef } from 'ng-primitives/internal';
import * as i1 from 'ng-primitives/roving-focus';
import { NgpRovingFocusItem, provideRovingFocusGroup, NgpRovingFocusGroup } from 'ng-primitives/roving-focus';
import { safeTakeUntilDestroyed } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import * as i2 from 'ng-primitives/focus-trap';
import { NgpFocusTrap } from 'ng-primitives/focus-trap';
import { Subject } from 'rxjs';

const defaultMenuConfig = {
    offset: 4,
    placement: 'bottom-start',
    flip: true,
    container: 'body',
    scrollBehavior: 'block',
};
const NgpMenuConfigToken = new InjectionToken('NgpMenuConfigToken');
/**
 * Provide the default Menu configuration
 * @param config The Menu configuration
 * @returns The provider
 */
function provideMenuConfig(config) {
    return [
        {
            provide: NgpMenuConfigToken,
            useValue: { ...defaultMenuConfig, ...config },
        },
    ];
}
/**
 * Inject the Menu configuration
 * @returns The global Menu configuration
 */
function injectMenuConfig() {
    return inject(NgpMenuConfigToken, { optional: true }) ?? defaultMenuConfig;
}

const NgpMenuToken = new InjectionToken('NgpMenuToken');
/**
 * Inject the Menu directive instance
 */
function injectMenu() {
    return inject(NgpMenuToken);
}
/**
 * Provide the Menu directive instance
 */
function provideMenu(type) {
    return { provide: NgpMenuToken, useExisting: type };
}

/**
 * The state token  for the SubmenuTrigger primitive.
 */
const NgpSubmenuTriggerStateToken = createStateToken('SubmenuTrigger');
/**
 * Provides the SubmenuTrigger state.
 */
const provideSubmenuTriggerState = createStateProvider(NgpSubmenuTriggerStateToken);
/**
 * Injects the SubmenuTrigger state.
 */
const injectSubmenuTriggerState = createStateInjector(NgpSubmenuTriggerStateToken);
/**
 * The SubmenuTrigger state registration function.
 */
const submenuTriggerState = createState(NgpSubmenuTriggerStateToken);

class NgpSubmenuTrigger {
    constructor() {
        /**
         * Access the menu trigger element.
         */
        this.trigger = injectElementRef();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the view container reference.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /** Access the parent menu */
        this.parentMenu = inject(NgpMenuToken, { optional: true });
        /**
         * Access the submenu template ref.
         */
        this.menu = input(undefined, {
            alias: 'ngpSubmenuTrigger',
        });
        /**
         * Define if the trigger should be disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpSubmenuTriggerDisabled',
            transform: booleanAttribute,
        });
        /**
         * Define the placement of the menu relative to the trigger.
         * @default 'right-start'
         */
        this.placement = input('right-start', {
            alias: 'ngpSubmenuTriggerPlacement',
        });
        /**
         * Define the offset of the menu relative to the trigger.
         * Can be a number (applies to mainAxis) or an object with mainAxis, crossAxis, and alignmentAxis.
         * @default 0
         */
        this.offset = input(0, {
            alias: 'ngpSubmenuTriggerOffset',
            transform: coerceOffset,
        });
        /**
         * Define whether the menu should flip when there is not enough space for the menu.
         * @default true
         */
        this.flip = input(true, {
            alias: 'ngpSubmenuTriggerFlip',
            transform: booleanAttribute,
        });
        /**
         * The overlay that manages the menu
         * @internal
         */
        this.overlay = signal(null);
        /**
         * The open state of the menu.
         * @internal
         */
        this.open = computed(() => this.overlay()?.isOpen() ?? false);
        /**
         * Access the menu trigger state.
         */
        this.state = submenuTriggerState(this);
        this.parentMenu?.closeSubmenus.pipe(safeTakeUntilDestroyed()).subscribe(element => {
            // if the element is not the trigger, we want to close the menu
            if (element === this.trigger.nativeElement) {
                return;
            }
            this.hide('mouse');
        });
    }
    toggle(event) {
        // if the trigger is disabled then do not toggle the menu
        if (this.state.disabled()) {
            return;
        }
        // determine the origin of the event, 0 is keyboard, 1 is mouse
        const origin = event.detail === 0 ? 'keyboard' : 'mouse';
        // if the menu is open then hide it
        if (this.open()) {
            this.hide(origin);
        }
        else {
            this.show();
        }
    }
    /**
     * Show the menu.
     */
    show() {
        // If the trigger is disabled, don't show the menu
        if (this.state.disabled()) {
            return;
        }
        // Create the overlay if it doesn't exist yet
        if (!this.overlay()) {
            this.createOverlay();
        }
        // Show the overlay
        this.overlay()?.show();
    }
    /**
     * @internal
     * Hide the menu.
     */
    hide(origin = 'program') {
        // If the trigger is disabled or the menu is not open, do nothing
        if (this.state.disabled() || !this.open()) {
            return;
        }
        // Hide the overlay
        this.overlay()?.hide({ origin });
    }
    /**
     * Create the overlay that will contain the menu
     */
    createOverlay() {
        const menu = this.state.menu();
        if (!menu) {
            throw new Error('Menu must be either a TemplateRef or a ComponentType');
        }
        // Create config for the overlay
        const config = {
            content: menu,
            triggerElement: this.trigger.nativeElement,
            injector: this.injector,
            placement: this.state.placement,
            offset: this.state.offset(),
            flip: this.state.flip(),
            closeOnOutsideClick: true,
            closeOnEscape: true,
            restoreFocus: true,
            viewContainerRef: this.viewContainerRef,
        };
        this.overlay.set(createOverlay(config));
    }
    /**
     * If the user presses the right arrow key, we want to open the submenu
     * and focus the first item in the submenu.
     * This behavior will be inverted if the direction is RTL.
     * @param event
     */
    showSubmenuOnArrow(event) {
        const direction = getComputedStyle(this.trigger.nativeElement).direction;
        const isRtl = direction === 'rtl';
        const isRightArrow = event.key === 'ArrowRight';
        const isLeftArrow = event.key === 'ArrowLeft';
        if ((isRightArrow && !isRtl) || (isLeftArrow && isRtl)) {
            event.preventDefault();
            this.show();
        }
    }
    /**
     * If the user hovers over the trigger, we want to open the submenu
     */
    showSubmenuOnHover(event) {
        // if this was triggered by a touch event, we don't want to show the submenu
        // as it will be shown by the click event - this prevents the submenu from being toggled
        if (event.pointerType === 'touch') {
            return;
        }
        this.show();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSubmenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpSubmenuTrigger, isStandalone: true, selector: "[ngpSubmenuTrigger]", inputs: { menu: { classPropertyName: "menu", publicName: "ngpSubmenuTrigger", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpSubmenuTriggerDisabled", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpSubmenuTriggerPlacement", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "ngpSubmenuTriggerOffset", isSignal: true, isRequired: false, transformFunction: null }, flip: { classPropertyName: "flip", publicName: "ngpSubmenuTriggerFlip", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "aria-haspopup": "true" }, listeners: { "click": "toggle($event)", "keydown.ArrowRight": "showSubmenuOnArrow($event)", "keydown.ArrowLeft": "showSubmenuOnArrow($event)", "pointerenter": "showSubmenuOnHover($event)" }, properties: { "attr.aria-expanded": "open() ? \"true\" : \"false\"", "attr.data-open": "open() ? \"\" : null" } }, providers: [provideSubmenuTriggerState({ inherit: false })], exportAs: ["ngpSubmenuTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSubmenuTrigger, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpSubmenuTrigger]',
                    exportAs: 'ngpSubmenuTrigger',
                    providers: [provideSubmenuTriggerState({ inherit: false })],
                    host: {
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'open() ? "true" : "false"',
                        '[attr.data-open]': 'open() ? "" : null',
                        '(click)': 'toggle($event)',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { showSubmenuOnArrow: [{
                type: HostListener,
                args: ['keydown.ArrowRight', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.ArrowLeft', ['$event']]
            }], showSubmenuOnHover: [{
                type: HostListener,
                args: ['pointerenter', ['$event']]
            }] } });

/**
 * The `NgpMenuItem` directive represents a menu item.
 */
class NgpMenuItem {
    constructor() {
        /** Access the injector */
        this.injector = inject(Injector);
        /** Access the button element */
        this.elementRef = injectElementRef();
        /** Access the parent menu */
        this.parentMenu = injectMenu();
        /** Whether the menu item is disabled */
        this.disabled = input(false, {
            alias: 'ngpMenuItemDisabled',
            transform: booleanAttribute,
        });
        setupButton({ disabled: this.disabled });
    }
    /** Close the menu when the item is clicked */
    onClick(event) {
        // we do this here to avoid circular dependency issues
        const trigger = this.injector.get(NgpSubmenuTrigger, null, { self: true, optional: true });
        const origin = event.detail === 0 ? 'keyboard' : 'mouse';
        // if this is a submenu trigger, we don't want to close the menu, we want to open the submenu
        if (!trigger) {
            this.parentMenu?.closeAllMenus(origin);
        }
    }
    /**
     * If the user presses the left arrow key (in LTR) and there is a parent menu,
     * we want to close the menu and focus the parent menu item.
     */
    handleArrowKey(event) {
        // if there is no parent menu, we don't want to do anything
        const trigger = this.injector.get(NgpSubmenuTrigger, null, { optional: true });
        if (!trigger) {
            return;
        }
        const direction = getComputedStyle(this.elementRef.nativeElement).direction;
        const isRtl = direction === 'rtl';
        const isLeftArrow = event.key === 'ArrowLeft';
        const isRightArrow = event.key === 'ArrowRight';
        if ((isLeftArrow && !isRtl) || (isRightArrow && isRtl)) {
            event.preventDefault();
            if (trigger) {
                trigger.hide('keyboard');
            }
        }
    }
    /**
     * If the user hovers over the trigger, we want to open the submenu
     */
    showSubmenuOnHover() {
        this.parentMenu?.closeSubmenus.next(this.elementRef.nativeElement);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMenuItem, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpMenuItem, isStandalone: true, selector: "[ngpMenuItem]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpMenuItemDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "menuitem" }, listeners: { "click": "onClick($event)", "keydown.ArrowLeft": "handleArrowKey($event)", "keydown.ArrowRight": "handleArrowKey($event)", "mouseenter": "showSubmenuOnHover()" } }, exportAs: ["ngpMenuItem"], hostDirectives: [{ directive: i1.NgpRovingFocusItem, inputs: ["ngpRovingFocusItemDisabled", "ngpMenuItemDisabled"] }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMenuItem, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMenuItem]',
                    exportAs: 'ngpMenuItem',
                    hostDirectives: [
                        { directive: NgpRovingFocusItem, inputs: ['ngpRovingFocusItemDisabled: ngpMenuItemDisabled'] },
                    ],
                    host: {
                        role: 'menuitem',
                        '(click)': 'onClick($event)',
                        '(keydown.ArrowLeft)': 'handleArrowKey($event)',
                        '(keydown.ArrowRight)': 'handleArrowKey($event)',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { showSubmenuOnHover: [{
                type: HostListener,
                args: ['mouseenter']
            }] } });

/**
 * The state token  for the MenuTrigger primitive.
 */
const NgpMenuTriggerStateToken = createStateToken('MenuTrigger');
/**
 * Provides the MenuTrigger state.
 */
const provideMenuTriggerState = createStateProvider(NgpMenuTriggerStateToken);
/**
 * Injects the MenuTrigger state.
 */
const injectMenuTriggerState = createStateInjector(NgpMenuTriggerStateToken);
/**
 * The MenuTrigger state registration function.
 */
const menuTriggerState = createState(NgpMenuTriggerStateToken);

/**
 * The `NgpMenuTrigger` directive allows you to turn an element into a menu trigger.
 */
class NgpMenuTrigger {
    constructor() {
        /**
         * Access the trigger element
         */
        this.trigger = injectElementRef();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the view container reference.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the global menu configuration.
         */
        this.config = injectMenuConfig();
        /**
         * Access the menu template ref or ComponentType.
         */
        this.menu = input(undefined, {
            alias: 'ngpMenuTrigger',
        });
        /**
         * Define if the trigger should be disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpMenuTriggerDisabled',
            transform: booleanAttribute,
        });
        /**
         * Define the placement of the menu relative to the trigger.
         * @default 'bottom-start'
         */
        this.placement = input(this.config.placement, {
            alias: 'ngpMenuTriggerPlacement',
        });
        /**
         * Define the offset of the menu relative to the trigger.
         * Can be a number (applies to mainAxis) or an object with mainAxis, crossAxis, and alignmentAxis.
         * @default 4
         */
        this.offset = input(this.config.offset, {
            alias: 'ngpMenuTriggerOffset',
            transform: coerceOffset,
        });
        /**
         * Define whether the menu should flip when there is not enough space for the menu.
         * @default true
         */
        this.flip = input(this.config.flip, {
            alias: 'ngpMenuTriggerFlip',
            transform: booleanAttribute,
        });
        /**
         * Define the container in which the menu should be attached.
         * @default document.body
         */
        this.container = input(this.config.container, {
            alias: 'ngpMenuTriggerContainer',
        });
        /**
         * Defines how the menu behaves when the window is scrolled.
         * @default 'block'
         */
        this.scrollBehavior = input(this.config.scrollBehavior, {
            alias: 'ngpMenuTriggerScrollBehavior',
        });
        /**
         * Provide context to the menu. This can be used to pass data to the menu content.
         */
        this.context = input(undefined, {
            alias: 'ngpMenuTriggerContext',
        });
        /**
         * The overlay that manages the menu
         * @internal
         */
        this.overlay = signal(null);
        /**
         * The open state of the menu.
         * @internal
         */
        this.open = computed(() => this.overlay()?.isOpen() ?? false);
        /**
         * The menu trigger state.
         */
        this.state = menuTriggerState(this);
    }
    ngOnDestroy() {
        this.overlay()?.destroy();
    }
    onClick(event) {
        if (this.state.disabled()) {
            return;
        }
        this.toggle(event);
    }
    toggle(event) {
        // determine the origin of the event, 0 is keyboard, 1 is mouse
        const origin = event.detail === 0 ? 'keyboard' : 'mouse';
        // if the menu is open then hide it
        if (this.open()) {
            this.hide(origin);
        }
        else {
            this.show();
        }
    }
    /**
     * Show the menu.
     */
    show() {
        // Create the overlay if it doesn't exist yet
        if (!this.overlay()) {
            this.createOverlay();
        }
        // Show the overlay
        this.overlay()?.show();
    }
    /**
     * @internal
     * Hide the menu.
     */
    hide(origin = 'program') {
        // If the trigger is disabled or the menu is not open, do nothing
        if (!this.open()) {
            return;
        }
        // Hide the overlay
        this.overlay()?.hide({ origin });
    }
    /**
     * Create the overlay that will contain the menu
     */
    createOverlay() {
        const menu = this.state.menu();
        if (!menu) {
            throw new Error('Menu must be either a TemplateRef or a ComponentType');
        }
        // Create config for the overlay
        const config = {
            content: menu,
            triggerElement: this.trigger.nativeElement,
            viewContainerRef: this.viewContainerRef,
            injector: this.injector,
            context: this.state.context,
            container: this.state.container(),
            placement: this.state.placement,
            offset: this.state.offset(),
            flip: this.state.flip(),
            closeOnOutsideClick: true,
            closeOnEscape: true,
            restoreFocus: true,
            scrollBehaviour: this.state.scrollBehavior(),
        };
        this.overlay.set(createOverlay(config));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMenuTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpMenuTrigger, isStandalone: true, selector: "[ngpMenuTrigger]", inputs: { menu: { classPropertyName: "menu", publicName: "ngpMenuTrigger", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpMenuTriggerDisabled", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpMenuTriggerPlacement", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "ngpMenuTriggerOffset", isSignal: true, isRequired: false, transformFunction: null }, flip: { classPropertyName: "flip", publicName: "ngpMenuTriggerFlip", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "ngpMenuTriggerContainer", isSignal: true, isRequired: false, transformFunction: null }, scrollBehavior: { classPropertyName: "scrollBehavior", publicName: "ngpMenuTriggerScrollBehavior", isSignal: true, isRequired: false, transformFunction: null }, context: { classPropertyName: "context", publicName: "ngpMenuTriggerContext", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "aria-haspopup": "true" }, listeners: { "click": "onClick($event)" }, properties: { "attr.aria-expanded": "open() ? \"true\" : \"false\"", "attr.data-open": "open() ? \"\" : null", "attr.data-placement": "state.placement()" } }, providers: [provideMenuTriggerState({ inherit: false })], exportAs: ["ngpMenuTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMenuTrigger, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMenuTrigger]',
                    exportAs: 'ngpMenuTrigger',
                    providers: [provideMenuTriggerState({ inherit: false })],
                    host: {
                        'aria-haspopup': 'true',
                        '[attr.aria-expanded]': 'open() ? "true" : "false"',
                        '[attr.data-open]': 'open() ? "" : null',
                        '[attr.data-placement]': 'state.placement()',
                        '(click)': 'onClick($event)',
                    },
                }]
        }] });

/**
 * The `NgpMenu` is a container for menu items.
 */
class NgpMenu {
    constructor() {
        /** Access the overlay. */
        this.overlay = injectOverlay();
        /** Access the menu trigger state */
        this.menuTrigger = injectMenuTriggerState();
        /** Access any parent menus */
        this.parentMenu = inject(NgpMenuToken, { optional: true, skipSelf: true });
        /** @internal Whether we should close submenus */
        this.closeSubmenus = new Subject();
    }
    /** @internal Close the menu and any parent menus */
    closeAllMenus(origin) {
        this.menuTrigger().hide(origin);
        this.parentMenu?.closeAllMenus(origin);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMenu, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpMenu, isStandalone: true, selector: "[ngpMenu]", host: { attributes: { "role": "menu", "data-overlay": "" }, properties: { "style.left.px": "overlay.position().x", "style.top.px": "overlay.position().y", "style.--ngp-menu-trigger-width.px": "overlay.triggerWidth()", "style.--ngp-menu-transform-origin": "overlay.transformOrigin()", "attr.data-placement": "overlay.finalPlacement()" } }, providers: [
            // ensure we don't inherit the focus group from the parent menu if there is one
            provideRovingFocusGroup(NgpRovingFocusGroup, { inherit: false }),
            provideMenu(NgpMenu),
        ], exportAs: ["ngpMenu"], hostDirectives: [{ directive: i1.NgpRovingFocusGroup }, { directive: i2.NgpFocusTrap }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMenu, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMenu]',
                    exportAs: 'ngpMenu',
                    hostDirectives: [NgpRovingFocusGroup, NgpFocusTrap],
                    providers: [
                        // ensure we don't inherit the focus group from the parent menu if there is one
                        provideRovingFocusGroup(NgpRovingFocusGroup, { inherit: false }),
                        provideMenu(NgpMenu),
                    ],
                    host: {
                        role: 'menu',
                        '[style.left.px]': 'overlay.position().x',
                        '[style.top.px]': 'overlay.position().y',
                        '[style.--ngp-menu-trigger-width.px]': 'overlay.triggerWidth()',
                        '[style.--ngp-menu-transform-origin]': 'overlay.transformOrigin()',
                        '[attr.data-placement]': 'overlay.finalPlacement()',
                        'data-overlay': '',
                    },
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpMenu, NgpMenuItem, NgpMenuToken, NgpMenuTrigger, NgpSubmenuTrigger, injectMenu, injectMenuTriggerState, injectSubmenuTriggerState, provideMenuConfig, provideMenuTriggerState, provideSubmenuTriggerState };
//# sourceMappingURL=ng-primitives-menu.mjs.map
