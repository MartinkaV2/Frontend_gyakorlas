import * as i0 from '@angular/core';
import { input, numberAttribute, signal, computed, Directive } from '@angular/core';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { uniqueId } from 'ng-primitives/utils';

/**
 * The state token  for the Meter primitive.
 */
const NgpMeterStateToken = createStateToken('Meter');
/**
 * Provides the Meter state.
 */
const provideMeterState = createStateProvider(NgpMeterStateToken);
/**
 * Injects the Meter state.
 */
const injectMeterState = createStateInjector(NgpMeterStateToken);
/**
 * The Meter state registration function.
 */
const meterState = createState(NgpMeterStateToken);

class NgpMeter {
    constructor() {
        /** The value of the meter. */
        this.value = input(0, {
            alias: 'ngpMeterValue',
            transform: numberAttribute,
        });
        /** The minimum value of the meter. */
        this.min = input(0, {
            alias: 'ngpMeterMin',
            transform: numberAttribute,
        });
        /** The maximum value of the meter. */
        this.max = input(100, {
            alias: 'ngpMeterMax',
            transform: numberAttribute,
        });
        /**
         * Define a function that returns the meter value label.
         * @param value The current value
         * @param max The maximum value
         * @returns The value label
         */
        this.valueLabel = input((value, max) => `${Math.round((value / max) * 100)}%`, {
            alias: 'ngpMeterValueLabel',
        });
        /** @internal Store the label instance */
        this.label = signal(null);
        /** @internal The percentage of the meter. */
        this.percentage = computed(() => {
            const value = this.state.value();
            const min = this.state.min();
            const max = this.state.max();
            if (value == null) {
                return 0;
            }
            if (value < min) {
                return 0;
            }
            if (value > max) {
                return 100;
            }
            return ((value - min) / (max - min)) * 100;
        });
        /** The state of the meter. */
        this.state = meterState(this);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeter, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpMeter, isStandalone: true, selector: "[ngpMeter]", inputs: { value: { classPropertyName: "value", publicName: "ngpMeterValue", isSignal: true, isRequired: false, transformFunction: null }, min: { classPropertyName: "min", publicName: "ngpMeterMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpMeterMax", isSignal: true, isRequired: false, transformFunction: null }, valueLabel: { classPropertyName: "valueLabel", publicName: "ngpMeterValueLabel", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "meter" }, properties: { "attr.aria-valuenow": "percentage()", "attr.aria-valuemin": "min()", "attr.aria-valuemax": "max()", "attr.aria-valuetext": "valueLabel()(value(), max())", "attr.aria-labelledby": "label()?.id()" } }, providers: [provideMeterState()], exportAs: ["ngpMeter"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeter, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMeter]',
                    exportAs: 'ngpMeter',
                    providers: [provideMeterState()],
                    host: {
                        role: 'meter',
                        '[attr.aria-valuenow]': 'percentage()',
                        '[attr.aria-valuemin]': 'min()',
                        '[attr.aria-valuemax]': 'max()',
                        '[attr.aria-valuetext]': 'valueLabel()(value(), max())',
                        '[attr.aria-labelledby]': 'label()?.id()',
                    },
                }]
        }] });

class NgpMeterTrack {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterTrack, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpMeterTrack, isStandalone: true, selector: "[ngpMeterTrack]", exportAs: ["ngpMeterTrack"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterTrack, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMeterTrack]',
                    exportAs: 'ngpMeterTrack',
                }]
        }] });

class NgpMeterIndicator {
    constructor() {
        /** Access the meter */
        this.meter = injectMeterState();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterIndicator, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpMeterIndicator, isStandalone: true, selector: "[ngpMeterIndicator]", host: { properties: { "style.width.%": "meter().percentage()" } }, exportAs: ["ngpMeterIndicator"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterIndicator, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMeterIndicator]',
                    exportAs: 'ngpMeterIndicator',
                    host: {
                        '[style.width.%]': 'meter().percentage()',
                    },
                }]
        }] });

class NgpMeterValue {
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterValue, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpMeterValue, isStandalone: true, selector: "[ngpMeterValue]", host: { attributes: { "aria-hidden": "true" } }, exportAs: ["ngpMeterValue"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterValue, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMeterValue]',
                    exportAs: 'ngpMeterValue',
                    host: {
                        'aria-hidden': 'true',
                    },
                }]
        }] });

class NgpMeterLabel {
    constructor() {
        /** Access the meter */
        this.meter = injectMeterState();
        /** The id of the meter label */
        this.id = input(uniqueId('ngp-meter-label'));
        // Register the label with the meter
        this.meter().label.set(this);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterLabel, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpMeterLabel, isStandalone: true, selector: "[ngpMeterLabel]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.id": "id()" } }, exportAs: ["ngpMeterLabel"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpMeterLabel, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpMeterLabel]',
                    exportAs: 'ngpMeterLabel',
                    host: {
                        '[attr.id]': 'id()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpMeter, NgpMeterIndicator, NgpMeterLabel, NgpMeterTrack, NgpMeterValue, injectMeterState, provideMeterState };
//# sourceMappingURL=ng-primitives-meter.mjs.map
