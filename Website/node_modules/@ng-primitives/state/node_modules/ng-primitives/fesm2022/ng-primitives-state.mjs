import { InjectionToken, signal, inject, computed, linkedSignal, isSignal } from '@angular/core';
import { isFunction } from 'ng-primitives/utils';

/**
 * Create a new injection token for the state.
 * @param description The description of the token
 */
function createStateToken(description) {
    return new InjectionToken(`Ngp${description}StateToken`);
}
/**
 * Create a new provider for the state. It first tries to inject the state from the parent injector,
 * as this allows for the state to be hoisted to a higher level in the component tree. This can
 * be useful to avoid issues where the injector can't be shared in some cases when ng-content is used.
 * @param token The token for the state
 */
function createStateProvider(token) {
    return ({ inherit } = {}) => ({
        provide: token,
        useFactory: () => {
            if (inherit === false) {
                // if we are not checking the parent, we want to create a new state
                return signal({});
            }
            // if we are checking the parent, we want to check if the state is already defined
            return inject(token, { optional: true, skipSelf: true }) ?? signal({});
        },
    });
}
function createStateInjector(token, options = {}) {
    return (injectOptions = {}) => {
        const value = inject(token, injectOptions);
        if (options.deferred) {
            return computed(() => value && Object.keys(value() ?? {}).length === 0 ? undefined : value?.());
        }
        return value ?? signal(undefined);
    };
}
/**
 * Convert the original state object into a writable state object.
 * @param token The token for the state
 */
function createState(token) {
    return (state) => {
        const internalState = inject(token);
        internalState.update(obj => {
            // Iterating over properties
            for (const key in state) {
                const value = state[key];
                // We want to make this a controlled input if it is an InputSignal or InputSignalWithTransform
                if (isSignalInput(value)) {
                    // @ts-ignore
                    obj[key] = createControlledInput(value);
                }
                else {
                    // @ts-ignore
                    obj[key] = value;
                }
            }
            // Iterating over prototype methods
            const prototype = Object.getPrototypeOf(state);
            for (const key of Object.getOwnPropertyNames(prototype)) {
                const descriptor = Object.getOwnPropertyDescriptor(prototype, key);
                // if this is a getter or setter, we need to define it on the object
                if (descriptor?.get || descriptor?.set) {
                    Object.defineProperty(obj, key, descriptor);
                }
                else if (isFunction(prototype[key])) {
                    obj[key] = prototype[key].bind(state);
                }
                else {
                    // @ts-ignore
                    obj[key] = prototype[key];
                }
            }
            return { ...obj };
        });
        return internalState();
    };
}
// this is a bit hacky, but we need to do it to track whether this is controlled
function createControlledInput(property) {
    const value = signal(property());
    let isControlled = false;
    const symbol = Object.getOwnPropertySymbols(property).find(s => s.description === 'SIGNAL');
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const inputDefinition = symbol ? property[symbol] : undefined;
    if (!symbol || !inputDefinition || !isFunction(inputDefinition.applyValueToInputSignal)) {
        console.warn('Angular has changed its internal Input implementation, report this issue to ng-primitives.');
        // fallback to a linked signal which is partially controlled
        return linkedSignal(() => property());
    }
    const originalApply = inputDefinition.applyValueToInputSignal.bind(inputDefinition);
    const originalSet = value.set.bind(value);
    const originalUpdate = value.update.bind(value);
    inputDefinition.applyValueToInputSignal = (inputSignalNode, newValue) => {
        isControlled = true;
        originalSet(newValue);
        originalApply(inputSignalNode, newValue);
    };
    value.set = (newValue) => {
        if (!isControlled) {
            originalSet(newValue);
        }
    };
    value.update = (updateFn) => {
        if (!isControlled) {
            originalUpdate(updateFn);
        }
    };
    return value;
}
function isSignalInput(property) {
    if (!isSignal(property)) {
        return false;
    }
    const symbol = Object.getOwnPropertySymbols(property).find(s => s.description === 'SIGNAL');
    if (!symbol) {
        return false;
    }
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    const inputDefinition = symbol ? property[symbol] : undefined;
    if (!inputDefinition) {
        return false;
    }
    return 'transformFn' in inputDefinition || 'applyValueToInputSignal' in inputDefinition;
}

/**
 * Generated bundle index. Do not edit.
 */

export { createState, createStateInjector, createStateProvider, createStateToken };
//# sourceMappingURL=ng-primitives-state.mjs.map
