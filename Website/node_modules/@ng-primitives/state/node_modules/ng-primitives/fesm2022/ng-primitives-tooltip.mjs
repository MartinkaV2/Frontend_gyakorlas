import { setupOverlayArrow, injectOverlay, injectOverlayContext, createOverlay } from 'ng-primitives/portal';
export { injectOverlayContext as injectTooltipContext } from 'ng-primitives/portal';
import * as i0 from '@angular/core';
import { InjectionToken, inject, Directive, input, Component, ElementRef, Injector, ViewContainerRef, booleanAttribute, numberAttribute, signal, computed } from '@angular/core';
import { explicitEffect, setupHover, setupOverflowListener } from 'ng-primitives/internal';
import { isString } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';

const defaultTooltipConfig = {
    offset: 4,
    placement: 'top',
    showDelay: 0,
    hideDelay: 500,
    flip: true,
    container: 'body',
    showOnOverflow: false,
    useTextContent: true,
};
const NgpTooltipConfigToken = new InjectionToken('NgpTooltipConfigToken');
/**
 * Provide the default Tooltip configuration
 * @param config The Tooltip configuration
 * @returns The provider
 */
function provideTooltipConfig(config) {
    return [
        {
            provide: NgpTooltipConfigToken,
            useValue: { ...defaultTooltipConfig, ...config },
        },
    ];
}
/**
 * Inject the Tooltip configuration
 * @returns The global Tooltip configuration
 */
function injectTooltipConfig() {
    return inject(NgpTooltipConfigToken, { optional: true }) ?? defaultTooltipConfig;
}

class NgpTooltipArrow {
    constructor() {
        setupOverlayArrow();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltipArrow, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpTooltipArrow, isStandalone: true, selector: "[ngpTooltipArrow]", exportAs: ["ngpTooltipArrow"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltipArrow, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpTooltipArrow]',
                    exportAs: 'ngpTooltipArrow',
                }]
        }], ctorParameters: () => [] });

/**
 * Apply the `ngpTooltip` directive to an element that represents the tooltip. This typically would be a `div` inside an `ng-template`.
 */
class NgpTooltip {
    constructor() {
        /**
         * Access the overlay.
         */
        this.overlay = injectOverlay();
        /**
         * The unique id of the tooltip.
         */
        this.id = input(this.overlay.id());
        explicitEffect([this.id], ([id]) => this.overlay.id.set(id));
        // if the mouse moves over the tooltip, we want to keep it open
        setupHover({
            hoverStart: () => this.overlay.cancelPendingClose(),
            hoverEnd: () => this.overlay.hide(),
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltip, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpTooltip, isStandalone: true, selector: "[ngpTooltip]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "tooltip", "data-overlay": "" }, properties: { "id": "id()", "style.left.px": "overlay.position().x", "style.top.px": "overlay.position().y", "style.--ngp-tooltip-trigger-width.px": "overlay.triggerWidth()", "style.--ngp-tooltip-transform-origin": "overlay.transformOrigin()", "attr.data-placement": "overlay.finalPlacement()" } }, exportAs: ["ngpTooltip"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltip, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpTooltip]',
                    exportAs: 'ngpTooltip',
                    host: {
                        role: 'tooltip',
                        '[id]': 'id()',
                        '[style.left.px]': 'overlay.position().x',
                        '[style.top.px]': 'overlay.position().y',
                        '[style.--ngp-tooltip-trigger-width.px]': 'overlay.triggerWidth()',
                        '[style.--ngp-tooltip-transform-origin]': 'overlay.transformOrigin()',
                        '[attr.data-placement]': 'overlay.finalPlacement()',
                        'data-overlay': '',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Internal component for wrapping string content in tooltip portals
 * @internal
 */
class NgpTooltipTextContentComponent {
    constructor() {
        /**
         * The string content to display
         */
        this.content = injectOverlayContext();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltipTextContentComponent, deps: [], target: i0.ɵɵFactoryTarget.Component }); }
    static { this.ɵcmp = i0.ɵɵngDeclareComponent({ minVersion: "14.0.0", version: "19.2.11", type: NgpTooltipTextContentComponent, isStandalone: true, selector: "ng-component", host: { attributes: { "ngpTooltip": "" } }, hostDirectives: [{ directive: NgpTooltip }], ngImport: i0, template: '{{ content() }}', isInline: true }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltipTextContentComponent, decorators: [{
            type: Component,
            args: [{
                    template: '{{ content() }}',
                    hostDirectives: [NgpTooltip],
                    host: {
                        // Used only for styling, since the host directive isn’t added to the DOM.
                        // This acts as the styling entry point.
                        ngpTooltip: '',
                    },
                }]
        }] });

/**
 * The state token  for the TooltipTrigger primitive.
 */
const NgpTooltipTriggerStateToken = createStateToken('TooltipTrigger');
/**
 * Provides the TooltipTrigger state.
 */
const provideTooltipTriggerState = createStateProvider(NgpTooltipTriggerStateToken);
/**
 * Injects the TooltipTrigger state.
 */
const injectTooltipTriggerState = createStateInjector(NgpTooltipTriggerStateToken);
/**
 * The TooltipTrigger state registration function.
 */
const tooltipTriggerState = createState(NgpTooltipTriggerStateToken);

/**
 * Apply the `ngpTooltipTrigger` directive to an element that triggers the tooltip to show.
 */
class NgpTooltipTrigger {
    constructor() {
        /**
         * Access the trigger element
         */
        this.trigger = inject((ElementRef));
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the view container reference.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the global tooltip configuration.
         */
        this.config = injectTooltipConfig();
        /**
         * Access the tooltip template ref.
         */
        this.tooltip = input(null, {
            alias: 'ngpTooltipTrigger',
            transform: (value) => (value && !isString(value) ? value : null),
        });
        /**
         * Define if the trigger should be disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpTooltipTriggerDisabled',
            transform: booleanAttribute,
        });
        /**
         * Define the placement of the tooltip relative to the trigger.
         * @default 'top'
         */
        this.placement = input(this.config.placement, {
            alias: 'ngpTooltipTriggerPlacement',
        });
        /**
         * Define the offset of the tooltip relative to the trigger.
         * @default 0
         */
        this.offset = input(this.config.offset, {
            alias: 'ngpTooltipTriggerOffset',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the tooltip is displayed.
         * @default 500
         */
        this.showDelay = input(this.config.showDelay, {
            alias: 'ngpTooltipTriggerShowDelay',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the tooltip is hidden.
         * @default 0
         */
        this.hideDelay = input(this.config.hideDelay, {
            alias: 'ngpTooltipTriggerHideDelay',
            transform: numberAttribute,
        });
        /**
         * Define whether the tooltip should flip when there is not enough space for the tooltip.
         * @default true
         */
        this.flip = input(this.config.flip, {
            alias: 'ngpTooltipTriggerFlip',
            transform: booleanAttribute,
        });
        /**
         * Define the container in which the tooltip should be attached.
         * @default document.body
         */
        this.container = input(this.config.container, {
            alias: 'ngpTooltipTriggerContainer',
        });
        /**
         * Define whether the tooltip should only show when the trigger element overflows.
         * @default false
         */
        this.showOnOverflow = input(this.config.showOnOverflow, {
            alias: 'ngpTooltipTriggerShowOnOverflow',
            transform: booleanAttribute,
        });
        /**
         * Provide context to the tooltip. This can be used to pass data to the tooltip content.
         */
        this.context = input(undefined, {
            alias: 'ngpTooltipTriggerContext',
        });
        /**
         * Define whether to use the text content of the trigger element as the tooltip content.
         * When enabled, the tooltip will display the text content of the trigger element.
         * @default true
         */
        this.useTextContent = input(this.config.useTextContent, {
            alias: 'ngpTooltipTriggerUseTextContent',
            transform: booleanAttribute,
        });
        /**
         * The overlay that manages the tooltip
         * @internal
         */
        this.overlay = signal(null);
        /**
         * The unique id of the tooltip.
         */
        this.tooltipId = signal(undefined);
        /**
         * The open state of the tooltip.
         * @internal
         */
        this.open = computed(() => this.overlay()?.isOpen() ?? false);
        /**
         * Store the state of the tooltip.
         * @internal
         */
        this.state = tooltipTriggerState(this);
        this.hasOverflow = setupOverflowListener(this.trigger.nativeElement, {
            disabled: computed(() => !this.state.showOnOverflow()),
        });
    }
    ngOnDestroy() {
        this.overlay()?.destroy();
    }
    /**
     * Show the tooltip.
     */
    show() {
        // If the trigger is disabled, do not show the tooltip
        if (this.state.disabled() || this.open()) {
            // we mark this as show again to stop it dismissing
            this.overlay()?.cancelPendingClose();
            return;
        }
        // if we should only show when there is overflow, check if the trigger has overflow
        if (this.state.showOnOverflow() && !this.hasOverflow()) {
            // If the trigger does not have overflow, do not show the tooltip
            return;
        }
        // Create the overlay if it doesn't exist yet
        if (!this.overlay()) {
            this.createOverlay();
        }
        this.overlay()?.show();
    }
    /**
     * Hide the tooltip.
     */
    hide() {
        // If the trigger is disabled, do nothing
        if (this.state.disabled()) {
            return;
        }
        this.overlay()?.hide();
    }
    /**
     * Create the overlay that will contain the tooltip
     */
    createOverlay() {
        // Determine the content and context based on useTextContent setting
        const shouldUseTextContent = this.state.useTextContent();
        let content = this.state.tooltip();
        let context = this.state.context;
        if (!content) {
            if (!shouldUseTextContent) {
                if (ngDevMode) {
                    throw new Error('[ngpTooltipTrigger]: Tooltip must be a string, TemplateRef, or ComponentType. Alternatively, set useTextContent to true if none is provided.');
                }
                return;
            }
            const textContent = this.trigger.nativeElement.textContent?.trim() || '';
            if (ngDevMode && !textContent) {
                console.warn('[ngpTooltipTrigger]: useTextContent is enabled but trigger element has no text content');
                return;
            }
            content = NgpTooltipTextContentComponent;
            context = signal(textContent);
        }
        else if (isString(content)) {
            context = signal(content);
            content = NgpTooltipTextContentComponent;
        }
        // Create config for the overlay
        const config = {
            content,
            triggerElement: this.trigger.nativeElement,
            injector: this.injector,
            context,
            container: this.state.container(),
            placement: this.state.placement(),
            offset: this.state.offset(),
            flip: this.state.flip(),
            showDelay: this.state.showDelay(),
            hideDelay: this.state.hideDelay(),
            closeOnEscape: true,
            closeOnOutsideClick: true,
            viewContainerRef: this.viewContainerRef,
        };
        // Create the overlay instance
        this.overlay.set(createOverlay(config));
    }
    /**
     * Set the tooltip id.
     */
    setTooltipId(id) {
        this.tooltipId.set(id);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltipTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpTooltipTrigger, isStandalone: true, selector: "[ngpTooltipTrigger]", inputs: { tooltip: { classPropertyName: "tooltip", publicName: "ngpTooltipTrigger", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpTooltipTriggerDisabled", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpTooltipTriggerPlacement", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "ngpTooltipTriggerOffset", isSignal: true, isRequired: false, transformFunction: null }, showDelay: { classPropertyName: "showDelay", publicName: "ngpTooltipTriggerShowDelay", isSignal: true, isRequired: false, transformFunction: null }, hideDelay: { classPropertyName: "hideDelay", publicName: "ngpTooltipTriggerHideDelay", isSignal: true, isRequired: false, transformFunction: null }, flip: { classPropertyName: "flip", publicName: "ngpTooltipTriggerFlip", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "ngpTooltipTriggerContainer", isSignal: true, isRequired: false, transformFunction: null }, showOnOverflow: { classPropertyName: "showOnOverflow", publicName: "ngpTooltipTriggerShowOnOverflow", isSignal: true, isRequired: false, transformFunction: null }, context: { classPropertyName: "context", publicName: "ngpTooltipTriggerContext", isSignal: true, isRequired: false, transformFunction: null }, useTextContent: { classPropertyName: "useTextContent", publicName: "ngpTooltipTriggerUseTextContent", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "mouseenter": "show()", "mouseleave": "hide()", "focus": "show()", "blur": "hide()" }, properties: { "attr.data-open": "open() ? \"\" : null", "attr.data-disabled": "state.disabled() ? \"\" : null", "attr.aria-describedby": "overlay()?.ariaDescribedBy()" } }, providers: [provideTooltipTriggerState()], exportAs: ["ngpTooltipTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpTooltipTrigger, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpTooltipTrigger]',
                    exportAs: 'ngpTooltipTrigger',
                    providers: [provideTooltipTriggerState()],
                    host: {
                        '[attr.data-open]': 'open() ? "" : null',
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                        '[attr.aria-describedby]': 'overlay()?.ariaDescribedBy()',
                        '(mouseenter)': 'show()',
                        '(mouseleave)': 'hide()',
                        '(focus)': 'show()',
                        '(blur)': 'hide()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpTooltip, NgpTooltipArrow, NgpTooltipTrigger, injectTooltipTriggerState, provideTooltipConfig, provideTooltipTriggerState };
//# sourceMappingURL=ng-primitives-tooltip.mjs.map
