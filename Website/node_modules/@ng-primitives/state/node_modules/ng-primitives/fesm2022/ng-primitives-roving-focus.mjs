import { Directionality } from '@angular/cdk/bidi';
import * as i0 from '@angular/core';
import { InjectionToken, inject, input, booleanAttribute, signal, Directive, ElementRef, computed, HostListener } from '@angular/core';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { FocusMonitor } from '@angular/cdk/a11y';

/**
 * The state token  for the RovingFocusGroup primitive.
 */
const NgpRovingFocusGroupStateToken = createStateToken('RovingFocusGroup');
/**
 * Provides the RovingFocusGroup state.
 */
const provideRovingFocusGroupState = createStateProvider(NgpRovingFocusGroupStateToken);
/**
 * Injects the RovingFocusGroup state.
 */
const injectRovingFocusGroupState = createStateInjector(NgpRovingFocusGroupStateToken);
/**
 * The RovingFocusGroup state registration function.
 */
const rovingFocusGroupState = createState(NgpRovingFocusGroupStateToken);

const NgpRovingFocusGroupToken = new InjectionToken('NgpRovingFocusGroupToken');
/**
 * Inject the RovingFocusGroup directive instance
 * @returns The RovingFocusGroup directive instance
 */
function injectRovingFocusGroup() {
    return inject(NgpRovingFocusGroupToken);
}
/**
 * Provide the RovingFocusGroup directive instance
 * @param type The RovingFocusGroup directive type
 * @returns The RovingFocusGroup token
 */
function provideRovingFocusGroup(type, { inherit = true } = {}) {
    return {
        provide: NgpRovingFocusGroupToken,
        // Roving focus groups may be nested, in this case, the parent group should be used
        useFactory: () => {
            if (!inherit) {
                return inject(type, { self: true });
            }
            // If the parent group is not found, return the current group
            // This is useful for nested groups
            return (inject(NgpRovingFocusGroupToken, { skipSelf: true, optional: true }) ??
                inject(type, { self: true }));
        },
    };
}

/**
 * Apply the `ngpRovingFocusGroup` directive to an element to manage focus for a group of child elements.
 */
class NgpRovingFocusGroup {
    constructor() {
        /**
         * Access the directionality service.
         */
        this.directionality = inject(Directionality);
        /**
         * Determine the orientation of the roving focus group.
         * @default 'vertical'
         */
        this.orientation = input('vertical', {
            alias: 'ngpRovingFocusGroupOrientation',
        });
        /**
         * Determine if focus should wrap when the end or beginning is reached.
         */
        this.wrap = input(true, {
            alias: 'ngpRovingFocusGroupWrap',
            transform: booleanAttribute,
        });
        /**
         * Determine if the home and end keys should navigate to the first and last items.
         */
        this.homeEnd = input(true, {
            alias: 'ngpRovingFocusGroupHomeEnd',
            transform: booleanAttribute,
        });
        /**
         * Determine if the roving focus group is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpRovingFocusGroupDisabled',
            transform: booleanAttribute,
        });
        /**
         * Store the items in the roving focus group.
         */
        this.items = signal([]);
        /**
         * Store the active item in the roving focus group.
         * @internal
         */
        this.activeItem = signal(null);
        /**
         * The state of the roving focus group.
         */
        this.state = rovingFocusGroupState(this);
    }
    /**
     * Get the items in the roving focus group sorted by order.
     */
    get sortedItems() {
        return this.items().sort((a, b) => {
            // sort the items by their position in the document
            return a.elementRef.nativeElement.compareDocumentPosition(b.elementRef.nativeElement) &
                Node.DOCUMENT_POSITION_FOLLOWING
                ? -1
                : 1;
        });
    }
    /**
     * Register an item with the roving focus group.
     * @param item The item to register
     * @internal
     */
    register(item) {
        this.items.update(items => [...items, item]);
        // if there is no active item, make the first item the tabbable item
        if (!this.activeItem()) {
            this.activeItem.set(item);
        }
    }
    /**
     * Unregister an item with the roving focus group.
     * @param item The item to unregister
     * @internal
     */
    unregister(item) {
        this.items.update(items => items.filter(i => i !== item));
        // check if the unregistered item is the active item
        if (this.activeItem() === item) {
            // if the active item is unregistered, activate the first item
            this.activeItem.set(this.items()[0] ?? null);
        }
    }
    /**
     * Activate an item in the roving focus group.
     * @param item The item to activate
     * @param origin The origin of the focus change
     */
    setActiveItem(item, origin = 'program') {
        this.activeItem.set(item);
        item?.focus(origin);
    }
    /**
     * Activate the first item in the roving focus group.
     * @param origin The origin of the focus change
     */
    activateFirstItem(origin) {
        // find the first item that is not disabled
        const item = this.sortedItems.find(i => !i.disabled()) ?? null;
        // set the first item as the active item
        this.setActiveItem(item, origin);
    }
    /**
     * Activate the last item in the roving focus group.
     * @param origin The origin of the focus change
     */
    activateLastItem(origin) {
        // find the last item that is not disabled
        const item = [...this.sortedItems].reverse().find(i => !i.disabled()) ?? null;
        // set the last item as the active item
        this.setActiveItem(item, origin);
    }
    /**
     * Activate the next item in the roving focus group.
     * @param origin The origin of the focus change
     */
    activateNextItem(origin) {
        const activeItem = this.activeItem();
        // if there is no active item, activate the first item
        if (!activeItem) {
            this.activateFirstItem(origin);
            return;
        }
        // find the index of the active item
        const index = this.sortedItems.indexOf(activeItem);
        // find the next item that is not disabled
        const item = this.sortedItems.slice(index + 1).find(i => !i.disabled()) ?? null;
        // if we are at the end of the list, wrap to the beginning
        if (!item && this.state.wrap()) {
            this.activateFirstItem(origin);
            return;
        }
        // if there is no next item, do nothing
        if (!item) {
            return;
        }
        // set the next item as the active item
        this.setActiveItem(item, origin);
    }
    /**
     * Activate the previous item in the roving focus group.
     * @param origin The origin of the focus change
     */
    activatePreviousItem(origin) {
        const activeItem = this.activeItem();
        // if there is no active item, activate the last item
        if (!activeItem) {
            this.activateLastItem(origin);
            return;
        }
        // find the index of the active item
        const index = this.sortedItems.indexOf(activeItem);
        // find the previous item that is not disabled
        const item = this.sortedItems
            .slice(0, index)
            .reverse()
            .find(i => !i.disabled()) ?? null;
        // if we are at the beginning of the list, wrap to the end
        if (!item && this.state.wrap()) {
            this.activateLastItem(origin);
            return;
        }
        // if there is no previous item, do nothing
        if (!item) {
            return;
        }
        // set the previous item as the active item
        this.setActiveItem(item, origin);
    }
    /**
     * Handle keyboard navigation for the roving focus group.
     * @param event The keyboard event
     * @internal
     */
    onKeydown(event) {
        if (this.state.disabled()) {
            return;
        }
        switch (event.key) {
            case 'ArrowUp':
                if (this.state.orientation() === 'vertical') {
                    event.preventDefault();
                    this.activatePreviousItem('keyboard');
                }
                break;
            case 'ArrowDown':
                if (this.state.orientation() === 'vertical') {
                    event.preventDefault();
                    this.activateNextItem('keyboard');
                }
                break;
            case 'ArrowLeft':
                if (this.state.orientation() === 'horizontal') {
                    event.preventDefault();
                    if (this.directionality.value === 'ltr') {
                        this.activatePreviousItem('keyboard');
                    }
                    else {
                        this.activateNextItem('keyboard');
                    }
                }
                break;
            case 'ArrowRight':
                if (this.state.orientation() === 'horizontal') {
                    event.preventDefault();
                    if (this.directionality.value === 'ltr') {
                        this.activateNextItem('keyboard');
                    }
                    else {
                        this.activatePreviousItem('keyboard');
                    }
                }
                break;
            case 'Home':
                if (this.state.homeEnd()) {
                    event.preventDefault();
                    this.activateFirstItem('keyboard');
                }
                break;
            case 'End':
                if (this.state.homeEnd()) {
                    event.preventDefault();
                    this.activateLastItem('keyboard');
                }
                break;
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRovingFocusGroup, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpRovingFocusGroup, isStandalone: true, selector: "[ngpRovingFocusGroup]", inputs: { orientation: { classPropertyName: "orientation", publicName: "ngpRovingFocusGroupOrientation", isSignal: true, isRequired: false, transformFunction: null }, wrap: { classPropertyName: "wrap", publicName: "ngpRovingFocusGroupWrap", isSignal: true, isRequired: false, transformFunction: null }, homeEnd: { classPropertyName: "homeEnd", publicName: "ngpRovingFocusGroupHomeEnd", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpRovingFocusGroupDisabled", isSignal: true, isRequired: false, transformFunction: null } }, providers: [provideRovingFocusGroup(NgpRovingFocusGroup), provideRovingFocusGroupState()], exportAs: ["ngpRovingFocusGroup"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRovingFocusGroup, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRovingFocusGroup]',
                    exportAs: 'ngpRovingFocusGroup',
                    providers: [provideRovingFocusGroup(NgpRovingFocusGroup), provideRovingFocusGroupState()],
                }]
        }] });

/**
 * Apply the `ngpRovingFocusItem` directive to an element within a roving focus group to automatically manage focus.
 */
class NgpRovingFocusItem {
    constructor() {
        /**
         * Access the group the roving focus item belongs to.
         */
        this.group = injectRovingFocusGroup();
        /**
         * Access the focus monitor service.
         */
        this.focusMonitor = inject(FocusMonitor);
        /**
         * Access the element the roving focus item is attached to.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Define if the item is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpRovingFocusItemDisabled',
            transform: booleanAttribute,
        });
        /**
         * Derive the tabindex of the roving focus item.
         */
        this.tabindex = computed(() => !this.group.disabled() && this.group.activeItem() === this ? 0 : -1);
    }
    /**
     * Initialize the roving focus item.
     */
    ngOnInit() {
        this.group.register(this);
    }
    /**
     * Clean up the roving focus item.
     */
    ngOnDestroy() {
        this.group.unregister(this);
    }
    /**
     * Forward the keydown event to the roving focus group.
     * @param event The keyboard event
     */
    onKeydown(event) {
        if (this.disabled()) {
            return;
        }
        this.group.onKeydown(event);
    }
    /**
     * Activate the roving focus item on click.
     */
    activate() {
        if (this.disabled()) {
            return;
        }
        this.group.setActiveItem(this, 'mouse');
    }
    /**
     * Focus the roving focus item.
     * @param origin The origin of the focus
     */
    focus(origin) {
        this.focusMonitor.focusVia(this.elementRef, origin);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRovingFocusItem, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpRovingFocusItem, isStandalone: true, selector: "[ngpRovingFocusItem]", inputs: { disabled: { classPropertyName: "disabled", publicName: "ngpRovingFocusItemDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "keydown": "onKeydown($event)", "click": "activate()" }, properties: { "attr.tabindex": "tabindex()" } }, exportAs: ["ngpRovingFocusItem"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRovingFocusItem, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRovingFocusItem]',
                    exportAs: 'ngpRovingFocusItem',
                    host: {
                        '[attr.tabindex]': 'tabindex()',
                    },
                }]
        }], propDecorators: { onKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }], activate: [{
                type: HostListener,
                args: ['click']
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpRovingFocusGroup, NgpRovingFocusGroupToken, NgpRovingFocusItem, injectRovingFocusGroup, injectRovingFocusGroupState, provideRovingFocusGroup, provideRovingFocusGroupState };
//# sourceMappingURL=ng-primitives-roving-focus.mjs.map
