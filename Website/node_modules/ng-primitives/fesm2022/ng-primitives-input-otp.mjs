import * as i0 from '@angular/core';
import { HostListener, Directive, computed, input, booleanAttribute, output, signal } from '@angular/core';
import * as i1 from 'ng-primitives/a11y';
import { NgpVisuallyHidden } from 'ng-primitives/a11y';
import { injectElementRef } from 'ng-primitives/internal';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { ngpInteractions } from 'ng-primitives/interactions';
import { uniqueId } from 'ng-primitives/utils';

/**
 * The state token for the InputOtp primitive.
 */
const NgpInputOtpStateToken = createStateToken('InputOtp');
/**
 * Provides the InputOtp state.
 */
const provideInputOtpState = createStateProvider(NgpInputOtpStateToken);
/**
 * Injects the InputOtp state.
 */
const injectInputOtpState = createStateInjector(NgpInputOtpStateToken);
/**
 * The InputOtp state registration function.
 */
const inputOtpState = createState(NgpInputOtpStateToken);

class NgpInputOtpInput {
    constructor() {
        /**
         * Access the element reference.
         */
        this.elementRef = injectElementRef();
        /**
         * Access the input-otp state.
         */
        this.state = injectInputOtpState();
        // Register this input with the parent
        this.state().registerInput(this);
    }
    ngAfterViewInit() {
        // Set initial value
        this.elementRef.nativeElement.value = this.state().value();
    }
    /**
     * Focus the input.
     * @internal
     */
    focus() {
        this.elementRef.nativeElement.focus();
    }
    /**
     * Set selection range.
     * @param start Start position
     * @param end End position
     * @internal
     */
    setSelectionRange(start, end) {
        this.elementRef.nativeElement.setSelectionRange(start, end);
    }
    /**
     * Handle input events (typing).
     */
    onInput(event) {
        if (this.state().disabled()) {
            return;
        }
        const input = event.target;
        let newValue = input.value;
        // Validate against pattern if provided
        const pattern = this.state().pattern();
        if (pattern) {
            const patternRegex = new RegExp(pattern);
            const filteredValue = newValue
                .split('')
                .filter(char => patternRegex.test(char))
                .join('');
            if (filteredValue !== newValue) {
                newValue = filteredValue;
                input.value = newValue;
            }
        }
        // Clamp to maxLength
        const maxLength = this.state().maxLength();
        if (newValue.length > maxLength) {
            newValue = newValue.substring(0, maxLength);
            input.value = newValue;
        }
        this.state().updateValue(newValue);
        this.updateSelection();
    }
    /**
     * Handle paste events.
     */
    onPaste(event) {
        if (this.state().disabled()) {
            return;
        }
        event.preventDefault();
        const clipboardData = event.clipboardData?.getData('text') || '';
        let pastedText = clipboardData.trim();
        // Apply paste transformer if provided
        const transformer = this.state().pasteTransformer();
        if (transformer) {
            pastedText = transformer(pastedText);
        }
        // Validate against pattern if provided
        const pattern = this.state().pattern();
        if (pattern) {
            const patternRegex = new RegExp(pattern);
            pastedText = pastedText
                .split('')
                .filter(char => patternRegex.test(char))
                .join('');
        }
        // Clamp to maxLength
        const maxLength = this.state().maxLength();
        if (pastedText.length > maxLength) {
            pastedText = pastedText.substring(0, maxLength);
        }
        // Update the input value and state
        this.elementRef.nativeElement.value = pastedText;
        this.state().updateValue(pastedText);
        // Set caret to the end
        const endPosition = pastedText.length;
        this.setSelectionRange(endPosition, endPosition);
        this.updateSelection();
    }
    /**
     * Handle focus events.
     */
    onFocus() {
        this.state().updateFocus(true);
        this.updateSelection();
    }
    /**
     * Handle blur events.
     */
    onBlur() {
        this.state().updateFocus(false);
    }
    /**
     * Handle keyup events to update selection.
     */
    onKeyup() {
        this.updateSelection();
    }
    /**
     * Handle selection change events.
     */
    onSelect() {
        this.updateSelection();
    }
    /**
     * Update the selection state.
     */
    updateSelection() {
        const input = this.elementRef.nativeElement;
        const maxLength = this.state().maxLength();
        // If input is at max length, set selection to last character
        if (input.value.length === maxLength) {
            input.setSelectionRange(input.value.length - 1, input.value.length);
        }
        // if the input is not at max length, set selection at the end
        if (input.value.length < maxLength) {
            input.setSelectionRange(input.value.length, input.value.length);
        }
        const start = input.selectionStart || 0;
        const end = input.selectionEnd || 0;
        this.state().updateSelection(start, end);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpInputOtpInput, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpInputOtpInput, isStandalone: true, selector: "input[ngpInputOtpInput]", host: { attributes: { "autocomplete": "one-time-code" }, listeners: { "input": "onInput($event)", "paste": "onPaste($event)", "focus": "onFocus()", "blur": "onBlur()", "keyup": "onKeyup()", "select": "onSelect()" }, properties: { "attr.inputmode": "state().inputMode()", "attr.maxlength": "state().maxLength()", "attr.pattern": "state().pattern() || null", "attr.disabled": "state().disabled() ? \"\" : null" } }, exportAs: ["ngpInputOtpInput"], hostDirectives: [{ directive: i1.NgpVisuallyHidden }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpInputOtpInput, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[ngpInputOtpInput]',
                    exportAs: 'ngpInputOtpInput',
                    hostDirectives: [NgpVisuallyHidden],
                    host: {
                        autocomplete: 'one-time-code',
                        '[attr.inputmode]': 'state().inputMode()',
                        '[attr.maxlength]': 'state().maxLength()',
                        '[attr.pattern]': 'state().pattern() || null',
                        '[attr.disabled]': 'state().disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { onInput: [{
                type: HostListener,
                args: ['input', ['$event']]
            }], onPaste: [{
                type: HostListener,
                args: ['paste', ['$event']]
            }], onFocus: [{
                type: HostListener,
                args: ['focus']
            }], onBlur: [{
                type: HostListener,
                args: ['blur']
            }], onKeyup: [{
                type: HostListener,
                args: ['keyup']
            }], onSelect: [{
                type: HostListener,
                args: ['select']
            }] } });

class NgpInputOtpSlot {
    constructor() {
        /**
         * Access the input-otp state.
         */
        this.state = injectInputOtpState();
        /**
         * The computed index of this slot based on registration order.
         */
        this.index = computed(() => this.state().getSlotIndex(this));
        /**
         * The character for this slot from the value string.
         */
        this.char = computed(() => {
            const value = this.state().value();
            const currentIndex = this.index();
            return currentIndex >= 0 && currentIndex < value.length ? value[currentIndex] : null;
        });
        /**
         * Whether this slot is focused (active).
         */
        this.focused = computed(() => {
            const currentIndex = this.index();
            const isFocused = this.state().isFocused();
            const selectionStart = this.state().selectionStart();
            const value = this.state().value();
            const maxLength = this.state().maxLength();
            return (isFocused &&
                (currentIndex === selectionStart ||
                    (value.length === maxLength && currentIndex === maxLength - 1)));
        });
        /**
         * Whether this slot should show the caret.
         */
        this.caret = computed(() => {
            const currentIndex = this.index();
            const isFocused = this.state().isFocused();
            const selectionStart = this.state().selectionStart();
            const selectionEnd = this.state().selectionEnd();
            const value = this.state().value();
            const maxLength = this.state().maxLength();
            return (isFocused &&
                currentIndex === selectionStart &&
                selectionStart === selectionEnd &&
                value.length < maxLength);
        });
        /**
         * Whether this slot is filled with a character.
         */
        this.filled = computed(() => this.char() !== null);
        /**
         * Whether to show placeholder for this slot.
         */
        this.showPlaceholder = computed(() => {
            const placeholder = this.state().placeholder();
            return !this.filled() && !!placeholder;
        });
        /**
         * The display character for this slot (character or placeholder).
         */
        this.displayChar = computed(() => {
            const char = this.char();
            if (char)
                return char;
            if (this.showPlaceholder())
                return this.state().placeholder();
            return '';
        });
        this.state().registerSlot(this);
    }
    ngOnDestroy() {
        // Unregister this slot when destroyed
        this.state().unregisterSlot(this);
    }
    /**
     * Handle click events on the slot.
     * @internal
     */
    onClick(event) {
        if (this.state().disabled())
            return;
        const currentValue = this.state().value();
        const maxLength = this.state().maxLength();
        // Focus the first empty slot, or the last slot if all are filled
        const targetPosition = currentValue.length < maxLength ? currentValue.length : maxLength - 1;
        this.state().focusAtPosition(targetPosition);
        event.preventDefault();
        event.stopPropagation();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpInputOtpSlot, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpInputOtpSlot, isStandalone: true, selector: "[ngpInputOtpSlot]", host: { attributes: { "role": "presentation" }, listeners: { "click": "onClick($event)" }, properties: { "attr.data-slot-index": "index()", "attr.data-active": "focused() ? \"\" : null", "attr.data-filled": "filled() ? \"\" : null", "attr.data-caret": "caret() ? \"\" : null", "attr.data-placeholder": "showPlaceholder() ? \"\" : null", "textContent": "displayChar()" } }, exportAs: ["ngpInputOtpSlot"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpInputOtpSlot, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpInputOtpSlot]',
                    exportAs: 'ngpInputOtpSlot',
                    host: {
                        role: 'presentation',
                        '[attr.data-slot-index]': 'index()',
                        '[attr.data-active]': 'focused() ? "" : null',
                        '[attr.data-filled]': 'filled() ? "" : null',
                        '[attr.data-caret]': 'caret() ? "" : null',
                        '[attr.data-placeholder]': 'showPlaceholder() ? "" : null',
                        '[textContent]': 'displayChar()',
                        '(click)': 'onClick($event)',
                    },
                }]
        }], ctorParameters: () => [] });

class NgpInputOtp {
    constructor() {
        /**
         * Access the element reference.
         */
        this.elementRef = injectElementRef();
        /**
         * The id of the input-otp.
         */
        this.id = input(uniqueId('ngp-input-otp'));
        /**
         * The current value of the OTP.
         */
        this.value = input('', {
            alias: 'ngpInputOtpValue',
        });
        /**
         * The regex pattern for allowed characters.
         */
        this.pattern = input('[0-9]', {
            alias: 'ngpInputOtpPattern',
        });
        /**
         * The input mode for the hidden input.
         */
        this.inputMode = input('text', {
            alias: 'ngpInputOtpInputMode',
        });
        /**
         * Function to transform pasted text.
         */
        this.pasteTransformer = input(undefined, {
            alias: 'ngpInputOtpPasteTransformer',
        });
        /**
         * Whether the input-otp is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpInputOtpDisabled',
            transform: booleanAttribute,
        });
        /**
         * The placeholder character to display when a slot is empty.
         */
        this.placeholder = input('', {
            alias: 'ngpInputOtpPlaceholder',
        });
        /**
         * Event emitted when the value changes.
         */
        this.valueChange = output({
            alias: 'ngpInputOtpValueChange',
        });
        /**
         * Event emitted when the OTP is complete (maxLength characters entered).
         */
        this.complete = output({
            alias: 'ngpInputOtpComplete',
        });
        /**
         * Store the input element reference.
         * @internal
         */
        this.inputElement = signal(undefined);
        /**
         * Store registered slots in order.
         * @internal
         */
        this.slots = signal([]);
        /**
         * The number of characters in the OTP, derived from registered slots.
         */
        this.maxLength = computed(() => this.slots().length);
        /**
         * The focus state of the input.
         * @internal
         */
        this.isFocused = signal(false);
        /**
         * The selection start position.
         * @internal
         */
        this.selectionStart = signal(0);
        /**
         * The selection end position.
         * @internal
         */
        this.selectionEnd = signal(0);
        /**
         * The state of the input-otp.
         */
        this.state = inputOtpState(this);
        ngpInteractions({
            hover: true,
            press: true,
            focus: true,
            disabled: this.state.disabled,
        });
    }
    /**
     * Register an input element with the input-otp.
     * @param input The input element to register.
     * @internal
     */
    registerInput(input) {
        this.inputElement.set(input);
    }
    /**
     * Register a slot with the input-otp.
     * @param slot The slot to register.
     * @internal
     */
    registerSlot(slot) {
        this.slots.update(currentSlots => [...currentSlots, slot]);
    }
    /**
     * Unregister a slot from the input-otp.
     * @param slot The slot to unregister.
     * @internal
     */
    unregisterSlot(slot) {
        this.slots.update(currentSlots => currentSlots.filter(s => s !== slot));
    }
    /**
     * Get the index of a registered slot.
     * @param slot The slot to get the index for.
     * @returns The index of the slot, or -1 if not found.
     * @internal
     */
    getSlotIndex(slot) {
        return this.slots().indexOf(slot);
    }
    /**
     * Update the value and emit change events.
     * @param newValue The new value.
     * @internal
     */
    updateValue(newValue) {
        if (newValue === this.state.value()) {
            return;
        }
        this.state.value.set(newValue);
        this.valueChange.emit(newValue);
        // Emit complete event when the OTP is complete
        if (newValue.length === this.maxLength()) {
            this.complete.emit(newValue);
        }
    }
    /**
     * Update focus state.
     * @param focused Whether the input is focused.
     * @internal
     */
    updateFocus(focused) {
        this.isFocused.set(focused);
    }
    /**
     * Update selection state.
     * @param start Selection start position.
     * @param end Selection end position.
     * @internal
     */
    updateSelection(start, end) {
        this.selectionStart.set(start);
        this.selectionEnd.set(end);
    }
    /**
     * Focus the input and set caret to the specified position.
     * @param position The position to set the caret to.
     * @internal
     */
    focusAtPosition(position) {
        const input = this.inputElement();
        if (!input) {
            return;
        }
        input.focus();
        input.setSelectionRange(position, position);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpInputOtp, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpInputOtp, isStandalone: true, selector: "[ngpInputOtp]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpInputOtpValue", isSignal: true, isRequired: false, transformFunction: null }, pattern: { classPropertyName: "pattern", publicName: "ngpInputOtpPattern", isSignal: true, isRequired: false, transformFunction: null }, inputMode: { classPropertyName: "inputMode", publicName: "ngpInputOtpInputMode", isSignal: true, isRequired: false, transformFunction: null }, pasteTransformer: { classPropertyName: "pasteTransformer", publicName: "ngpInputOtpPasteTransformer", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpInputOtpDisabled", isSignal: true, isRequired: false, transformFunction: null }, placeholder: { classPropertyName: "placeholder", publicName: "ngpInputOtpPlaceholder", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { valueChange: "ngpInputOtpValueChange", complete: "ngpInputOtpComplete" }, providers: [provideInputOtpState()], exportAs: ["ngpInputOtp"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpInputOtp, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpInputOtp]',
                    exportAs: 'ngpInputOtp',
                    providers: [provideInputOtpState()],
                }]
        }], ctorParameters: () => [] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpInputOtp, NgpInputOtpInput, NgpInputOtpSlot, injectInputOtpState, provideInputOtpState };
//# sourceMappingURL=ng-primitives-input-otp.mjs.map
