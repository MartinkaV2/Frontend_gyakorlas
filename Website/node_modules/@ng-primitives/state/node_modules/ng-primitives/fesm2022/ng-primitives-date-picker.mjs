import * as i0 from '@angular/core';
import { InjectionToken, inject, TemplateRef, ViewContainerRef, Injector, Directive, contentChild, computed, ElementRef, HostListener, input, numberAttribute, booleanAttribute, output, signal, afterNextRender } from '@angular/core';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { FocusMonitor } from '@angular/cdk/a11y';
import { setupButton } from 'ng-primitives/button';
import { injectDateAdapter } from 'ng-primitives/date-time';
import { uniqueId } from 'ng-primitives/utils';
import { explicitEffect } from 'ng-primitives/internal';

const defaultDatePickerConfig = {
    firstDayOfWeek: 7,
};
const NgpDatePickerConfigToken = new InjectionToken('NgpDatePickerConfigToken');
/**
 * Provide the default DatePicker / DateRangePicker configuration
 * @param config The DatePicker / DateRangePicker configuration
 * @returns The provider
 */
function provideDatePickerConfig(config) {
    return [
        {
            provide: NgpDatePickerConfigToken,
            useValue: { ...defaultDatePickerConfig, ...config },
        },
    ];
}
/**
 * Inject the DatePicker / DateRangePicker configuration
 * @returns The global DatePicker / DateRangePicker configuration
 */
function injectDatePickerConfig() {
    return inject(NgpDatePickerConfigToken, { optional: true }) ?? defaultDatePickerConfig;
}

const NgpDatePickerRowRenderToken = new InjectionToken('NgpDatePickerRowRenderToken');
/**
 * Inject the DatePickerRowRender directive instance
 */
function injectDatePickerRowRender() {
    return inject(NgpDatePickerRowRenderToken);
}
const NgpDatePickerWeekToken = new InjectionToken('NgpDatePickerWeekToken');
/**
 * Inject current week days
 */
function injectDatePickerWeek() {
    return inject(NgpDatePickerWeekToken);
}

const NgpDatePickerCellRenderToken = new InjectionToken('NgpDatePickerCellRenderToken');
/**
 * Inject the DatePickerCell directive instance
 */
function injectDatePickerCellRender() {
    return inject(NgpDatePickerCellRenderToken);
}
const NgpDatePickerCellDateToken = new InjectionToken('NgpDatePickerCellDateToken');
/**
 * Inject current cell date
 */
function injectDatePickerCellDate() {
    return inject(NgpDatePickerCellDateToken);
}

/**
 * A structural directive that renders a cell in the date picker grid.
 */
class NgpDatePickerCellRender {
    // Make sure the template checker knows the type of the context with which the
    // template of this directive will be rendered
    static ngTemplateContextGuard(_, context) {
        return true;
    }
    constructor() {
        /**
         * Access the template ref for the cell.
         */
        this.templateRef = inject(TemplateRef);
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the dates in the week.
         */
        this.dates = injectDatePickerWeek();
        /**
         * Store the view refs for the dates.
         */
        this.viewRefs = [];
        this.renderDates();
    }
    /**
     * Render the dates in the week.
     */
    renderDates() {
        this.viewRefs.forEach(viewRef => viewRef.destroy());
        for (const date of this.dates) {
            const viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, {
                $implicit: date,
            }, {
                injector: Injector.create({
                    parent: this.viewContainerRef.injector,
                    providers: [{ provide: NgpDatePickerCellDateToken, useValue: date }],
                }),
            });
            this.viewRefs.push(viewRef);
        }
    }
    /**
     * Destroy the view refs.
     */
    ngOnDestroy() {
        this.viewRefs.forEach(viewRef => viewRef.destroy());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerCellRender, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpDatePickerCellRender, isStandalone: true, selector: "[ngpDatePickerCellRender]", providers: [{ provide: NgpDatePickerCellRenderToken, useExisting: NgpDatePickerCellRender }], exportAs: ["ngpDatePickerCellRender"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerCellRender, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerCellRender]',
                    exportAs: 'ngpDatePickerCellRender',
                    providers: [{ provide: NgpDatePickerCellRenderToken, useExisting: NgpDatePickerCellRender }],
                }]
        }], ctorParameters: () => [] });

const NgpDatePickerDateButtonToken = new InjectionToken('NgpDatePickerDateButtonToken');
/**
 * Inject the DatePickerDateButton directive instance
 */
function injectDatePickerDateButton() {
    return inject(NgpDatePickerDateButtonToken);
}

/**
 * The state token  for the DateRangePicker primitive.
 */
const NgpDateRangePickerStateToken = createStateToken('DateRangePicker');
/**
 * Provides the DateRangePicker state.
 */
const provideDateRangePickerState = createStateProvider(NgpDateRangePickerStateToken);
/**
 * Injects the DateRangePicker state.
 */
const injectDateRangePickerState = createStateInjector(NgpDateRangePickerStateToken);
/**
 * The DateRangePicker state registration function.
 */
const dateRangePickerState = createState(NgpDateRangePickerStateToken);

const NgpDatePickerStateToken = createStateToken('DatePicker');
const provideDatePickerState = createStateProvider(NgpDatePickerStateToken);
const injectDatePickerState = createStateInjector(NgpDatePickerStateToken);
const datePickerState = createState(NgpDatePickerStateToken);
function injectDateControllerState() {
    const datePickerState = injectDatePickerState({ optional: true });
    const dateRangePickerState = injectDateRangePickerState({ optional: true });
    if (datePickerState()) {
        return datePickerState;
    }
    else if (dateRangePickerState()) {
        return dateRangePickerState;
    }
    else {
        throw new Error('No date picker or date range picker state found');
    }
}

/**
 * A cell in the date picker grid.
 */
class NgpDatePickerCell {
    constructor() {
        /**
         * Access the date picker.
         */
        this.state = injectDateControllerState();
        /**
         * Access the child date picker date button.
         */
        this.datePickerButton = contentChild(NgpDatePickerDateButtonToken, {
            descendants: true,
        });
        /**
         * Access the label id.
         */
        this.labelId = computed(() => this.state().label()?.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerCell, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.11", type: NgpDatePickerCell, isStandalone: true, selector: "[ngpDatePickerCell]", host: { attributes: { "role": "gridcell" }, properties: { "attr.data-selected": "datePickerButton()?.selected() ? \"\" : null", "attr.aria-selected": "datePickerButton()?.selected()", "attr.aria-disabled": "datePickerButton()?.disabled()", "attr.data-disabled": "datePickerButton()?.disabled() ? \"\" : null", "attr.aria-labelledby": "labelId()" } }, queries: [{ propertyName: "datePickerButton", first: true, predicate: NgpDatePickerDateButtonToken, descendants: true, isSignal: true }], exportAs: ["ngpDatePickerCell"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerCell, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerCell]',
                    exportAs: 'ngpDatePickerCell',
                    host: {
                        role: 'gridcell',
                        '[attr.data-selected]': 'datePickerButton()?.selected() ? "" : null',
                        '[attr.aria-selected]': 'datePickerButton()?.selected()',
                        '[attr.aria-disabled]': 'datePickerButton()?.disabled()',
                        '[attr.data-disabled]': 'datePickerButton()?.disabled() ? "" : null',
                        '[attr.aria-labelledby]': 'labelId()',
                    },
                }]
        }] });

/**
 * A button that represents a date in the date picker grid.
 */
class NgpDatePickerDateButton {
    constructor() {
        /**
         * Access the element ref.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access the focus monitor.
         */
        this.focusMonitor = inject(FocusMonitor);
        /**
         * Access the date picker state.
         */
        this.state = injectDateControllerState();
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * The date this cell represents.
         */
        this.date = injectDatePickerCellDate();
        /**
         * Determine if this is the focused date.
         */
        this.focused = computed(() => this.dateAdapter.isSameDay(this.date, this.state().focusedDate()));
        /**
         * Determine if this is the selected date.
         */
        this.selected = computed(() => this.state().isSelected(this.date));
        /**
         * Determine if this is the start date of the range.
         */
        this.start = computed(() => this.state().isStartOfRange(this.date));
        /**
         * Determine if this is the end date of the range.
         */
        this.end = computed(() => this.state().isEndOfRange(this.date));
        /**
         * Determine if this is between the start and end dates of the range.
         */
        this.betweenRange = computed(() => this.state().isBetweenRange(this.date));
        /**
         * Determine if this date is outside the current month.
         */
        this.outside = computed(() => !this.dateAdapter.isSameMonth(this.date, this.state().focusedDate()));
        /**
         * Determine if this date is today.
         */
        this.today = computed(() => this.dateAdapter.isSameDay(this.date, this.dateAdapter.now()));
        /**
         * Determine if this date is disabled.
         * @internal
         */
        this.disabled = computed(() => {
            const min = this.state().min();
            const max = this.state().max();
            if (this.state().disabled() || this.state().dateDisabled()(this.date)) {
                return true;
            }
            if (min && this.dateAdapter.compare(this.dateAdapter.startOfDay(this.date), min) < 0) {
                return true;
            }
            if (max && this.dateAdapter.compare(this.dateAdapter.startOfDay(this.date), max) > 0) {
                return true;
            }
            return false;
        });
        /**
         * Determine if the element is a button.
         */
        this.isButton = this.elementRef.nativeElement.tagName === 'BUTTON';
        this.state().registerButton(this);
        setupButton({ disabled: this.disabled });
    }
    ngOnDestroy() {
        this.state().unregisterButton(this);
    }
    /**
     * When the button is clicked, select the date.
     */
    select(event) {
        // if the button is disabled, do nothing.
        if (this.disabled()) {
            return;
        }
        // because this may not be a button, we should stop the event from firing twice due to
        // us listening to both the click and the keydown.enter event.
        if (event) {
            event.preventDefault();
            event.stopPropagation();
        }
        this.state().select(this.date);
        this.state().setFocusedDate(this.date, 'mouse', 'forward');
    }
    /**
     * Focus if this is the current focused date.
     * @internal
     */
    focus() {
        if (this.dateAdapter.isSameDay(this.date, this.state().focusedDate())) {
            this.focusMonitor.focusVia(this.elementRef, 'keyboard');
        }
    }
    /**
     * Focus the previous cell.
     */
    focusPrevious(event) {
        event.preventDefault();
        event.stopPropagation();
        // in rtl, the arrow keys are reversed.
        if (this.getDirection() === 'rtl') {
            this.focusDate(this.dateAdapter.add(this.state().focusedDate(), { days: 1 }), 'forward');
        }
        else {
            this.focusDate(this.dateAdapter.subtract(this.state().focusedDate(), { days: 1 }), 'backward');
        }
    }
    /**
     * Focus the next cell.
     */
    focusNext(event) {
        event.preventDefault();
        event.stopPropagation();
        // in rtl, the arrow keys are reversed.
        if (this.getDirection() === 'rtl') {
            this.focusDate(this.dateAdapter.subtract(this.state().focusedDate(), { days: 1 }), 'backward');
        }
        else {
            this.focusDate(this.dateAdapter.add(this.state().focusedDate(), { days: 1 }), 'forward');
        }
    }
    /**
     * Focus the above cell.
     */
    focusAbove(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.subtract(this.state().focusedDate(), { days: 7 }), 'backward');
    }
    /**
     * Focus the below cell.
     */
    focusBelow(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.add(this.state().focusedDate(), { days: 7 }), 'forward');
    }
    /**
     * Focus the first date of the month.
     */
    focusFirst(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.startOfMonth(this.state().focusedDate()), 'forward');
    }
    /**
     * Focus the last date of the month.
     */
    focusLast(event) {
        event.preventDefault();
        event.stopPropagation();
        this.focusDate(this.dateAdapter.endOfMonth(this.state().focusedDate()), 'backward');
    }
    /**
     * Focus the same date in the previous month.
     */
    focusPreviousMonth(event) {
        event.preventDefault();
        event.stopPropagation();
        const date = this.dateAdapter.getDate(this.state().focusedDate());
        let previousMonthTarget = this.dateAdapter.startOfMonth(this.state().focusedDate());
        previousMonthTarget = this.dateAdapter.subtract(previousMonthTarget, { months: 1 });
        const lastDay = this.dateAdapter.endOfMonth(previousMonthTarget);
        // if we are on a date that does not exist in the previous month, we should focus the last day of the month.
        if (date > this.dateAdapter.getDate(lastDay)) {
            this.focusDate(lastDay, 'forward');
            return;
        }
        else {
            this.focusDate(this.dateAdapter.set(previousMonthTarget, { day: date }), 'forward');
        }
    }
    /**
     * Focus the same date in the next month.
     */
    focusNextMonth(event) {
        event.preventDefault();
        event.stopPropagation();
        const date = this.dateAdapter.getDate(this.state().focusedDate());
        let nextMonthTarget = this.dateAdapter.startOfMonth(this.state().focusedDate());
        nextMonthTarget = this.dateAdapter.add(nextMonthTarget, { months: 1 });
        const lastDay = this.dateAdapter.endOfMonth(nextMonthTarget);
        // if we are on a date that does not exist in the next month, we should focus the last day of the month.
        if (date > this.dateAdapter.getDate(lastDay)) {
            this.focusDate(lastDay, 'backward');
            return;
        }
        else {
            this.focusDate(this.dateAdapter.set(nextMonthTarget, { day: date }), 'backward');
        }
    }
    focusDate(date, direction) {
        this.state().setFocusedDate(date, 'keyboard', direction);
    }
    /**
     * Get the direction of the element.
     */
    getDirection() {
        return getComputedStyle(this.elementRef.nativeElement).direction === 'rtl' ? 'rtl' : 'ltr';
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerDateButton, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpDatePickerDateButton, isStandalone: true, selector: "[ngpDatePickerDateButton]", host: { listeners: { "click": "select()", "keydown.enter": "select($event)", "keydown.space": "select($event)", "keydown.arrowLeft": "focusPrevious($event)", "keydown.arrowRight": "focusNext($event)", "keydown.arrowUp": "focusAbove($event)", "keydown.arrowDown": "focusBelow($event)", "keydown.home": "focusFirst($event)", "keydown.end": "focusLast($event)", "keydown.pageUp": "focusPreviousMonth($event)", "keydown.pageDown": "focusNextMonth($event)" }, properties: { "attr.role": "!isButton ? \"button\" : null", "attr.tabindex": "focused() ? 0 : -1", "attr.data-selected": "selected() ? \"\" : null", "attr.aria-disabled": "disabled()", "attr.data-outside-month": "outside() ? \"\" : null", "attr.data-today": "today() ? \"\" : null", "attr.data-range-start": "start() ? \"\" : null", "attr.data-range-end": "end() ? \"\" : null", "attr.data-range-between": "betweenRange() ? \"\" : null" } }, providers: [{ provide: NgpDatePickerDateButtonToken, useExisting: NgpDatePickerDateButton }], exportAs: ["ngpDatePickerDateButton"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerDateButton, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerDateButton]',
                    exportAs: 'ngpDatePickerDateButton',
                    providers: [{ provide: NgpDatePickerDateButtonToken, useExisting: NgpDatePickerDateButton }],
                    host: {
                        '[attr.role]': '!isButton ? "button" : null',
                        '[attr.tabindex]': 'focused() ? 0 : -1',
                        '[attr.data-selected]': 'selected() ? "" : null',
                        '[attr.aria-disabled]': 'disabled()',
                        '[attr.data-outside-month]': 'outside() ? "" : null',
                        '[attr.data-today]': 'today() ? "" : null',
                        '[attr.data-range-start]': 'start() ? "" : null',
                        '[attr.data-range-end]': 'end() ? "" : null',
                        '[attr.data-range-between]': 'betweenRange() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { select: [{
                type: HostListener,
                args: ['click']
            }, {
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }], focusPrevious: [{
                type: HostListener,
                args: ['keydown.arrowLeft', ['$event']]
            }], focusNext: [{
                type: HostListener,
                args: ['keydown.arrowRight', ['$event']]
            }], focusAbove: [{
                type: HostListener,
                args: ['keydown.arrowUp', ['$event']]
            }], focusBelow: [{
                type: HostListener,
                args: ['keydown.arrowDown', ['$event']]
            }], focusFirst: [{
                type: HostListener,
                args: ['keydown.home', ['$event']]
            }], focusLast: [{
                type: HostListener,
                args: ['keydown.end', ['$event']]
            }], focusPreviousMonth: [{
                type: HostListener,
                args: ['keydown.pageUp', ['$event']]
            }], focusNextMonth: [{
                type: HostListener,
                args: ['keydown.pageDown', ['$event']]
            }] } });

/**
 * The grid that contains the days of the month.
 */
class NgpDatePickerGrid {
    constructor() {
        /**
         * Access the date picker state.
         */
        this.state = injectDateControllerState();
        /**
         * Determine the id for the label.
         */
        this.labelId = computed(() => this.state().label()?.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerGrid, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpDatePickerGrid, isStandalone: true, selector: "[ngpDatePickerGrid]", host: { attributes: { "role": "grid" }, properties: { "attr.aria-labelledby": "labelId()", "attr.data-disabled": "state().disabled() ? \"\" : null" } }, exportAs: ["ngpDatePickerGrid"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerGrid, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerGrid]',
                    exportAs: 'ngpDatePickerGrid',
                    host: {
                        role: 'grid',
                        '[attr.aria-labelledby]': 'labelId()',
                        '[attr.data-disabled]': 'state().disabled() ? "" : null',
                    },
                }]
        }] });

const NgpDatePickerLabelToken = new InjectionToken('NgpDatePickerLabelToken');
/**
 * Inject the DatePickerLabel directive instance
 */
function injectDatePickerLabel() {
    return inject(NgpDatePickerLabelToken);
}

/**
 * The label that displays the current month and year typically in the header of the date picker. This will be announced by screen readers when the date changes.
 */
class NgpDatePickerLabel {
    constructor() {
        /**
         * Access the date picker.
         */
        this.state = injectDateControllerState();
        /**
         * Define a unique id for the label.
         */
        this.id = input(uniqueId('ngp-date-picker-label'));
        /**
         * Define the aria live attribute.
         */
        this.ariaLive = input('polite', {
            alias: 'aria-live',
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerLabel, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpDatePickerLabel, isStandalone: true, selector: "[ngpDatePickerLabel]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, ariaLive: { classPropertyName: "ariaLive", publicName: "aria-live", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "id": "id()", "attr.aria-live": "ariaLive()", "attr.data-disabled": "state().disabled() ? \"\" : null" } }, providers: [{ provide: NgpDatePickerLabelToken, useExisting: NgpDatePickerLabel }], exportAs: ["ngpDatePickerLabel"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerLabel, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerLabel]',
                    exportAs: 'ngpDatePickerLabel',
                    providers: [{ provide: NgpDatePickerLabelToken, useExisting: NgpDatePickerLabel }],
                    host: {
                        '[id]': 'id()',
                        '[attr.aria-live]': 'ariaLive()',
                        '[attr.data-disabled]': 'state().disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * A button that navigates to the next month.
 */
class NgpDatePickerNextMonth {
    constructor() {
        /**
         * Access the element ref.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker state.
         */
        this.state = injectDateControllerState();
        /**
         * Determine if this is a button element
         */
        this.isButton = this.elementRef.nativeElement.tagName.toLowerCase() === 'button';
        /**
         * Determine if the next month is disabled.
         * @internal
         */
        this.disabled = computed(() => {
            if (this.state().disabled()) {
                return true;
            }
            const maxDate = this.state().max();
            const lastDay = this.dateAdapter.set(this.dateAdapter.endOfMonth(this.state().focusedDate()), {
                hour: 23,
                minute: 59,
                second: 59,
                millisecond: 999,
            });
            // if there is a max date and it is equal to or before the last day of the month, disable it.
            if (maxDate && this.dateAdapter.compare(maxDate, lastDay) <= 0) {
                return true;
            }
            return false;
        });
        setupButton({ disabled: this.disabled });
    }
    /**
     * Navigate to the next month.
     */
    navigateToNextMonth() {
        if (this.disabled()) {
            return;
        }
        // move focus to the first day of the next month.
        let date = this.state().focusedDate();
        date = this.dateAdapter.add(date, { months: 1 });
        date = this.dateAdapter.set(date, {
            day: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0,
        });
        this.state().setFocusedDate(date, 'mouse', 'forward');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerNextMonth, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpDatePickerNextMonth, isStandalone: true, selector: "[ngpDatePickerNextMonth]", host: { listeners: { "click": "navigateToNextMonth()" }, properties: { "attr.aria-disabled": "disabled()", "attr.type": "isButton ? \"button\" : null" } }, exportAs: ["ngpDatePickerNextMonth"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerNextMonth, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerNextMonth]',
                    exportAs: 'ngpDatePickerNextMonth',
                    host: {
                        '[attr.aria-disabled]': 'disabled()',
                        '[attr.type]': 'isButton ? "button" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { navigateToNextMonth: [{
                type: HostListener,
                args: ['click']
            }] } });

/**
 * A button that navigates to the previous month.
 */
class NgpDatePickerPreviousMonth {
    constructor() {
        /**
         * Access the element ref.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker state.
         */
        this.state = injectDateControllerState();
        /**
         * Determine if this is a button element
         */
        this.isButton = this.elementRef.nativeElement.tagName.toLowerCase() === 'button';
        /**
         * Determine if the next month is disabled.
         * @internal
         */
        this.disabled = computed(() => {
            if (this.state().disabled()) {
                return true;
            }
            const minDate = this.state().min();
            // if the next month is out of bounds, disable it.
            const firstDay = this.dateAdapter.set(this.dateAdapter.startOfMonth(this.state().focusedDate()), {
                hour: 0,
                minute: 0,
                second: 0,
                millisecond: 0,
            });
            // if there is a min date and it is equal to or after the first day of the month, disable it.
            if (minDate && this.dateAdapter.compare(minDate, firstDay) >= 0) {
                return true;
            }
            return false;
        });
        setupButton({ disabled: this.disabled });
    }
    /**
     * Navigate to the previous month.
     */
    navigateToPreviouMonth() {
        if (this.disabled()) {
            return;
        }
        // move focus to the first day of the previous month.
        let date = this.state().focusedDate();
        date = this.dateAdapter.subtract(date, { months: 1 });
        date = this.dateAdapter.set(date, {
            day: 1,
            hour: 0,
            minute: 0,
            second: 0,
            millisecond: 0,
        });
        this.state().setFocusedDate(date, 'mouse', 'backward');
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerPreviousMonth, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpDatePickerPreviousMonth, isStandalone: true, selector: "[ngpDatePickerPreviousMonth]", host: { listeners: { "click": "navigateToPreviouMonth()" }, properties: { "attr.aria-disabled": "disabled()", "attr.type": "isButton ? \"button\" : null" } }, exportAs: ["ngpDatePickerPreviousMonth"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerPreviousMonth, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerPreviousMonth]',
                    exportAs: 'ngpDatePickerPreviousMonth',
                    host: {
                        '[attr.aria-disabled]': 'disabled()',
                        '[attr.type]': 'isButton ? "button" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { navigateToPreviouMonth: [{
                type: HostListener,
                args: ['click']
            }] } });

/**
 * The number of days in a week.
 * @internal
 */
const DAYS_PER_WEEK = 7;
/**
 * A structural directive that renders a row of weekdays in the date picker grid.
 */
class NgpDatePickerRowRender {
    constructor() {
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker.
         */
        this.state = injectDateControllerState();
        /**
         * Access the template ref for the cell.
         */
        this.templateRef = inject(TemplateRef);
        /**
         * Access the view container ref.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Get all the days to display, this is the days of the current month
         * and the days of the previous and next month to fill the grid.
         */
        this.days = computed(() => {
            const month = this.state().focusedDate();
            const days = [];
            // Get the first and last day of the month.
            let firstDay = this.dateAdapter.startOfMonth(month);
            let lastDay = this.dateAdapter.endOfMonth(month);
            // calculate the offset of the first day of the week.
            const firstDayOfWeekOffset = this.getFirstDayOfWeekOffset(firstDay);
            const lastDayOfWeekOffset = this.getLastDayOfWeekOffset(lastDay);
            // find the first and last day of visible in the grid.
            firstDay = this.dateAdapter.subtract(firstDay, {
                days: firstDayOfWeekOffset,
            });
            lastDay = this.dateAdapter.add(lastDay, {
                days: lastDayOfWeekOffset,
            });
            // collect all the days to display.
            while (firstDay <= lastDay) {
                days.push(firstDay);
                firstDay = this.dateAdapter.add(firstDay, { days: 1 });
            }
            return days;
        });
        // get the weeks to display.
        this.weeks = computed(() => {
            const days = this.days();
            const weeks = [];
            for (let i = 0; i < days.length; i += 7) {
                weeks.push(days.slice(i, i + 7));
            }
            return weeks;
        });
        /**
         * Store the embedded view refs of each rendered row.
         */
        this.viewRefs = [];
        /**
         * Store the previously rendered month.
         */
        this.previousMonth = null;
        // Wait for the inputs of the containing picker to be initialized.
        explicitEffect([this.state().focusedDate, this.state().firstDayOfWeek], () => this.renderRows());
    }
    ngOnDestroy() {
        this.destroyRows();
    }
    /**
     * Render the row.
     */
    renderRows() {
        // If the focused date has not changed, do not re-render.
        if (this.previousMonth &&
            this.dateAdapter.isSameMonth(this.previousMonth, this.state().focusedDate())) {
            return;
        }
        // Store the current focused month.
        this.previousMonth = this.state().focusedDate();
        const weeks = this.weeks();
        // clear the view container.
        this.destroyRows();
        // render the weeks.
        for (const week of weeks) {
            const viewRef = this.viewContainerRef.createEmbeddedView(this.templateRef, null, {
                injector: Injector.create({
                    parent: this.viewContainerRef.injector,
                    providers: [{ provide: NgpDatePickerWeekToken, useValue: week }],
                }),
            });
            this.viewRefs.push(viewRef);
        }
    }
    /**
     * Destroy the row.
     */
    destroyRows() {
        for (const viewRef of this.viewRefs) {
            viewRef.destroy();
        }
        this.viewRefs.length = 0;
    }
    /**
     * Get the offset of the first day of the week.
     * @param firstCalendarDay The first day of the calendar without the offset.
     * @returns The offset of the first day of the week.
     *
     * @internal
     */
    getFirstDayOfWeekOffset(firstCalendarDay) {
        return ((DAYS_PER_WEEK + this.dateAdapter.getDay(firstCalendarDay) - this.state().firstDayOfWeek()) %
            DAYS_PER_WEEK);
    }
    /**
     * Get the offset of the last day of the week.
     * @param lastCalendarDay The last day of the calendar without the offset.
     * @returns The offset of the last day of the week.
     *
     * @internal
     */
    getLastDayOfWeekOffset(lastCalendarDay) {
        const lastDay = this.dateAdapter.getDay(lastCalendarDay);
        const firstDay = this.state().firstDayOfWeek();
        return (DAYS_PER_WEEK + firstDay + DAYS_PER_WEEK - 1 - lastDay) % DAYS_PER_WEEK;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerRowRender, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpDatePickerRowRender, isStandalone: true, selector: "[ngpDatePickerRowRender]", providers: [{ provide: NgpDatePickerRowRenderToken, useExisting: NgpDatePickerRowRender }], exportAs: ["ngpDatePickerRowRender"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePickerRowRender, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePickerRowRender]',
                    exportAs: 'ngpDatePickerRowRender',
                    providers: [{ provide: NgpDatePickerRowRenderToken, useExisting: NgpDatePickerRowRender }],
                }]
        }], ctorParameters: () => [] });

/**
 * Transform the first day of the week input value to a number (0-7) for the start of the week in
 * the calendar.
 * @param firstDayOfWeek The first day of the week input value (number).
 * @returns The first day of the week number.
 */
function transformToFirstDayOfWeekNumber(firstDayOfWeek) {
    if (!firstDayOfWeek) {
        return 7;
    }
    return numberAttribute(firstDayOfWeek);
}

/**
 * The outermost container for the date picker.
 */
class NgpDatePicker {
    constructor() {
        /**
         * Access the date adapter.
         */
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date picker config.
         */
        this.config = injectDatePickerConfig();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * The minimum date that can be selected.
         */
        this.min = input(undefined, {
            alias: 'ngpDatePickerMin',
        });
        /**
         * The maximum date that can be selected.
         */
        this.max = input(undefined, {
            alias: 'ngpDatePickerMax',
        });
        /**
         * Determine if the date picker is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpDatePickerDisabled',
            transform: booleanAttribute,
        });
        /**
         * A function that is called to determine if a specific date should be disabled.
         */
        this.dateDisabled = input(() => false, {
            alias: 'ngpDatePickerDateDisabled',
        });
        /**
         * Sets which day starts the week in the calendar.
         * Accepts 0-7 where 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday.
         * Defaults to NgpDatePickerConfig.firstDayOfWeek (default 7 if not overridden).
         * Note: Update calendar header column order when changing from Sunday start.
         * @default 7 (Sunday)
         */
        this.firstDayOfWeek = input(transformToFirstDayOfWeekNumber(this.config.firstDayOfWeek), {
            alias: 'ngpDatePickerFirstDayOfWeek',
            transform: transformToFirstDayOfWeekNumber,
        });
        /**
         * The selected value.
         */
        this.date = input(undefined, {
            alias: 'ngpDatePickerDate',
        });
        /**
         * Emit when the date changes.
         */
        this.dateChange = output({
            alias: 'ngpDatePickerDateChange',
        });
        /**
         * The focused value.
         */
        this.focusedDate = input(this.dateAdapter.now(), {
            alias: 'ngpDatePickerFocusedDate',
        });
        /**
         * Emit when the focused date changes.
         */
        this.focusedDateChange = output({
            alias: 'ngpDatePickerFocusedDateChange',
        });
        /**
         * Detect the label element.
         * @internal
         */
        this.label = contentChild(NgpDatePickerLabelToken, { descendants: true });
        /**
         * Access all the date picker buttons
         */
        this.buttons = signal([]);
        /**
         * The date picker state.
         */
        this.state = datePickerState(this);
    }
    /**
     * Set the focused date.
     * @param date The date to focus.
     * @internal
     */
    setFocusedDate(date, origin = 'mouse', direction) {
        if (this.state.disabled()) {
            return;
        }
        const min = this.state.min();
        const max = this.state.max();
        if (min && this.dateAdapter.isBefore(date, min)) {
            date = min;
        }
        if (max && this.dateAdapter.isAfter(date, max)) {
            date = max;
        }
        // if the date is disabled, find the next available date in the specified direction.
        if (this.state.dateDisabled()(date)) {
            let nextDate = this.dateAdapter.add(date, { days: direction === 'forward' ? 1 : -1 });
            while (this.state.dateDisabled()(nextDate) ||
                (min && this.dateAdapter.isBefore(nextDate, min)) ||
                (max && this.dateAdapter.isAfter(nextDate, max))) {
                nextDate = this.dateAdapter.add(nextDate, { days: direction === 'forward' ? 1 : -1 });
            }
            date = nextDate;
        }
        this.state.focusedDate.set(date);
        this.focusedDateChange.emit(date);
        if (origin === 'keyboard') {
            afterNextRender({
                write: () => this.buttons().forEach(button => button.focus()),
            }, {
                injector: this.injector,
            });
        }
    }
    /**
     * Register a date button.
     * @param button The date button to register.
     * @internal
     */
    registerButton(button) {
        this.buttons.update(buttons => [...buttons, button]);
    }
    /**
     * Unregister a date button.
     * @param button The date button to unregister.
     * @internal
     */
    unregisterButton(button) {
        this.buttons.update(buttons => buttons.filter(b => b !== button));
    }
    /**
     * Select a date.
     * @param date The date to select.
     * @internal
     */
    select(date) {
        this.state.date.set(date);
        this.dateChange.emit(date);
    }
    /**
     * Determine if a date is selected.
     * @param date The date to check.
     * @returns True if the date is selected, false otherwise.
     * @internal
     */
    isSelected(date) {
        const selected = this.state.date();
        if (!selected) {
            return false;
        }
        return this.dateAdapter.isSameDay(date, selected);
    }
    /**
     * Determine if a date is the start of a range. In a date picker, this is always false.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isStartOfRange(_) {
        return false;
    }
    /**
     * Determine if a date is the end of a range. In a date picker, this is always false.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isEndOfRange(_) {
        return false;
    }
    /**
     * Determine if a date is between the start and end dates. In a date picker, this is always false.
     * @param date The date to check.
     * @returns True if the date is between the start and end dates, false otherwise.
     * @internal
     */
    isBetweenRange(_) {
        return false;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePicker, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.11", type: NgpDatePicker, isStandalone: true, selector: "[ngpDatePicker]", inputs: { min: { classPropertyName: "min", publicName: "ngpDatePickerMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpDatePickerMax", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpDatePickerDisabled", isSignal: true, isRequired: false, transformFunction: null }, dateDisabled: { classPropertyName: "dateDisabled", publicName: "ngpDatePickerDateDisabled", isSignal: true, isRequired: false, transformFunction: null }, firstDayOfWeek: { classPropertyName: "firstDayOfWeek", publicName: "ngpDatePickerFirstDayOfWeek", isSignal: true, isRequired: false, transformFunction: null }, date: { classPropertyName: "date", publicName: "ngpDatePickerDate", isSignal: true, isRequired: false, transformFunction: null }, focusedDate: { classPropertyName: "focusedDate", publicName: "ngpDatePickerFocusedDate", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { dateChange: "ngpDatePickerDateChange", focusedDateChange: "ngpDatePickerFocusedDateChange" }, host: { properties: { "attr.data-disabled": "state.disabled() ? \"\" : null" } }, providers: [provideDatePickerState()], queries: [{ propertyName: "label", first: true, predicate: NgpDatePickerLabelToken, descendants: true, isSignal: true }], exportAs: ["ngpDatePicker"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDatePicker, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDatePicker]',
                    exportAs: 'ngpDatePicker',
                    providers: [provideDatePickerState()],
                    host: {
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                    },
                }]
        }] });

class NgpDateRangePicker {
    constructor() {
        this.dateAdapter = injectDateAdapter();
        /**
         * Access the date range picker config.
         */
        this.config = injectDatePickerConfig();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * The minimum date that can be selected.
         */
        this.min = input(undefined, {
            alias: 'ngpDateRangePickerMin',
        });
        /**
         * The maximum date that can be selected.
         */
        this.max = input(undefined, {
            alias: 'ngpDateRangePickerMax',
        });
        /**
         * Determine if the date picker is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpDateRangePickerDisabled',
            transform: booleanAttribute,
        });
        /**
         * A function that is called to determine if a specific date should be disabled.
         */
        this.dateDisabled = input(() => false, {
            alias: 'ngpDateRangePickerDateDisabled',
        });
        /**
         * Sets which day starts the week in the calendar.
         * Accepts 0-7 where 1=Monday, 2=Tuesday, 3=Wednesday, 4=Thursday, 5=Friday, 6=Saturday, 7=Sunday.
         * Defaults to NgpDatePickerConfig.firstDayOfWeek (default 7 if not overridden).
         * Note: Update calendar header column order when changing from Sunday start.
         * @default 7 (Sunday)
         */
        this.firstDayOfWeek = input(transformToFirstDayOfWeekNumber(this.config.firstDayOfWeek), {
            alias: 'ngpDateRangePickerFirstDayOfWeek',
            transform: transformToFirstDayOfWeekNumber,
        });
        /**
         * The selected start date
         */
        this.startDate = input(undefined, {
            alias: 'ngpDateRangePickerStartDate',
        });
        /**
         * Emit when the date changes.
         */
        this.startDateChange = output({
            alias: 'ngpDateRangePickerStartDateChange',
        });
        /**
         * The selected end date
         */
        this.endDate = input(undefined, {
            alias: 'ngpDateRangePickerEndDate',
        });
        /**
         * Emit when the end date changes.
         */
        this.endDateChange = output({
            alias: 'ngpDateRangePickerEndDateChange',
        });
        /**
         * The focused value.
         */
        this.focusedDate = input(this.dateAdapter.now(), {
            alias: 'ngpDateRangePickerFocusedDate',
        });
        /**
         * Emit when the focused date changes.
         */
        this.focusedDateChange = output({
            alias: 'ngpDateRangePickerFocusedDateChange',
        });
        /**
         * Detect the label element.
         * @internal
         */
        this.label = contentChild(NgpDatePickerLabelToken, { descendants: true });
        /**
         * Access all the date picker buttons
         */
        this.buttons = signal([]);
        /**
         * The date range picker state.
         */
        this.state = dateRangePickerState(this);
    }
    /**
     * Set the focused date.
     * @param date The date to focus.
     * @internal
     */
    setFocusedDate(date, origin = 'mouse', direction) {
        if (this.state.disabled()) {
            return;
        }
        const min = this.state.min();
        const max = this.state.max();
        if (min && this.dateAdapter.isBefore(date, min)) {
            date = min;
        }
        if (max && this.dateAdapter.isAfter(date, max)) {
            date = max;
        }
        // if the date is disabled, find the next available date in the specified direction.
        if (this.state.dateDisabled()(date)) {
            let nextDate = this.dateAdapter.add(date, { days: direction === 'forward' ? 1 : -1 });
            while (this.state.dateDisabled()(nextDate) ||
                (min && this.dateAdapter.isBefore(nextDate, min)) ||
                (max && this.dateAdapter.isAfter(nextDate, max))) {
                nextDate = this.dateAdapter.add(nextDate, { days: direction === 'forward' ? 1 : -1 });
            }
            date = nextDate;
        }
        this.state.focusedDate.set(date);
        this.focusedDateChange.emit(date);
        if (origin === 'keyboard') {
            afterNextRender({
                write: () => this.buttons().forEach(button => button.focus()),
            }, {
                injector: this.injector,
            });
        }
    }
    /**
     * Register a date button.
     * @param button The date button to register.
     * @internal
     */
    registerButton(button) {
        this.buttons.update(buttons => [...buttons, button]);
    }
    /**
     * Unregister a date button.
     * @param button The date button to unregister.
     * @internal
     */
    unregisterButton(button) {
        this.buttons.update(buttons => buttons.filter(b => b !== button));
    }
    /**
     * Select a date.
     * @param date The date to select.
     * @internal
     */
    /**
     * Handles the selection of a date within the date range picker.
     *
     * Selection logic:
     * - If neither a start date nor an end date is selected:
     *   - Sets the selected date as the start date.
     * - If a start date is selected but no end date:
     *   - If the selected date is after the start date, sets it as the end date.
     *   - If the selected date is before the start date, sets the selected date as the start date
     *     and the previous start date as the end date.
     *   - If the selected date is the same as the start date, sets the selected date as the end date
     *     to select a single date.
     * - If both start and end dates are already selected:
     *   - Resets the selection, setting the selected date as the new start date and clearing the end date.
     *
     * @param date The date to select.
     */
    select(date) {
        const start = this.state.startDate();
        const end = this.state.endDate();
        if (!start && !end) {
            this.state.startDate.set(date);
            this.startDateChange.emit(date);
            return;
        }
        if (start && !end) {
            if (this.dateAdapter.isAfter(date, start)) {
                this.state.endDate.set(date);
                this.endDateChange.emit(date);
            }
            else if (this.dateAdapter.isBefore(date, start)) {
                this.state.startDate.set(date);
                this.state.endDate.set(start);
                this.startDateChange.emit(date);
                this.endDateChange.emit(start);
            }
            else if (this.dateAdapter.isSameDay(date, start)) {
                this.state.endDate.set(date);
                this.endDateChange.emit(date);
            }
            return;
        }
        // If both start and end are selected, reset selection
        this.state.startDate.set(date);
        this.startDateChange.emit(date);
        this.state.endDate.set(undefined);
        this.endDateChange.emit(undefined);
    }
    /**
     * Determine if a date is selected. A date is selected if it is either the start date or the end date.
     * @param date The date to check.
     * @returns True if the date is selected, false otherwise.
     * @internal
     */
    isSelected(date) {
        const start = this.state.startDate();
        const end = this.state.endDate();
        if (!start && !end) {
            return false;
        }
        const isStartSelected = start ? this.dateAdapter.isSameDay(date, start) : false;
        const isEndSelected = end ? this.dateAdapter.isSameDay(date, end) : false;
        return isStartSelected || isEndSelected;
    }
    /**
     * Determine if a date is the start of a range.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isStartOfRange(date) {
        const start = this.state.startDate();
        return start ? this.dateAdapter.isSameDay(date, start) : false;
    }
    /**
     * Determine if a date is the end of a range.
     * @param date The date to check.
     * @returns Always false.
     * @internal
     */
    isEndOfRange(date) {
        const end = this.state.endDate();
        return end ? this.dateAdapter.isSameDay(date, end) : false;
    }
    /**
     * Determine if a date is between the start and end dates.
     * @param date The date to check.
     * @returns True if the date is between the start and end dates, false otherwise.
     * @internal
     */
    isBetweenRange(date) {
        const start = this.state.startDate();
        const end = this.state.endDate();
        if (!start || !end) {
            return false;
        }
        return this.dateAdapter.isAfter(date, start) && this.dateAdapter.isBefore(date, end);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDateRangePicker, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.11", type: NgpDateRangePicker, isStandalone: true, selector: "[ngpDateRangePicker]", inputs: { min: { classPropertyName: "min", publicName: "ngpDateRangePickerMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpDateRangePickerMax", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpDateRangePickerDisabled", isSignal: true, isRequired: false, transformFunction: null }, dateDisabled: { classPropertyName: "dateDisabled", publicName: "ngpDateRangePickerDateDisabled", isSignal: true, isRequired: false, transformFunction: null }, firstDayOfWeek: { classPropertyName: "firstDayOfWeek", publicName: "ngpDateRangePickerFirstDayOfWeek", isSignal: true, isRequired: false, transformFunction: null }, startDate: { classPropertyName: "startDate", publicName: "ngpDateRangePickerStartDate", isSignal: true, isRequired: false, transformFunction: null }, endDate: { classPropertyName: "endDate", publicName: "ngpDateRangePickerEndDate", isSignal: true, isRequired: false, transformFunction: null }, focusedDate: { classPropertyName: "focusedDate", publicName: "ngpDateRangePickerFocusedDate", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { startDateChange: "ngpDateRangePickerStartDateChange", endDateChange: "ngpDateRangePickerEndDateChange", focusedDateChange: "ngpDateRangePickerFocusedDateChange" }, host: { properties: { "attr.data-disabled": "state.disabled() ? \"\" : null" } }, providers: [provideDateRangePickerState()], queries: [{ propertyName: "label", first: true, predicate: NgpDatePickerLabelToken, descendants: true, isSignal: true }], exportAs: ["ngpDateRangePicker"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDateRangePicker, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDateRangePicker]',
                    exportAs: 'ngpDateRangePicker',
                    providers: [provideDateRangePickerState()],
                    host: {
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpDatePicker, NgpDatePickerCell, NgpDatePickerCellRender, NgpDatePickerCellRenderToken, NgpDatePickerDateButton, NgpDatePickerDateButtonToken, NgpDatePickerGrid, NgpDatePickerLabel, NgpDatePickerLabelToken, NgpDatePickerNextMonth, NgpDatePickerPreviousMonth, NgpDatePickerRowRender, NgpDatePickerRowRenderToken, NgpDateRangePicker, injectDatePickerCellDate, injectDatePickerCellRender, injectDatePickerConfig, injectDatePickerDateButton, injectDatePickerLabel, injectDatePickerRowRender, injectDatePickerState, injectDatePickerWeek, injectDateRangePickerState, provideDatePickerConfig, provideDatePickerState, provideDateRangePickerState, transformToFirstDayOfWeekNumber };
//# sourceMappingURL=ng-primitives-date-picker.mjs.map
