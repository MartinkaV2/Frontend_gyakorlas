import { FocusOrigin } from '@angular/cdk/a11y';
import { BooleanInput, NumberInput } from '@angular/cdk/coercion';
import { OnDestroy } from '@angular/core';
import { NgpOverlay, NgpOverlayContent, NgpOffset, NgpOffsetInput } from 'ng-primitives/portal';
import * as i0 from "@angular/core";
/**
 * Apply the `ngpPopoverTrigger` directive to an element that triggers the popover to show.
 */
export declare class NgpPopoverTrigger<T = null> implements OnDestroy {
    /**
     * Access the trigger element
     */
    private readonly trigger;
    /**
     * Access the injector.
     */
    private readonly injector;
    /**
     * Access the view container reference.
     */
    private readonly viewContainerRef;
    /**
     * Access the global popover configuration.
     */
    private readonly config;
    /**
     * Access the popover template ref.
     */
    readonly popover: import("@angular/core").InputSignal<NgpOverlayContent<T> | undefined>;
    /**
     * Define if the trigger should be disabled.
     * @default false
     */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Define the placement of the popover relative to the trigger.
     * @default 'top'
     */
    readonly placement: import("@angular/core").InputSignal<NgpPopoverPlacement>;
    /**
     * Define the offset of the popover relative to the trigger.
     * Can be a number (applies to mainAxis) or an object with mainAxis, crossAxis, and alignmentAxis.
     * @default 0
     */
    readonly offset: import("@angular/core").InputSignalWithTransform<NgpOffset, NgpOffsetInput>;
    /**
     * Define the delay before the popover is displayed.
     * @default 0
     */
    readonly showDelay: import("@angular/core").InputSignalWithTransform<number, NumberInput>;
    /**
     * Define the delay before the popover is hidden.
     * @default 0
     */
    readonly hideDelay: import("@angular/core").InputSignalWithTransform<number, NumberInput>;
    /**
     * Define whether the popover should flip when there is not enough space for the popover.
     * @default true
     */
    readonly flip: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Define the container in which the popover should be attached.
     * @default document.body
     */
    readonly container: import("@angular/core").InputSignal<string | HTMLElement | null>;
    /**
     * Define whether the popover should close when clicking outside of it.
     * @default true
     */
    readonly closeOnOutsideClick: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Define whether the popover should close when the escape key is pressed.
     * @default true
     */
    readonly closeOnEscape: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Defines how the popover behaves when the window is scrolled.
     * @default 'reposition'
     */
    readonly scrollBehavior: import("@angular/core").InputSignal<"reposition" | "block">;
    /**
     * Provide context to the popover. This can be used to pass data to the popover content.
     */
    readonly context: import("@angular/core").InputSignal<T | undefined>;
    /**
     * Define an anchor element for positioning the popover.
     * If provided, the popover will be positioned relative to this element instead of the trigger.
     */
    readonly anchor: import("@angular/core").InputSignal<HTMLElement | null>;
    /**
     * The overlay that manages the popover
     * @internal
     */
    readonly overlay: import("@angular/core").WritableSignal<NgpOverlay<T> | null>;
    /**
     * The open state of the popover.
     * @internal
     */
    readonly open: import("@angular/core").Signal<boolean>;
    /**
     * Event emitted when the popover open state changes.
     */
    readonly openChange: import("@angular/core").OutputEmitterRef<boolean>;
    /**
     * The popover trigger state.
     */
    readonly state: import("ng-primitives/state").CreatedState<NgpPopoverTrigger<T>>;
    ngOnDestroy(): void;
    protected toggle(event: MouseEvent): void;
    /**
     * Show the popover.
     * @returns A promise that resolves when the popover has been shown
     */
    show(): Promise<void>;
    /**
     * @internal
     * Hide the popover.
     * @returns A promise that resolves when the popover has been hidden
     */
    hide(origin?: FocusOrigin): Promise<void>;
    /**
     * Create the overlay that will contain the popover
     */
    private createOverlay;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgpPopoverTrigger<any>, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgpPopoverTrigger<any>, "[ngpPopoverTrigger]", ["ngpPopoverTrigger"], { "popover": { "alias": "ngpPopoverTrigger"; "required": false; "isSignal": true; }; "disabled": { "alias": "ngpPopoverTriggerDisabled"; "required": false; "isSignal": true; }; "placement": { "alias": "ngpPopoverTriggerPlacement"; "required": false; "isSignal": true; }; "offset": { "alias": "ngpPopoverTriggerOffset"; "required": false; "isSignal": true; }; "showDelay": { "alias": "ngpPopoverTriggerShowDelay"; "required": false; "isSignal": true; }; "hideDelay": { "alias": "ngpPopoverTriggerHideDelay"; "required": false; "isSignal": true; }; "flip": { "alias": "ngpPopoverTriggerFlip"; "required": false; "isSignal": true; }; "container": { "alias": "ngpPopoverTriggerContainer"; "required": false; "isSignal": true; }; "closeOnOutsideClick": { "alias": "ngpPopoverTriggerCloseOnOutsideClick"; "required": false; "isSignal": true; }; "closeOnEscape": { "alias": "ngpPopoverTriggerCloseOnEscape"; "required": false; "isSignal": true; }; "scrollBehavior": { "alias": "ngpPopoverTriggerScrollBehavior"; "required": false; "isSignal": true; }; "context": { "alias": "ngpPopoverTriggerContext"; "required": false; "isSignal": true; }; "anchor": { "alias": "ngpPopoverTriggerAnchor"; "required": false; "isSignal": true; }; }, { "openChange": "ngpPopoverTriggerOpenChange"; }, never, never, true, never>;
}
export type NgpPopoverPlacement = 'top' | 'right' | 'bottom' | 'left' | 'top-start' | 'top-end' | 'right-start' | 'right-end' | 'bottom-start' | 'bottom-end' | 'left-start' | 'left-end';
