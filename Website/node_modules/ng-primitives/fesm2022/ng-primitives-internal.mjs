import * as i0 from '@angular/core';
import { inject, ElementRef, Injectable, Directive, effect, untracked, CSP_NONCE, PLATFORM_ID, signal, Injector, DestroyRef } from '@angular/core';
import { DOCUMENT, isPlatformBrowser, isPlatformServer } from '@angular/common';
import { isUndefined, safeTakeUntilDestroyed } from 'ng-primitives/utils';
import { Observable, merge } from 'rxjs';
import { map } from 'rxjs/operators';

/**
 * A simple utility function to inject an element reference with less boilerplate.
 * @returns The element reference.
 */
function injectElementRef() {
    return inject(ElementRef);
}

class NgpExitAnimationManager {
    constructor() {
        /** Store the instances of the exit animation directive. */
        this.instances = [];
    }
    /** Add an instance to the manager. */
    add(instance) {
        this.instances.push(instance);
    }
    /** Remove an instance from the manager. */
    remove(instance) {
        const index = this.instances.indexOf(instance);
        if (index !== -1) {
            this.instances.splice(index, 1);
        }
    }
    /** Exit all instances. */
    async exit() {
        await Promise.all(this.instances.map(instance => instance.exit()));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpExitAnimationManager, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpExitAnimationManager }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpExitAnimationManager, decorators: [{
            type: Injectable
        }] });
function provideExitAnimationManager() {
    return { provide: NgpExitAnimationManager, useClass: NgpExitAnimationManager };
}
function injectExitAnimationManager() {
    return inject(NgpExitAnimationManager);
}

class NgpExitAnimation {
    constructor() {
        /** The animation manager. */
        this.animationManager = injectExitAnimationManager();
        /** Access the element reference. */
        this.elementRef = injectElementRef();
        /** Exist animation reference. */
        this.ref = setupExitAnimation({ element: this.elementRef.nativeElement });
        this.animationManager.add(this);
    }
    ngOnDestroy() {
        this.animationManager.remove(this);
    }
    /** Mark the element as exiting. */
    async exit() {
        await this.ref.exit();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpExitAnimation, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpExitAnimation, isStandalone: true, selector: "[ngpExitAnimation]", exportAs: ["ngpExitAnimation"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpExitAnimation, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpExitAnimation]',
                    exportAs: 'ngpExitAnimation',
                }]
        }], ctorParameters: () => [] });
function setupExitAnimation({ element }) {
    let state = 'enter';
    function setState(newState) {
        state = newState;
        // remove all current animation state attributes
        element.removeAttribute('data-enter');
        element.removeAttribute('data-exit');
        // add the new animation state attribute
        if (state === 'enter') {
            element.setAttribute('data-enter', '');
        }
        else if (state === 'exit') {
            element.setAttribute('data-exit', '');
        }
    }
    // Set the initial state to 'enter'
    requestAnimationFrame(() => setState('enter'));
    return {
        exit: () => {
            return new Promise((resolve, reject) => {
                setState('exit');
                const animations = element.getAnimations();
                // Wait for the exit animations to finish
                if (animations.length > 0) {
                    Promise.all(animations.map(anim => anim.finished))
                        .then(() => resolve())
                        .catch(err => {
                        if (err instanceof Error && err.name !== 'AbortError') {
                            return reject(err);
                        }
                        // Ignore abort errors as they are expected when the animation is interrupted
                        // by the removal of the element - e.g. when the user navigates away to another page
                        resolve();
                    });
                }
                else {
                    resolve();
                }
            });
        },
    };
}

/**
 * This implementation is heavily inspired by the great work on ngextension!
 * https://github.com/ngxtension/ngxtension-platform/blob/main/libs/ngxtension/explicit-effect/src/explicit-effect.ts
 */
/**
 * This explicit effect function will take the dependencies and the function to run when the dependencies change.
 * @param deps - The dependencies that the effect will run on
 * @param fn - The function to run when the dependencies change
 * @param options - The options for the effect with the addition of defer (it allows the computation to run on first change, not immediately)
 */
function explicitEffect(deps, fn, options) {
    return effect(onCleanup => {
        const depValues = deps.map(s => s());
        untracked(() => fn(depValues, onCleanup));
    }, options);
}

/**
 * A utility service for injecting styles into the document.
 * Angular doesn't allow directives to specify styles, only components.
 * As we ship directives, occasionally we need to associate styles with them.
 * This service allows us to programmatically inject styles into the document.
 */
class StyleInjector {
    constructor() {
        /**
         * Access the CSP nonce
         */
        this.cspNonce = inject(CSP_NONCE, { optional: true });
        /**
         * Access the document.
         */
        this.document = inject(DOCUMENT);
        /**
         * Detect the platform.
         */
        this.platformId = inject(PLATFORM_ID);
        /**
         * Store the map of style elements with their unique identifiers.
         */
        this.styleElements = new Map();
        if (isPlatformBrowser(this.platformId)) {
            this.collectServerStyles();
        }
    }
    /**
     * Inject a style into the document.
     * @param id The unique identifier for the style.
     * @param style The style to inject.
     */
    add(id, style) {
        if (this.styleElements.has(id)) {
            return;
        }
        const styleElement = this.document.createElement('style');
        styleElement.setAttribute('data-ngp-style', id);
        styleElement.textContent = style;
        // If a CSP nonce is provided, set it on the style element
        if (this.cspNonce) {
            styleElement.setAttribute('nonce', this.cspNonce);
        }
        this.document.head.appendChild(styleElement);
        this.styleElements.set(id, styleElement);
    }
    /**
     * Remove a style from the document.
     * @param id The unique identifier for the style.
     */
    remove(id) {
        const styleElement = this.styleElements.get(id);
        if (styleElement) {
            this.document.head.removeChild(styleElement);
            this.styleElements.delete(id);
        }
    }
    /**
     * Collect any styles that were rendered by the server.
     */
    collectServerStyles() {
        const styleElements = this.document.querySelectorAll('style[data-ngp-style]');
        styleElements.forEach(styleElement => {
            const id = styleElement.getAttribute('data-ngp-style');
            if (id) {
                this.styleElements.set(id, styleElement);
            }
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: StyleInjector, deps: [], target: i0.ɵɵFactoryTarget.Injectable }); }
    static { this.ɵprov = i0.ɵɵngDeclareInjectable({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: StyleInjector, providedIn: 'root' }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: StyleInjector, decorators: [{
            type: Injectable,
            args: [{
                    providedIn: 'root',
                }]
        }], ctorParameters: () => [] });
function injectStyleInjector() {
    return inject(StyleInjector);
}

/**
 * A simple helper function to create a resize observer as an RxJS Observable.
 * @param element The element to observe for resize events.
 * @returns The resize event as an Observable.
 */
function fromResizeEvent(element, { disabled = signal(false), injector } = {}) {
    return new Observable(observable => {
        // ResizeObserver may not be available in all environments, so check for its existence
        if (isUndefined(window?.ResizeObserver)) {
            // ResizeObserver is not available (SSR or unsupported browser)
            // Complete the observable without emitting any values
            observable.complete();
            return;
        }
        let observer = null;
        function setupOrTeardownObserver() {
            if (disabled()) {
                if (observer) {
                    observer.disconnect();
                    observer = null;
                }
                return;
            }
            if (!observer) {
                observer = new ResizeObserver(entries => {
                    // if there are no entries, ignore the event
                    if (!entries.length) {
                        return;
                    }
                    // otherwise, take the first entry and emit the dimensions
                    const entry = entries[0];
                    let width, height;
                    if ('borderBoxSize' in entry) {
                        const borderSizeEntry = entry['borderBoxSize'];
                        // this may be different across browsers so normalize it
                        const borderSize = Array.isArray(borderSizeEntry)
                            ? borderSizeEntry[0]
                            : borderSizeEntry;
                        width = borderSize['inlineSize'];
                        height = borderSize['blockSize'];
                    }
                    else {
                        // fallback for browsers that don't support borderBoxSize
                        width = element.offsetWidth;
                        height = element.offsetHeight;
                    }
                    // For inline elements, ResizeObserver may report 0,0 dimensions
                    // Use getBoundingClientRect as fallback for inline elements with zero dimensions
                    if ((width === 0 || height === 0) && getComputedStyle(element).display === 'inline') {
                        const rect = element.getBoundingClientRect();
                        width = rect.width;
                        height = rect.height;
                    }
                    observable.next({ width, height });
                });
                observer.observe(element);
            }
        }
        setupOrTeardownObserver();
        explicitEffect([disabled], () => setupOrTeardownObserver(), { injector });
        return () => observer?.disconnect();
    });
}
/**
 * A utility function to observe any element for resize events and return the dimensions as a signal.
 */
function observeResize(elementFn) {
    const dimensions = signal({ width: 0, height: 0 });
    const injector = inject(Injector);
    const destroyRef = inject(DestroyRef);
    // store the subscription to the resize event
    let subscription = null;
    effect(() => {
        const targetElement = elementFn();
        untracked(() => {
            if (!targetElement) {
                return;
            }
            // if we already have a subscription, unsubscribe from it
            subscription?.unsubscribe();
            // create a new subscription to the resize event
            subscription = fromResizeEvent(targetElement, { injector })
                .pipe(safeTakeUntilDestroyed(destroyRef))
                .subscribe(event => dimensions.set({ width: event.width, height: event.height }));
        });
    });
    return dimensions;
}
/**
 * A simple utility to get the dimensions of an element as a signal.
 */
function injectDimensions() {
    const elementRef = injectElementRef();
    const destroyRef = inject(DestroyRef);
    const dimensions = signal({ width: 0, height: 0 });
    fromResizeEvent(elementRef.nativeElement)
        .pipe(safeTakeUntilDestroyed(destroyRef), map(({ width, height }) => ({ width, height })))
        .subscribe(event => dimensions.set(event));
    return dimensions;
}

/**
 * Whenever an element is removed from the DOM, we call the callback.
 * @param element The element to watch for removal.
 * @param callback The callback to call when the element is removed.
 */
function onDomRemoval(element, callback) {
    const platform = inject(PLATFORM_ID);
    // Dont run this on the server
    if (isPlatformServer(platform)) {
        return;
    }
    // This is a bit of a hack, but it works. If the element dimensions become zero,
    // it's likely that the element has been removed from the DOM.
    fromResizeEvent(element)
        .pipe(safeTakeUntilDestroyed())
        .subscribe(dimensions => {
        // we check the dimensions first to short-circuit the check as it's faster
        if (dimensions.width === 0 && dimensions.height === 0 && !document.body.contains(element)) {
            callback();
        }
    });
}

/**
 * This function sets up a mutation observer to listen for changes in the DOM.
 * It will stop listening when the `disabled` signal is true, and re-enable when it is false.
 * @param options - Options for the mutation observer
 */
function fromMutationObserver(element, { childList, subtree, attributes, characterData, disabled = signal(false), injector, } = {}) {
    return new Observable(observable => {
        let observer = null;
        function setupOrTeardownObserver() {
            if (disabled()) {
                if (observer) {
                    observer.disconnect();
                    observer = null;
                }
                return;
            }
            observer = new MutationObserver(mutations => observable.next(mutations));
            observer.observe(element, { childList, subtree, attributes, characterData });
        }
        setupOrTeardownObserver();
        // any time the disabled state changes, we need to re-evaluate the observer
        explicitEffect([disabled], () => setupOrTeardownObserver(), { injector });
        return () => observer?.disconnect();
    });
}

function setupOverflowListener(element, { disabled = signal(false), injector }) {
    const hasOverflow = signal(false);
    const destroyRef = injector?.get(DestroyRef) ?? inject(DestroyRef);
    // Merge both observables and update hasOverflow on any event
    merge(fromResizeEvent(element, { disabled, injector }), fromMutationObserver(element, { disabled, injector, characterData: true }))
        .pipe(safeTakeUntilDestroyed(destroyRef))
        .subscribe(() => hasOverflow.set(element.scrollWidth > element.clientWidth || element.scrollHeight > element.clientHeight));
    return hasOverflow;
}

function getScrollableAncestor(element) {
    let parent = element.parentElement;
    while (parent) {
        const style = window.getComputedStyle(parent);
        if (/(auto|scroll)/.test(style.overflowY) || /(auto|scroll)/.test(style.overflowX)) {
            return parent;
        }
        parent = parent.parentElement;
    }
    return null;
}
function scrollIntoViewIfNeeded(element) {
    const scrollableAncestor = getScrollableAncestor(element);
    if (!scrollableAncestor)
        return;
    const parentRect = scrollableAncestor.getBoundingClientRect();
    const elementRect = element.getBoundingClientRect();
    if (elementRect.top < parentRect.top) {
        scrollableAncestor.scrollTop -= parentRect.top - elementRect.top;
    }
    else if (elementRect.bottom > parentRect.bottom) {
        scrollableAncestor.scrollTop += elementRect.bottom - parentRect.bottom;
    }
    if (elementRect.left < parentRect.left) {
        scrollableAncestor.scrollLeft -= parentRect.left - elementRect.left;
    }
    else if (elementRect.right > parentRect.right) {
        scrollableAncestor.scrollLeft += elementRect.right - parentRect.right;
    }
}

/**
 * Generated bundle index. Do not edit.
 */

export { NgpExitAnimation, NgpExitAnimationManager, StyleInjector, explicitEffect, fromMutationObserver, fromResizeEvent, injectDimensions, injectElementRef, injectExitAnimationManager, injectStyleInjector, observeResize, onDomRemoval, provideExitAnimationManager, scrollIntoViewIfNeeded, setupExitAnimation, setupOverflowListener };
//# sourceMappingURL=ng-primitives-internal.mjs.map
