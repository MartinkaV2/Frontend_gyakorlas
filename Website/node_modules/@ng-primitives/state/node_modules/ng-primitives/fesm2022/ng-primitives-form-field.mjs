import * as i0 from '@angular/core';
import { input, effect, Directive, computed, booleanAttribute, afterRenderEffect, signal, contentChild, inject, ElementRef, HostListener } from '@angular/core';
import { uniqueId, onBooleanChange, controlStatus, onChange } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { injectElementRef, explicitEffect } from 'ng-primitives/internal';
import { NgControl } from '@angular/forms';

/**
 * The state token  for the FormField primitive.
 */
const NgpFormFieldStateToken = createStateToken('FormField');
/**
 * Provides the FormField state.
 */
const provideFormFieldState = createStateProvider(NgpFormFieldStateToken);
/**
 * Injects the FormField state.
 */
const injectFormFieldState = createStateInjector(NgpFormFieldStateToken);
/**
 * The FormField state registration function.
 */
const formFieldState = createState(NgpFormFieldStateToken);

/**
 * The `NgpDescription` directive is used to mark a description element within a form field. There may be multiple descriptions associated with a form control.
 */
class NgpDescription {
    constructor() {
        /**
         * The id of the description. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-description'));
        /**
         * Access the form field that the description is associated with.
         */
        this.formField = injectFormFieldState({ optional: true });
        effect(onCleanup => {
            this.formField()?.addDescription(this.id());
            onCleanup(() => this.formField()?.removeDescription(this.id()));
        });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDescription, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpDescription, isStandalone: true, selector: "[ngpDescription]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.id": "id()", "attr.data-invalid": "formField()?.invalid() ? \"\" : null", "attr.data-valid": "formField()?.valid() ? \"\" : null", "attr.data-touched": "formField()?.touched() ? \"\" : null", "attr.data-pristine": "formField()?.pristine() ? \"\" : null", "attr.data-dirty": "formField()?.dirty() ? \"\" : null", "attr.data-pending": "formField()?.pending() ? \"\" : null", "attr.data-disabled": "formField()?.disabled() ? \"\" : null" } }, exportAs: ["ngpDescription"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpDescription, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpDescription]',
                    exportAs: 'ngpDescription',
                    host: {
                        '[attr.id]': 'id()',
                        '[attr.data-invalid]': 'formField()?.invalid() ? "" : null',
                        '[attr.data-valid]': 'formField()?.valid() ? "" : null',
                        '[attr.data-touched]': 'formField()?.touched() ? "" : null',
                        '[attr.data-pristine]': 'formField()?.pristine() ? "" : null',
                        '[attr.data-dirty]': 'formField()?.dirty() ? "" : null',
                        '[attr.data-pending]': 'formField()?.pending() ? "" : null',
                        '[attr.data-disabled]': 'formField()?.disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * The `NgpError` directive is used to mark an error message element within a form field. There may be multiple error messages associated with a form control.
 */
class NgpError {
    constructor() {
        /**
         * Access the form field that the description is associated with.
         */
        this.formField = injectFormFieldState({ optional: true });
        /**
         * The id of the error message. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-error'));
        /**
         * The validator associated with the error message.
         */
        this.validator = input(null, {
            alias: 'ngpErrorValidator',
        });
        /**
         * Determine if there is an error message.
         */
        this.hasError = computed(() => {
            const errors = this.formField()?.errors() ?? [];
            const validator = this.validator();
            return validator ? errors?.includes(validator) : errors?.length > 0;
        });
        /**
         * Determine whether the validator associated with this error is failing.
         */
        this.state = computed(() => (this.hasError() ? 'fail' : 'pass'));
        // add or remove the error message when the error state changes
        onBooleanChange(this.hasError, () => this.formField()?.addDescription(this.id()), () => this.formField()?.removeDescription(this.id()));
    }
    ngOnChanges(changes) {
        if ('id' in changes) {
            this.formField()?.removeDescription(changes['id'].previousValue);
        }
    }
    ngOnDestroy() {
        this.formField()?.removeDescription(this.id());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpError, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpError, isStandalone: true, selector: "[ngpError]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, validator: { classPropertyName: "validator", publicName: "ngpErrorValidator", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.id": "id()", "attr.data-invalid": "formField()?.invalid() ? \"\" : null", "attr.data-valid": "formField()?.valid() ? \"\" : null", "attr.data-touched": "formField()?.touched() ? \"\" : null", "attr.data-pristine": "formField()?.pristine() ? \"\" : null", "attr.data-dirty": "formField()?.dirty() ? \"\" : null", "attr.data-pending": "formField()?.pending() ? \"\" : null", "attr.data-disabled": "formField()?.disabled() ? \"\" : null", "attr.data-validator": "state()" } }, exportAs: ["ngpError"], usesOnChanges: true, ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpError, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpError]',
                    exportAs: 'ngpError',
                    host: {
                        '[attr.id]': 'id()',
                        '[attr.data-invalid]': 'formField()?.invalid() ? "" : null',
                        '[attr.data-valid]': 'formField()?.valid() ? "" : null',
                        '[attr.data-touched]': 'formField()?.touched() ? "" : null',
                        '[attr.data-pristine]': 'formField()?.pristine() ? "" : null',
                        '[attr.data-dirty]': 'formField()?.dirty() ? "" : null',
                        '[attr.data-pending]': 'formField()?.pending() ? "" : null',
                        '[attr.data-disabled]': 'formField()?.disabled() ? "" : null',
                        '[attr.data-validator]': 'state()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * The state token  for the FormControl primitive.
 */
const NgpFormControlStateToken = createStateToken('FormControl');
/**
 * Provides the FormControl state.
 */
const provideFormControlState = createStateProvider(NgpFormControlStateToken);
/**
 * Injects the FormControl state.
 */
const injectFormControlState = createStateInjector(NgpFormControlStateToken);
/**
 * The FormControl state registration function.
 */
const formControlState = createState(NgpFormControlStateToken);

/**
 * Typically this primitive would be not be used directly, but instead a more specific form control primitive would be used (e.g. `ngpInput`). All of our form control primitives use `ngpFormControl` internally so they will have the same accessibility features as described below.
 *
 * The `NgpFormControl` directive is used to mark a form control element within a form field. This element will have an `aria-labelledby` attribute set to the ID of the label element within the form field and an `aria-describedby` attribute set to the ID of the description elements within the form field.
 */
class NgpFormControl {
    constructor() {
        /**
         * The id of the form control. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-form-control'));
        /**
         * Whether the form control is disabled by a parent.
         */
        this.disabled = input(false, {
            alias: 'ngpFormControlDisabled',
            transform: booleanAttribute,
        });
        /**
         * The element reference.
         */
        this.elementRef = injectElementRef();
        /**
         * Whether the element supports the disabled attribute.
         */
        this.supportsDisabledAttribute = 'disabled' in this.elementRef.nativeElement;
        /**
         * The state of the form control.
         */
        this.state = formControlState(this);
        // Sync the form control state with the control state.
        this.status = setupFormControl({ id: this.state.id, disabled: this.state.disabled });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFormControl, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpFormControl, isStandalone: true, selector: "[ngpFormControl]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpFormControlDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { properties: { "attr.disabled": "supportsDisabledAttribute && status().disabled ? \"\" : null" } }, providers: [provideFormControlState()], exportAs: ["ngpFormControl"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFormControl, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpFormControl]',
                    exportAs: 'ngpFormControl',
                    providers: [provideFormControlState()],
                    host: {
                        '[attr.disabled]': 'supportsDisabledAttribute && status().disabled ? "" : null',
                    },
                }]
        }], ctorParameters: () => [] });
function setupFormControl({ id, disabled = signal(false), }) {
    const element = injectElementRef().nativeElement;
    // Access the form field that the form control is associated with.
    const formField = injectFormFieldState({ optional: true });
    // Access the form control status.
    const status = controlStatus();
    // Determine the aria-labelledby attribute value.
    const ariaLabelledBy = computed(() => formField()?.labels().join(' '));
    // Determine the aria-describedby attribute value.
    const ariaDescribedBy = computed(() => formField()?.descriptions().join(' '));
    explicitEffect([id], ([id], onCleanup) => {
        formField()?.setFormControl(id);
        onCleanup(() => formField()?.removeFormControl());
    });
    afterRenderEffect({
        write: () => {
            setAttribute(element, 'id', id());
            setAttribute(element, 'aria-labelledby', ariaLabelledBy());
            setAttribute(element, 'aria-describedby', ariaDescribedBy());
            setStateAttribute(element, status().invalid, 'data-invalid');
            setStateAttribute(element, status().valid, 'data-valid');
            setStateAttribute(element, status().touched, 'data-touched');
            setStateAttribute(element, status().pristine, 'data-pristine');
            setStateAttribute(element, status().dirty, 'data-dirty');
            setStateAttribute(element, status().pending, 'data-pending');
            setStateAttribute(element, disabled() || status().disabled, 'data-disabled');
        },
    });
    return computed(() => ({ ...status(), disabled: status().disabled || disabled() }));
}
/**
 * Sets the attribute on the element. If the value is not empty, the attribute is set to the value.
 * If the value is empty, the attribute is removed.
 * @param element The element to set the attribute on.
 * @param attribute The attribute to set on the element.
 * @param value The value to set on the attribute.
 */
function setAttribute(element, attribute, value) {
    if (value && value.length > 0) {
        element.setAttribute(attribute, value);
    }
    else {
        element.removeAttribute(attribute);
    }
}
/**
 * Sets the attribute on the element based on the state. If the state is true, the attribute
 * is set to an empty string. If the state is false, the attribute is removed.
 * @param element The element to set the attribute on.
 * @param state The state to set the attribute based on.
 * @param attribute The attribute to set on the element.
 */
function setStateAttribute(element, state, attribute) {
    if (state) {
        element.setAttribute(attribute, '');
    }
    else {
        element.removeAttribute(attribute);
    }
}

/**
 * The `NgpFormField` directive is a container for form field elements. Any labels, form controls, or descriptions should be placed within this directive.
 */
class NgpFormField {
    constructor() {
        /**
         * Store the form label.
         * @internal
         */
        this.labels = signal([]);
        /**
         * Store the form descriptions.
         * @internal
         */
        this.descriptions = signal([]);
        /**
         * Store the id of the associated form control.
         * @internal
         */
        this.formControl = signal(null);
        /**
         * Find any NgControl within the form field.
         * @internal
         */
        this.ngControl = contentChild(NgControl);
        /**
         * Store the validation error messages.
         * @internal
         */
        this.errors = signal([]);
        /**
         * Whether the control is pristine.
         * @internal
         */
        this.pristine = signal(null);
        /**
         * Whether the control is touched.
         * @internal
         */
        this.touched = signal(null);
        /**
         * Whether the control is dirty.
         * @internal
         */
        this.dirty = signal(null);
        /**
         * Whether the control is valid.
         */
        this.valid = signal(null);
        /**
         * Whether the control is invalid.
         * @internal
         */
        this.invalid = signal(null);
        /**
         * Whether the control is pending.
         * @internal
         */
        this.pending = signal(null);
        /**
         * Whether the control is disabled.
         * @internal
         */
        this.disabled = signal(null);
        /**
         * The form field state.
         */
        this.state = formFieldState(this);
        // any time the ngControl changes, setup the subscriptions.
        onChange(this.ngControl, this.setupSubscriptions.bind(this));
    }
    ngOnDestroy() {
        this.subscription?.unsubscribe();
    }
    /**
     * Setup a listener for the form control status.
     * @param control
     */
    setupSubscriptions(control) {
        // Unsubscribe from the previous subscriptions.
        this.subscription?.unsubscribe();
        // set the initial values
        this.updateStatus();
        const underlyingControl = control?.control;
        // Listen for changes to the underlying control's status.
        this.subscription = underlyingControl?.events?.subscribe(this.updateStatus.bind(this));
    }
    updateStatus() {
        const control = this.ngControl();
        if (!control) {
            return;
        }
        this.pristine.set(control.pristine);
        this.touched.set(control.touched);
        this.dirty.set(control.dirty);
        this.valid.set(control.valid);
        this.invalid.set(control.invalid);
        this.pending.set(control.pending);
        this.disabled.set(control.disabled);
        this.errors.set(control?.errors ? Object.keys(control.errors) : []);
    }
    /**
     * Register the id of the associated form control.
     * @param id
     * @internal
     */
    setFormControl(id) {
        this.formControl.set(id);
    }
    /**
     * Register a label with the form field.
     * @param label
     * @internal
     */
    addLabel(label) {
        this.labels.update(labels => [...labels, label]);
    }
    /**
     * Register a description with the form field.
     * @param description
     * @internal
     */
    addDescription(description) {
        this.descriptions.update(descriptions => [...descriptions, description]);
    }
    /**
     * Remove the associated form control.
     * @internal
     */
    removeFormControl() {
        this.formControl.set(null);
    }
    /**
     * Remove a label from the form field.
     * @param label
     * @internal
     */
    removeLabel(label) {
        this.labels.update(labels => labels.filter(l => l !== label));
    }
    /**
     * Remove a description from the form field.
     * @param description
     * @internal
     */
    removeDescription(description) {
        this.descriptions.update(descriptions => descriptions.filter(d => d !== description));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFormField, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.11", type: NgpFormField, isStandalone: true, selector: "[ngpFormField]", host: { properties: { "attr.data-invalid": "invalid() ? \"\" : null", "attr.data-valid": "valid() ? \"\" : null", "attr.data-touched": "touched() ? \"\" : null", "attr.data-pristine": "pristine() ? \"\" : null", "attr.data-dirty": "dirty() ? \"\" : null", "attr.data-pending": "pending() ? \"\" : null", "attr.data-disabled": "disabled() ? \"\" : null" } }, providers: [provideFormFieldState()], queries: [{ propertyName: "ngControl", first: true, predicate: NgControl, descendants: true, isSignal: true }], exportAs: ["ngpFormField"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpFormField, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpFormField]',
                    exportAs: 'ngpFormField',
                    providers: [provideFormFieldState()],
                    host: {
                        '[attr.data-invalid]': 'invalid() ? "" : null',
                        '[attr.data-valid]': 'valid() ? "" : null',
                        '[attr.data-touched]': 'touched() ? "" : null',
                        '[attr.data-pristine]': 'pristine() ? "" : null',
                        '[attr.data-dirty]': 'dirty() ? "" : null',
                        '[attr.data-pending]': 'pending() ? "" : null',
                        '[attr.data-disabled]': 'disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * The `NgpLabel` directive is used to mark a label element within a form field. Preferably, there should use an HTML `<label>` element.
 */
class NgpLabel {
    constructor() {
        /**
         * The id of the label. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-label'));
        /**
         * Access the form field that the label is associated with.
         */
        this.formField = injectFormFieldState({ optional: true });
        /**
         * Derive the for attribute value if the label is an HTML label element.
         */
        this.htmlFor = computed(() => this.formField()?.formControl());
        /**
         * Access the element that the label is associated with.
         */
        this.elementRef = inject(ElementRef);
        /**
         * Determine if the label is an HTML label element.
         */
        this.isLabel = this.elementRef.nativeElement instanceof HTMLLabelElement;
        effect(onCleanup => {
            this.formField()?.addLabel(this.id());
            onCleanup(() => this.formField()?.removeLabel(this.id()));
        });
    }
    onClick(event) {
        // by default a label will perform a click on the associated form control, however
        // this only works if the associated form control is an input element which may not always
        // be the case, so we prevent the default behavior and handle the click event ourselves.
        // This was inspired by the HeadlessUI approach:
        // https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-react/src/components/label/label.tsx#L58
        if (this.isLabel) {
            event.preventDefault();
        }
        // to find the associated form control we can lookup via the known id
        const targetId = this.htmlFor();
        if (!targetId) {
            return;
        }
        const target = document.getElementById(targetId);
        if (!target) {
            return;
        }
        // if the target is disabled then do nothing
        const disabled = target.getAttribute('disabled');
        const ariaDisabled = target.getAttribute('aria-disabled');
        if (disabled === '' || disabled === 'true' || ariaDisabled === 'true') {
            return;
        }
        // radio buttons, checkboxes and switches should all be clicked immediately as they require state changes
        if ((target instanceof HTMLInputElement &&
            (target.type === 'radio' || target.type === 'checkbox')) ||
            target.role === 'radio' ||
            target.role === 'checkbox' ||
            target.role === 'switch') {
            target.click();
        }
        // Move focus to the element, this allows you to start using keyboard shortcuts since the
        // bound element is now focused.
        target.focus({ preventScroll: true });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpLabel, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpLabel, isStandalone: true, selector: "[ngpLabel]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "onClick($event)" }, properties: { "attr.id": "id()", "attr.for": "htmlFor()", "attr.data-invalid": "formField()?.invalid() ? \"\" : null", "attr.data-valid": "formField()?.valid() ? \"\" : null", "attr.data-touched": "formField()?.touched() ? \"\" : null", "attr.data-pristine": "formField()?.pristine() ? \"\" : null", "attr.data-dirty": "formField()?.dirty() ? \"\" : null", "attr.data-pending": "formField()?.pending() ? \"\" : null", "attr.data-disabled": "formField()?.disabled() ? \"\" : null" } }, exportAs: ["ngpLabel"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpLabel, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpLabel]',
                    exportAs: 'ngpLabel',
                    host: {
                        '[attr.id]': 'id()',
                        '[attr.for]': 'htmlFor()',
                        '[attr.data-invalid]': 'formField()?.invalid() ? "" : null',
                        '[attr.data-valid]': 'formField()?.valid() ? "" : null',
                        '[attr.data-touched]': 'formField()?.touched() ? "" : null',
                        '[attr.data-pristine]': 'formField()?.pristine() ? "" : null',
                        '[attr.data-dirty]': 'formField()?.dirty() ? "" : null',
                        '[attr.data-pending]': 'formField()?.pending() ? "" : null',
                        '[attr.data-disabled]': 'formField()?.disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { onClick: [{
                type: HostListener,
                args: ['click', ['$event']]
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpDescription, NgpError, NgpFormControl, NgpFormField, NgpLabel, injectFormControlState, injectFormFieldState, provideFormControlState, provideFormFieldState, setupFormControl };
//# sourceMappingURL=ng-primitives-form-field.mjs.map
