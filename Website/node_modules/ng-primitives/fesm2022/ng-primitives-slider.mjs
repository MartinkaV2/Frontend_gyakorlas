import * as i0 from '@angular/core';
import { Directive, HostListener, input, numberAttribute, output, booleanAttribute, signal, computed } from '@angular/core';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { ngpInteractions } from 'ng-primitives/interactions';
import { injectElementRef } from 'ng-primitives/internal';
import { setupFormControl } from 'ng-primitives/form-field';
import { uniqueId } from 'ng-primitives/utils';

/**
 * The state token  for the Slider primitive.
 */
const NgpSliderStateToken = createStateToken('Slider');
/**
 * Provides the Slider state.
 */
const provideSliderState = createStateProvider(NgpSliderStateToken);
/**
 * Injects the Slider state.
 */
const injectSliderState = createStateInjector(NgpSliderStateToken);
/**
 * The Slider state registration function.
 */
const sliderState = createState(NgpSliderStateToken);

/**
 * Apply the `ngpSliderRange` directive to an element that represents the range of the slider.
 */
class NgpSliderRange {
    constructor() {
        /**
         * Access the slider state.
         */
        this.sliderState = injectSliderState();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSliderRange, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpSliderRange, isStandalone: true, selector: "[ngpSliderRange]", host: { properties: { "attr.data-orientation": "sliderState().orientation()", "attr.data-disabled": "sliderState().disabled() ? \"\" : null", "style.width.%": "sliderState().orientation() === \"horizontal\" ? sliderState().percentage() : undefined", "style.height.%": "sliderState().orientation() === \"vertical\" ? sliderState().percentage() : undefined" } }, exportAs: ["ngpSliderRange"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSliderRange, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpSliderRange]',
                    exportAs: 'ngpSliderRange',
                    host: {
                        '[attr.data-orientation]': 'sliderState().orientation()',
                        '[attr.data-disabled]': 'sliderState().disabled() ? "" : null',
                        '[style.width.%]': 'sliderState().orientation() === "horizontal" ? sliderState().percentage() : undefined',
                        '[style.height.%]': 'sliderState().orientation() === "vertical" ? sliderState().percentage() : undefined',
                    },
                }]
        }] });

/**
 * Apply the `ngpSliderThumb` directive to an element that represents the thumb of the slider.
 */
class NgpSliderThumb {
    constructor() {
        /**
         * Access the slider state.
         */
        this.state = injectSliderState();
        /**
         * Access the thumb element.
         */
        this.elementRef = injectElementRef();
        /**
         * Store the dragging state.
         */
        this.dragging = false;
        ngpInteractions({
            hover: true,
            focusVisible: true,
            press: true,
            disabled: this.state().disabled,
        });
    }
    handlePointerDown(event) {
        event.preventDefault();
        if (this.state().disabled()) {
            return;
        }
        this.dragging = true;
    }
    handlePointerUp() {
        if (this.state().disabled()) {
            return;
        }
        this.dragging = false;
    }
    handlePointerMove(event) {
        if (this.state().disabled() || !this.dragging) {
            return;
        }
        const rect = this.state().track()?.element.nativeElement.getBoundingClientRect();
        if (!rect) {
            return;
        }
        const percentage = this.state().orientation() === 'horizontal'
            ? (event.clientX - rect.left) / rect.width
            : 1 - (event.clientY - rect.top) / rect.height;
        const value = this.state().min() +
            (this.state().max() - this.state().min()) * Math.max(0, Math.min(1, percentage));
        this.state().value.set(value);
        this.state().valueChange.emit(value);
    }
    /**
     * Handle keyboard events.
     * @param event
     */
    handleKeydown(event) {
        const multiplier = event.shiftKey ? 10 : 1;
        const step = this.state().step() * multiplier;
        const currentValue = this.state().value();
        // determine the document direction
        const isRTL = getComputedStyle(this.elementRef.nativeElement).direction === 'rtl';
        let newValue;
        switch (event.key) {
            case 'ArrowLeft':
                newValue = isRTL
                    ? Math.min(currentValue + step, this.state().max())
                    : Math.max(currentValue - step, this.state().min());
                break;
            case 'ArrowDown':
                newValue = Math.max(currentValue - step, this.state().min());
                break;
            case 'ArrowRight':
                newValue = isRTL
                    ? Math.max(currentValue - step, this.state().min())
                    : Math.min(currentValue + step, this.state().max());
                break;
            case 'ArrowUp':
                newValue = Math.min(currentValue + step, this.state().max());
                break;
            case 'Home':
                newValue = isRTL ? this.state().max() : this.state().min();
                break;
            case 'End':
                newValue = isRTL ? this.state().min() : this.state().max();
                break;
            default:
                return;
        }
        // if the value is the same, do not emit an event
        if (newValue === currentValue) {
            return;
        }
        this.state().value.set(newValue);
        this.state().valueChange.emit(newValue);
        event.preventDefault();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSliderThumb, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpSliderThumb, isStandalone: true, selector: "[ngpSliderThumb]", host: { attributes: { "role": "slider" }, listeners: { "pointerdown": "handlePointerDown($event)", "document:pointerup": "handlePointerUp()", "document:pointermove": "handlePointerMove($event)", "keydown": "handleKeydown($event)" }, properties: { "attr.aria-valuemin": "state().min()", "attr.aria-valuemax": "state().max()", "attr.aria-valuenow": "state().value()", "attr.aria-orientation": "state().orientation()", "tabindex": "state().disabled() ? -1 : 0", "attr.data-orientation": "state().orientation()", "attr.data-disabled": "state().disabled() ? \"\" : null", "style.inset-inline-start.%": "state().orientation() === \"horizontal\" ? state().percentage() : undefined", "style.inset-block-start.%": "state().orientation() === \"vertical\" ? state().percentage() : undefined" } }, exportAs: ["ngpSliderThumb"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSliderThumb, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpSliderThumb]',
                    exportAs: 'ngpSliderThumb',
                    host: {
                        role: 'slider',
                        '[attr.aria-valuemin]': 'state().min()',
                        '[attr.aria-valuemax]': 'state().max()',
                        '[attr.aria-valuenow]': 'state().value()',
                        '[attr.aria-orientation]': 'state().orientation()',
                        '[tabindex]': 'state().disabled() ? -1 : 0',
                        '[attr.data-orientation]': 'state().orientation()',
                        '[attr.data-disabled]': 'state().disabled() ? "" : null',
                        '[style.inset-inline-start.%]': 'state().orientation() === "horizontal" ? state().percentage() : undefined',
                        '[style.inset-block-start.%]': 'state().orientation() === "vertical" ? state().percentage() : undefined',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handlePointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }], handlePointerUp: [{
                type: HostListener,
                args: ['document:pointerup']
            }], handlePointerMove: [{
                type: HostListener,
                args: ['document:pointermove', ['$event']]
            }], handleKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

/**
 * Apply the `ngpSliderTrack` directive to an element that represents the track of the slider.
 */
class NgpSliderTrack {
    constructor() {
        /**
         * Access the slider state.
         */
        this.sliderState = injectSliderState();
        /**
         * The element that represents the slider track.
         */
        this.element = injectElementRef();
        this.sliderState().track.set(this);
    }
    /**
     * When the slider track is clicked, update the value.
     * @param event The click event.
     */
    handlePointerDown(event) {
        if (this.sliderState().disabled()) {
            return;
        }
        // get the position the click occurred within the slider track
        const position = this.sliderState().orientation() === 'horizontal' ? event.clientX : event.clientY;
        const rect = this.element.nativeElement.getBoundingClientRect();
        const percentage = (position - (this.sliderState().orientation() === 'horizontal' ? rect.left : rect.top)) /
            (this.sliderState().orientation() === 'horizontal' ? rect.width : rect.height);
        // update the value based on the position
        this.sliderState().value.set(this.sliderState().min() + (this.sliderState().max() - this.sliderState().min()) * percentage);
        this.sliderState().valueChange.emit(this.sliderState().value());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSliderTrack, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpSliderTrack, isStandalone: true, selector: "[ngpSliderTrack]", host: { listeners: { "pointerdown": "handlePointerDown($event)" }, properties: { "attr.data-orientation": "sliderState().orientation()", "attr.data-disabled": "sliderState().disabled() ? \"\" : null" } }, exportAs: ["ngpSliderTrack"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSliderTrack, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpSliderTrack]',
                    exportAs: 'ngpSliderTrack',
                    host: {
                        '[attr.data-orientation]': 'sliderState().orientation()',
                        '[attr.data-disabled]': 'sliderState().disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handlePointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }] } });

/**
 * Apply the `ngpSlider` directive to an element that represents the slider and contains the track, range, and thumb.
 */
class NgpSlider {
    constructor() {
        /**
         * The id of the slider. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-slider'));
        /**
         * The value of the slider.
         */
        this.value = input(0, {
            alias: 'ngpSliderValue',
            transform: numberAttribute,
        });
        /**
         * Emits when the value changes.
         */
        this.valueChange = output({
            alias: 'ngpSliderValueChange',
        });
        /**
         * The minimum value of the slider.
         */
        this.min = input(0, {
            alias: 'ngpSliderMin',
            transform: numberAttribute,
        });
        /**
         * The maximum value of the slider.
         */
        this.max = input(100, {
            alias: 'ngpSliderMax',
            transform: numberAttribute,
        });
        /**
         * The step value of the slider.
         */
        this.step = input(1, {
            alias: 'ngpSliderStep',
            transform: numberAttribute,
        });
        /**
         * The orientation of the slider.
         */
        this.orientation = input('horizontal', {
            alias: 'ngpSliderOrientation',
        });
        /**
         * The disabled state of the slider.
         */
        this.disabled = input(false, {
            alias: 'ngpSliderDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the slider track.
         * @internal
         */
        this.track = signal(undefined);
        /**
         * The value as a percentage based on the min and max values.
         */
        this.percentage = computed(() => ((this.state.value() - this.state.min()) / (this.state.max() - this.state.min())) * 100);
        /**
         * The state of the slider. We use this for the slider state rather than relying on the inputs.
         * @internal
         */
        this.state = sliderState(this);
        setupFormControl({ id: this.state.id, disabled: this.state.disabled });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSlider, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpSlider, isStandalone: true, selector: "[ngpSlider]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpSliderValue", isSignal: true, isRequired: false, transformFunction: null }, min: { classPropertyName: "min", publicName: "ngpSliderMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpSliderMax", isSignal: true, isRequired: false, transformFunction: null }, step: { classPropertyName: "step", publicName: "ngpSliderStep", isSignal: true, isRequired: false, transformFunction: null }, orientation: { classPropertyName: "orientation", publicName: "ngpSliderOrientation", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpSliderDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { valueChange: "ngpSliderValueChange" }, host: { properties: { "id": "id()", "attr.data-orientation": "state.orientation()" } }, providers: [provideSliderState()], exportAs: ["ngpSlider"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpSlider, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpSlider]',
                    exportAs: 'ngpSlider',
                    providers: [provideSliderState()],
                    host: {
                        '[id]': 'id()',
                        '[attr.data-orientation]': 'state.orientation()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * The state token for the Range Slider primitive.
 */
const NgpRangeSliderStateToken = createStateToken('RangeSlider');
/**
 * Provides the Range Slider state.
 */
const provideRangeSliderState = createStateProvider(NgpRangeSliderStateToken);
/**
 * Injects the Range Slider state.
 */
const injectRangeSliderState = createStateInjector(NgpRangeSliderStateToken);
/**
 * The Range Slider state registration function.
 */
const rangeSliderState = createState(NgpRangeSliderStateToken);

/**
 * Apply the `ngpRangeSliderRange` directive to an element that represents the range between the low and high values.
 */
class NgpRangeSliderRange {
    constructor() {
        /**
         * Access the range slider state.
         */
        this.rangeSliderState = injectRangeSliderState();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSliderRange, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpRangeSliderRange, isStandalone: true, selector: "[ngpRangeSliderRange]", host: { properties: { "attr.data-orientation": "rangeSliderState().orientation()", "attr.data-disabled": "rangeSliderState().disabled() ? \"\" : null", "style.width.%": "rangeSliderState().orientation() === \"horizontal\" ? rangeSliderState().rangePercentage() : undefined", "style.height.%": "rangeSliderState().orientation() === \"vertical\" ? rangeSliderState().rangePercentage() : undefined", "style.inset-inline-start.%": "rangeSliderState().orientation() === \"horizontal\" ? rangeSliderState().lowPercentage() : undefined", "style.inset-block-start.%": "rangeSliderState().orientation() === \"vertical\" ? rangeSliderState().lowPercentage() : undefined" } }, exportAs: ["ngpRangeSliderRange"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSliderRange, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRangeSliderRange]',
                    exportAs: 'ngpRangeSliderRange',
                    host: {
                        '[attr.data-orientation]': 'rangeSliderState().orientation()',
                        '[attr.data-disabled]': 'rangeSliderState().disabled() ? "" : null',
                        '[style.width.%]': 'rangeSliderState().orientation() === "horizontal" ? rangeSliderState().rangePercentage() : undefined',
                        '[style.height.%]': 'rangeSliderState().orientation() === "vertical" ? rangeSliderState().rangePercentage() : undefined',
                        '[style.inset-inline-start.%]': 'rangeSliderState().orientation() === "horizontal" ? rangeSliderState().lowPercentage() : undefined',
                        '[style.inset-block-start.%]': 'rangeSliderState().orientation() === "vertical" ? rangeSliderState().lowPercentage() : undefined',
                    },
                }]
        }] });

/**
 * Apply the `ngpRangeSliderThumb` directive to an element that represents a thumb of the range slider.
 * Each thumb can be configured to control either the 'low' or 'high' value.
 */
class NgpRangeSliderThumb {
    constructor() {
        /**
         * Access the range slider state.
         */
        this.state = injectRangeSliderState();
        /**
         * Access the thumb element.
         */
        this.elementRef = injectElementRef();
        /**
         * Determines which value this thumb controls ('low' or 'high').
         */
        this.thumb = computed(() => this.state().thumbs().indexOf(this) === 0 ? 'low' : 'high');
        /**
         * Store the dragging state.
         */
        this.dragging = false;
        /**
         * Get the current value for this thumb.
         */
        this.value = computed(() => this.thumb() === 'low' ? this.state().low() : this.state().high());
        /**
         * Get the current percentage for this thumb.
         */
        this.percentage = computed(() => this.thumb() === 'low' ? this.state().lowPercentage() : this.state().highPercentage());
        ngpInteractions({
            hover: true,
            focusVisible: true,
            press: true,
            disabled: this.state().disabled,
        });
        this.state().addThumb(this);
    }
    ngOnDestroy() {
        this.state().removeThumb(this);
    }
    handlePointerDown(event) {
        event.preventDefault();
        if (this.state().disabled()) {
            return;
        }
        this.dragging = true;
    }
    handlePointerUp() {
        if (this.state().disabled()) {
            return;
        }
        this.dragging = false;
    }
    handlePointerMove(event) {
        if (this.state().disabled() || !this.dragging) {
            return;
        }
        const rect = this.state().track()?.element.nativeElement.getBoundingClientRect();
        if (!rect) {
            return;
        }
        const percentage = this.state().orientation() === 'horizontal'
            ? (event.clientX - rect.left) / rect.width
            : (event.clientY - rect.top) / rect.height;
        const value = this.state().min() +
            (this.state().max() - this.state().min()) * Math.max(0, Math.min(1, percentage));
        // Update the appropriate value based on thumb type
        if (this.thumb() === 'low') {
            this.state().setLowValue(value);
        }
        else {
            this.state().setHighValue(value);
        }
    }
    /**
     * Handle keyboard events.
     * @param event
     */
    handleKeydown(event) {
        const multiplier = event.shiftKey ? 10 : 1;
        const currentValue = this.value();
        const step = this.state().step() * multiplier;
        // determine the document direction
        const isRTL = getComputedStyle(this.elementRef.nativeElement).direction === 'rtl';
        let newValue;
        switch (event.key) {
            case 'ArrowLeft':
                newValue = isRTL
                    ? Math.min(currentValue - step, this.state().max())
                    : Math.max(currentValue - step, this.state().min());
                break;
            case 'ArrowDown':
                newValue = Math.max(currentValue - step, this.state().min());
                break;
            case 'ArrowRight':
                newValue = isRTL
                    ? Math.max(currentValue + step, this.state().min())
                    : Math.min(currentValue + step, this.state().max());
                break;
            case 'ArrowUp':
                newValue = Math.min(currentValue + step, this.state().max());
                break;
            case 'Home':
                newValue = isRTL ? this.state().max() : this.state().min();
                break;
            case 'End':
                newValue = isRTL ? this.state().min() : this.state().max();
                break;
            default:
                return;
        }
        // Update the appropriate value based on thumb type
        if (this.thumb() === 'low') {
            this.state().setLowValue(newValue);
        }
        else {
            this.state().setHighValue(newValue);
        }
        event.preventDefault();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSliderThumb, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpRangeSliderThumb, isStandalone: true, selector: "[ngpRangeSliderThumb]", host: { attributes: { "role": "slider" }, listeners: { "pointerdown": "handlePointerDown($event)", "document:pointerup": "handlePointerUp()", "document:pointermove": "handlePointerMove($event)", "keydown": "handleKeydown($event)" }, properties: { "attr.aria-valuemin": "state().min()", "attr.aria-valuemax": "state().max()", "attr.aria-valuenow": "value()", "attr.aria-orientation": "state().orientation()", "tabindex": "state().disabled() ? -1 : 0", "attr.data-orientation": "state().orientation()", "attr.data-disabled": "state().disabled() ? \"\" : null", "attr.data-thumb": "thumb()", "style.inset-inline-start.%": "state().orientation() === \"horizontal\" ? percentage() : undefined", "style.inset-block-start.%": "state().orientation() === \"vertical\" ? percentage() : undefined" } }, exportAs: ["ngpRangeSliderThumb"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSliderThumb, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRangeSliderThumb]',
                    exportAs: 'ngpRangeSliderThumb',
                    host: {
                        role: 'slider',
                        '[attr.aria-valuemin]': 'state().min()',
                        '[attr.aria-valuemax]': 'state().max()',
                        '[attr.aria-valuenow]': 'value()',
                        '[attr.aria-orientation]': 'state().orientation()',
                        '[tabindex]': 'state().disabled() ? -1 : 0',
                        '[attr.data-orientation]': 'state().orientation()',
                        '[attr.data-disabled]': 'state().disabled() ? "" : null',
                        '[attr.data-thumb]': 'thumb()',
                        '[style.inset-inline-start.%]': 'state().orientation() === "horizontal" ? percentage() : undefined',
                        '[style.inset-block-start.%]': 'state().orientation() === "vertical" ? percentage() : undefined',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handlePointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }], handlePointerUp: [{
                type: HostListener,
                args: ['document:pointerup']
            }], handlePointerMove: [{
                type: HostListener,
                args: ['document:pointermove', ['$event']]
            }], handleKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

/**
 * Apply the `ngpRangeSliderTrack` directive to an element that represents the track of the range slider.
 */
class NgpRangeSliderTrack {
    constructor() {
        /**
         * Access the range slider state.
         */
        this.rangeSliderState = injectRangeSliderState();
        /**
         * The element that represents the slider track.
         */
        this.element = injectElementRef();
        this.rangeSliderState().track.set(this);
    }
    /**
     * When the slider track is clicked, update the closest thumb value.
     * @param event The click event.
     */
    handlePointerDown(event) {
        if (this.rangeSliderState().disabled()) {
            return;
        }
        // get the position the click occurred within the slider track
        const position = this.rangeSliderState().orientation() === 'horizontal' ? event.clientX : event.clientY;
        const rect = this.element.nativeElement.getBoundingClientRect();
        const percentage = (position - (this.rangeSliderState().orientation() === 'horizontal' ? rect.left : rect.top)) /
            (this.rangeSliderState().orientation() === 'horizontal' ? rect.width : rect.height);
        // calculate the value based on the position
        const value = this.rangeSliderState().min() +
            (this.rangeSliderState().max() - this.rangeSliderState().min()) * percentage;
        // determine which thumb to move based on proximity
        const closestThumb = this.rangeSliderState().getClosestThumb(percentage * 100);
        if (closestThumb === 'low') {
            this.rangeSliderState().setLowValue(value);
        }
        else {
            this.rangeSliderState().setHighValue(value);
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSliderTrack, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpRangeSliderTrack, isStandalone: true, selector: "[ngpRangeSliderTrack]", host: { listeners: { "pointerdown": "handlePointerDown($event)" }, properties: { "attr.data-orientation": "rangeSliderState().orientation()", "attr.data-disabled": "rangeSliderState().disabled() ? \"\" : null" } }, exportAs: ["ngpRangeSliderTrack"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSliderTrack, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRangeSliderTrack]',
                    exportAs: 'ngpRangeSliderTrack',
                    host: {
                        '[attr.data-orientation]': 'rangeSliderState().orientation()',
                        '[attr.data-disabled]': 'rangeSliderState().disabled() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handlePointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }] } });

/**
 * Apply the `ngpRangeSlider` directive to an element that represents the range slider and contains the track, range, and thumbs.
 */
class NgpRangeSlider {
    constructor() {
        /**
         * The id of the range slider. If not provided, a unique id will be generated.
         */
        this.id = input(uniqueId('ngp-range-slider'));
        /**
         * The low value of the range slider.
         */
        this.low = input(0, {
            alias: 'ngpRangeSliderLow',
            transform: numberAttribute,
        });
        /**
         * Emits when the low value changes.
         */
        this.lowChange = output({
            alias: 'ngpRangeSliderLowChange',
        });
        /**
         * The high value of the range slider.
         */
        this.high = input(100, {
            alias: 'ngpRangeSliderHigh',
            transform: numberAttribute,
        });
        /**
         * Emits when the high value changes.
         */
        this.highChange = output({
            alias: 'ngpRangeSliderHighChange',
        });
        /**
         * The minimum value of the range slider.
         */
        this.min = input(0, {
            alias: 'ngpRangeSliderMin',
            transform: numberAttribute,
        });
        /**
         * The maximum value of the range slider.
         */
        this.max = input(100, {
            alias: 'ngpRangeSliderMax',
            transform: numberAttribute,
        });
        /**
         * The step value of the range slider.
         */
        this.step = input(1, {
            alias: 'ngpRangeSliderStep',
            transform: numberAttribute,
        });
        /**
         * The orientation of the range slider.
         */
        this.orientation = input('horizontal', {
            alias: 'ngpRangeSliderOrientation',
        });
        /**
         * The disabled state of the range slider.
         */
        this.disabled = input(false, {
            alias: 'ngpRangeSliderDisabled',
            transform: booleanAttribute,
        });
        /**
         * Access the slider track.
         * @internal
         */
        this.track = signal(undefined);
        /**
         * The thumbs of the range slider.
         * @internal
         */
        this.thumbs = signal([]);
        /**
         * The low value as a percentage based on the min and max values.
         * @internal
         */
        this.lowPercentage = computed(() => ((this.state.low() - this.state.min()) / (this.state.max() - this.state.min())) * 100);
        /**
         * The high value as a percentage based on the min and max values.
         * @internal
         */
        this.highPercentage = computed(() => ((this.state.high() - this.state.min()) / (this.state.max() - this.state.min())) * 100);
        /**
         * The range between low and high values as a percentage.
         * @internal
         */
        this.rangePercentage = computed(() => this.highPercentage() - this.lowPercentage());
        /**
         * The state of the range slider. We use this for the range slider state rather than relying on the inputs.
         * @internal
         */
        this.state = rangeSliderState(this);
        setupFormControl({ id: this.state.id, disabled: this.state.disabled });
    }
    /**
     * Updates the low value, ensuring it doesn't exceed the high value.
     * @param value The new low value
     * @internal
     */
    setLowValue(value) {
        const clampedValue = Math.max(this.state.min(), Math.min(value, this.state.high()));
        this.state.low.set(clampedValue);
        this.lowChange.emit(clampedValue);
    }
    /**
     * Updates the high value, ensuring it doesn't go below the low value.
     * @param value The new high value
     * @internal
     */
    setHighValue(value) {
        const clampedValue = Math.min(this.state.max(), Math.max(value, this.state.low()));
        this.state.high.set(clampedValue);
        this.highChange.emit(clampedValue);
    }
    /**
     * Determines which thumb should be moved based on the position clicked.
     * @param percentage The percentage position of the click
     * @returns 'low' or 'high' indicating which thumb should move
     *
     * @internal
     */
    getClosestThumb(percentage) {
        const value = this.state.min() + (this.state.max() - this.state.min()) * (percentage / 100);
        const distanceToLow = Math.abs(value - this.state.low());
        const distanceToHigh = Math.abs(value - this.state.high());
        return distanceToLow <= distanceToHigh ? 'low' : 'high';
    }
    /**
     * Updates the thumbs array when a new thumb is added.
     * @param thumb The new thumb to add
     * @internal
     */
    addThumb(thumb) {
        this.thumbs.update(thumbs => [...thumbs, thumb]);
    }
    /**
     * Removes a thumb from the thumbs array.
     * @param thumb The thumb to remove
     * @internal
     */
    removeThumb(thumb) {
        this.thumbs.update(thumbs => thumbs.filter(t => t !== thumb));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSlider, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpRangeSlider, isStandalone: true, selector: "[ngpRangeSlider]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, low: { classPropertyName: "low", publicName: "ngpRangeSliderLow", isSignal: true, isRequired: false, transformFunction: null }, high: { classPropertyName: "high", publicName: "ngpRangeSliderHigh", isSignal: true, isRequired: false, transformFunction: null }, min: { classPropertyName: "min", publicName: "ngpRangeSliderMin", isSignal: true, isRequired: false, transformFunction: null }, max: { classPropertyName: "max", publicName: "ngpRangeSliderMax", isSignal: true, isRequired: false, transformFunction: null }, step: { classPropertyName: "step", publicName: "ngpRangeSliderStep", isSignal: true, isRequired: false, transformFunction: null }, orientation: { classPropertyName: "orientation", publicName: "ngpRangeSliderOrientation", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpRangeSliderDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { lowChange: "ngpRangeSliderLowChange", highChange: "ngpRangeSliderHighChange" }, host: { properties: { "id": "id()", "attr.data-orientation": "state.orientation()" } }, providers: [provideRangeSliderState()], exportAs: ["ngpRangeSlider"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpRangeSlider, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpRangeSlider]',
                    exportAs: 'ngpRangeSlider',
                    providers: [provideRangeSliderState()],
                    host: {
                        '[id]': 'id()',
                        '[attr.data-orientation]': 'state.orientation()',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpRangeSlider, NgpRangeSliderRange, NgpRangeSliderThumb, NgpRangeSliderTrack, NgpSlider, NgpSliderRange, NgpSliderThumb, NgpSliderTrack, injectRangeSliderState, injectSliderState, provideRangeSliderState, provideSliderState };
//# sourceMappingURL=ng-primitives-slider.mjs.map
