import * as i0 from '@angular/core';
import { input, computed, HostListener, Directive, booleanAttribute, inject, ViewContainerRef, TemplateRef, Injector, signal, InjectionToken, output, afterRenderEffect } from '@angular/core';
import { ngpInteractions } from 'ng-primitives/interactions';
import { injectElementRef, observeResize } from 'ng-primitives/internal';
import { uniqueId } from 'ng-primitives/utils';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { setupFormControl } from 'ng-primitives/form-field';
import { createOverlay } from 'ng-primitives/portal';
import { activeDescendantManager } from 'ng-primitives/a11y';

/**
 * The state token  for the Combobox primitive.
 */
const NgpComboboxStateToken = createStateToken('Combobox');
/**
 * Provides the Combobox state.
 */
const provideComboboxState = createStateProvider(NgpComboboxStateToken);
/**
 * Injects the Combobox state.
 */
const injectComboboxState = createStateInjector(NgpComboboxStateToken);
/**
 * The Combobox state registration function.
 */
const comboboxState = createState(NgpComboboxStateToken);

class NgpComboboxButton {
    constructor() {
        /** Access the combobox state. */
        this.state = injectComboboxState();
        /**
         * Access the element reference.
         * @internal
         */
        this.elementRef = injectElementRef();
        /** The id of the button. */
        this.id = input(uniqueId('ngp-combobox-button'));
        /** The id of the dropdown. */
        this.dropdownId = computed(() => this.state().dropdown()?.id());
        ngpInteractions({
            hover: true,
            press: true,
            disabled: this.state().disabled,
        });
        this.state().registerButton(this);
    }
    async toggleDropdown() {
        await this.state().toggleDropdown();
        this.state().input()?.focus();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxButton, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpComboboxButton, isStandalone: true, selector: "[ngpComboboxButton]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "type": "button", "tabindex": "-1", "aria-haspopup": "listbox" }, listeners: { "click": "toggleDropdown()" }, properties: { "id": "id()", "attr.aria-controls": "dropdownId()", "attr.aria-expanded": "state().open()", "attr.data-open": "state().open() ? \"\" : undefined", "attr.data-disabled": "state().disabled() ? \"\" : undefined", "attr.data-multiple": "state().multiple() ? \"\" : undefined", "disabled": "state().disabled()" } }, exportAs: ["ngpComboboxButton"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxButton, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpComboboxButton]',
                    exportAs: 'ngpComboboxButton',
                    host: {
                        type: 'button',
                        tabindex: '-1',
                        'aria-haspopup': 'listbox',
                        '[id]': 'id()',
                        '[attr.aria-controls]': 'dropdownId()',
                        '[attr.aria-expanded]': 'state().open()',
                        '[attr.data-open]': 'state().open() ? "" : undefined',
                        '[attr.data-disabled]': 'state().disabled() ? "" : undefined',
                        '[attr.data-multiple]': 'state().multiple() ? "" : undefined',
                        '[disabled]': 'state().disabled()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { toggleDropdown: [{
                type: HostListener,
                args: ['click']
            }] } });

class NgpComboboxDropdown {
    constructor() {
        /** Access the combobox state. */
        this.state = injectComboboxState();
        /** The dimensions of the combobox. */
        this.comboboxDimensions = observeResize(() => this.state().elementRef.nativeElement);
        /** The dimensions of the combobox. */
        this.inputDimensions = observeResize(() => this.state().input()?.elementRef.nativeElement);
        /** Store the combobox button dimensions. */
        this.buttonDimensions = observeResize(() => this.state().button()?.elementRef.nativeElement);
        /**
         * Access the element reference.
         * @internal
         */
        this.elementRef = injectElementRef();
        /** The id of the dropdown. */
        this.id = input(uniqueId('ngp-combobox-dropdown'));
        this.state().registerDropdown(this);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxDropdown, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpComboboxDropdown, isStandalone: true, selector: "[ngpComboboxDropdown]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "listbox" }, properties: { "id": "id()", "style.left.px": "state().overlay()?.position()?.x", "style.top.px": "state().overlay()?.position()?.y", "style.--ngp-combobox-transform-origin": "state().overlay()?.transformOrigin()", "style.--ngp-combobox-width.px": "comboboxDimensions().width", "style.--ngp-combobox-input-width.px": "inputDimensions().width", "style.--ngp-combobox-button-width.px": "buttonDimensions().width" } }, exportAs: ["ngpComboboxDropdown"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxDropdown, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpComboboxDropdown]',
                    exportAs: 'ngpComboboxDropdown',
                    host: {
                        role: 'listbox',
                        '[id]': 'id()',
                        '[style.left.px]': 'state().overlay()?.position()?.x',
                        '[style.top.px]': 'state().overlay()?.position()?.y',
                        '[style.--ngp-combobox-transform-origin]': 'state().overlay()?.transformOrigin()',
                        '[style.--ngp-combobox-width.px]': 'comboboxDimensions().width',
                        '[style.--ngp-combobox-input-width.px]': 'inputDimensions().width',
                        '[style.--ngp-combobox-button-width.px]': 'buttonDimensions().width',
                    },
                }]
        }], ctorParameters: () => [] });

class NgpComboboxInput {
    constructor() {
        /** Access the combobox state. */
        this.state = injectComboboxState();
        /**
         * Access the element reference.
         * @internal
         */
        this.elementRef = injectElementRef();
        /** The id of the input. */
        this.id = input(uniqueId('ngp-combobox-input'));
        /** The id of the dropdown. */
        this.dropdownId = computed(() => this.state().dropdown()?.id());
        /** The id of the active descendant. */
        this.activeDescendant = computed(() => this.state().activeDescendantManager.activeDescendant());
        /** Determine if the pointer was used to focus the input. */
        this.pointerFocused = false;
        /**
         * The control status - this is required as we apply them to the combobox element as well as the input element.
         * @internal
         */
        this.controlStatus = setupFormControl({ id: this.id, disabled: this.state().disabled });
        ngpInteractions({
            focus: true,
            hover: true,
            press: true,
            disabled: this.state().disabled,
        });
        this.state().registerInput(this);
    }
    /** Handle keydown events for accessibility. */
    handleKeydown(event) {
        switch (event.key) {
            case 'ArrowDown':
                if (this.state().open()) {
                    this.state().activateNextOption();
                }
                else {
                    this.state().openDropdown();
                }
                event.preventDefault();
                break;
            case 'ArrowUp':
                if (this.state().open()) {
                    this.state().activatePreviousOption();
                }
                else {
                    this.state().openDropdown();
                    this.state().activeDescendantManager.last();
                }
                event.preventDefault();
                break;
            case 'Home':
                if (this.state().open()) {
                    this.state().activeDescendantManager.first();
                }
                event.preventDefault();
                break;
            case 'End':
                if (this.state().open()) {
                    this.state().activeDescendantManager.last();
                }
                event.preventDefault();
                break;
            case 'Enter':
                if (this.state().open()) {
                    const activeItem = this.state().activeDescendantManager.activeItem();
                    if (activeItem) {
                        this.state().toggleOption(activeItem);
                    }
                }
                event.preventDefault();
                break;
            case 'Escape':
                this.state().closeDropdown();
                event.preventDefault();
                break;
            case 'Backspace':
                // if the input is not empty then open the dropdown
                if (this.elementRef.nativeElement.value.length > 0) {
                    this.state().openDropdown();
                }
                break;
            default:
                // Ignore keys with length > 1 (e.g., 'Shift', 'ArrowLeft', 'Enter', etc.)
                // Filter out control/meta key combos (e.g., Ctrl+C)
                if (event.key !== 'Unidentified' &&
                    (event.key.length > 1 || event.ctrlKey || event.metaKey || event.altKey)) {
                    return;
                }
                // if this was a character key, we want to open the dropdown
                this.state().openDropdown();
        }
    }
    closeDropdown(event) {
        const relatedTarget = event.relatedTarget;
        // if the blur was caused by focus moving to the dropdown, don't close
        if (relatedTarget &&
            this.state().dropdown()?.elementRef.nativeElement.contains(relatedTarget)) {
            return;
        }
        // if the blur was caused by focus moving to the button, don't close
        if (relatedTarget && this.state().button()?.elementRef.nativeElement.contains(relatedTarget)) {
            return;
        }
        this.state().closeDropdown();
        event.preventDefault();
    }
    /**
     * Focus the input field
     * @internal
     */
    focus() {
        this.elementRef.nativeElement.focus({ preventScroll: true });
    }
    highlightText() {
        if (this.pointerFocused) {
            this.pointerFocused = false;
            return;
        }
        // highlight the text in the input
        this.elementRef.nativeElement.setSelectionRange(0, this.elementRef.nativeElement.value.length);
    }
    handlePointerDown() {
        this.pointerFocused = true;
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxInput, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpComboboxInput, isStandalone: true, selector: "input[ngpComboboxInput]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "combobox", "type": "text", "autocomplete": "off", "autocorrect": "off", "spellcheck": "false", "aria-haspopup": "listbox", "aria-autocomplete": "list" }, listeners: { "keydown": "handleKeydown($event)", "blur": "closeDropdown($event)", "focus": "highlightText($event)", "pointerdown": "handlePointerDown($event)" }, properties: { "id": "id()", "attr.aria-controls": "state().open() ? dropdownId() : undefined", "attr.aria-expanded": "state().open()", "attr.data-open": "state().open() ? \"\" : undefined", "attr.data-disabled": "state().disabled() ? \"\" : undefined", "attr.data-multiple": "state().multiple() ? \"\" : undefined", "attr.aria-activedescendant": "activeDescendant()", "disabled": "state().disabled()" } }, exportAs: ["ngpComboboxInput"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxInput, decorators: [{
            type: Directive,
            args: [{
                    selector: 'input[ngpComboboxInput]',
                    exportAs: 'ngpComboboxInput',
                    host: {
                        role: 'combobox',
                        type: 'text',
                        autocomplete: 'off',
                        autocorrect: 'off',
                        spellcheck: 'false',
                        'aria-haspopup': 'listbox',
                        'aria-autocomplete': 'list',
                        '[id]': 'id()',
                        '[attr.aria-controls]': 'state().open() ? dropdownId() : undefined',
                        '[attr.aria-expanded]': 'state().open()',
                        '[attr.data-open]': 'state().open() ? "" : undefined',
                        '[attr.data-disabled]': 'state().disabled() ? "" : undefined',
                        '[attr.data-multiple]': 'state().multiple() ? "" : undefined',
                        '[attr.aria-activedescendant]': 'activeDescendant()',
                        '[disabled]': 'state().disabled()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handleKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }], closeDropdown: [{
                type: HostListener,
                args: ['blur', ['$event']]
            }], highlightText: [{
                type: HostListener,
                args: ['focus', ['$event']]
            }], handlePointerDown: [{
                type: HostListener,
                args: ['pointerdown', ['$event']]
            }] } });

/**
 * Check if all regular options (excluding 'all' and undefined) are selected.
 * @param options All available options
 * @param selectedValues Currently selected values
 * @param compareWith Comparison function
 * @returns true if all regular options are selected
 */
function areAllOptionsSelected(options, selectedValues, compareWith) {
    const regularOptions = options.filter(opt => opt.value() !== 'all' && opt.value() !== undefined);
    return (regularOptions.length > 0 &&
        regularOptions.every(opt => selectedValues.some(val => compareWith(val, opt.value()))));
}

class NgpComboboxOption {
    constructor() {
        /** Access the combobox state. */
        this.state = injectComboboxState();
        /**
         * The element reference of the option.
         * @internal
         */
        this.elementRef = injectElementRef();
        /** The id of the option. */
        this.id = input(uniqueId('ngp-combobox-option'));
        /** @required The value of the option. */
        this.value = input(undefined, {
            alias: 'ngpComboboxOptionValue',
        });
        /** The disabled state of the option. */
        this.disabled = input(false, {
            alias: 'ngpComboboxOptionDisabled',
            transform: booleanAttribute,
        });
        /**
         * Whether this option is the active descendant.
         * @internal
         */
        this.active = computed(() => this.state().activeDescendantManager.activeDescendant() === this.id());
        /** Whether this option is selected. */
        this.selected = computed(() => {
            const value = this.value();
            const stateValue = this.state().value();
            if (!value) {
                return false;
            }
            // Handle select all functionality - only works in multiple selection mode
            if (value === 'all') {
                if (!this.state().multiple()) {
                    return false; // Never selected in single selection mode
                }
                const selectedValues = Array.isArray(stateValue) ? stateValue : [];
                return areAllOptionsSelected(this.state().options(), selectedValues, this.state().compareWith());
            }
            if (!stateValue) {
                return false;
            }
            if (this.state().multiple()) {
                return (Array.isArray(stateValue) && stateValue.some(v => this.state().compareWith()(value, v)));
            }
            return this.state().compareWith()(value, stateValue);
        });
        this.state().registerOption(this);
        ngpInteractions({
            hover: true,
            press: true,
            disabled: this.disabled,
        });
    }
    ngOnInit() {
        if (this.value() === undefined) {
            throw new Error('ngpComboboxOption: The value input is required. Please provide a value for the option.');
        }
    }
    ngOnDestroy() {
        this.state().unregisterOption(this);
    }
    /**
     * Select the option.
     * @internal
     */
    select() {
        if (this.disabled()) {
            return;
        }
        this.state().toggleOption(this);
    }
    /**
     * Scroll the option into view.
     * @internal
     */
    scrollIntoView() {
        this.elementRef.nativeElement.scrollIntoView({ block: 'nearest' });
    }
    /**
     * Whenever the pointer enters the option, activate it.
     * @internal
     */
    onPointerEnter() {
        this.state().activeDescendantManager.activate(this);
    }
    /**
     * Whenever the pointer leaves the option, deactivate it.
     * @internal
     */
    onPointerLeave() {
        this.state().activeDescendantManager.activate(undefined);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxOption, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpComboboxOption, isStandalone: true, selector: "[ngpComboboxOption]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpComboboxOptionValue", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpComboboxOptionDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "option" }, listeners: { "click": "select()", "pointerenter": "onPointerEnter()", "pointerleave": "onPointerLeave()" }, properties: { "id": "id()", "attr.tabindex": "-1", "attr.aria-selected": "selected() ? \"true\" : undefined", "attr.data-selected": "selected() ? \"\" : undefined", "attr.data-active": "active() ? \"\" : undefined", "attr.data-disabled": "disabled() ? \"\" : undefined" } }, exportAs: ["ngpComboboxOption"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxOption, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpComboboxOption]',
                    exportAs: 'ngpComboboxOption',
                    host: {
                        role: 'option',
                        '[id]': 'id()',
                        '[attr.tabindex]': '-1',
                        '[attr.aria-selected]': 'selected() ? "true" : undefined',
                        '[attr.data-selected]': 'selected() ? "" : undefined',
                        '[attr.data-active]': 'active() ? "" : undefined',
                        '[attr.data-disabled]': 'disabled() ? "" : undefined',
                        '(click)': 'select()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { onPointerEnter: [{
                type: HostListener,
                args: ['pointerenter']
            }], onPointerLeave: [{
                type: HostListener,
                args: ['pointerleave']
            }] } });

class NgpComboboxPortal {
    constructor() {
        /** Access the combobox state. */
        this.state = injectComboboxState();
        /** Access the view container reference. */
        this.viewContainerRef = inject(ViewContainerRef);
        /** Access the template reference. */
        this.templateRef = inject(TemplateRef);
        /** Access the injector. */
        this.injector = inject(Injector);
        /**
         * The overlay that manages the popover
         * @internal
         */
        this.overlay = signal(null);
        this.state().registerPortal(this);
    }
    /** Cleanup the portal. */
    ngOnDestroy() {
        this.overlay()?.destroy();
    }
    /**
     * Attach the portal.
     * @internal
     */
    show() {
        // Create the overlay if it doesn't exist yet
        if (!this.overlay()) {
            this.createOverlay();
        }
        // Show the overlay
        return this.overlay().show();
    }
    /**
     * Detach the portal.
     * @internal
     */
    async detach() {
        this.overlay()?.hide();
    }
    /**
     * Create the overlay that will contain the dropdown
     */
    createOverlay() {
        // Create config for the overlay
        const config = {
            content: this.templateRef,
            viewContainerRef: this.viewContainerRef,
            triggerElement: this.state().elementRef.nativeElement,
            injector: this.injector,
            placement: this.state().placement,
            closeOnOutsideClick: true,
            closeOnEscape: true,
            restoreFocus: false,
            scrollBehaviour: 'reposition',
            container: this.state().container(),
        };
        this.overlay.set(createOverlay(config));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxPortal, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpComboboxPortal, isStandalone: true, selector: "[ngpComboboxPortal]", exportAs: ["ngpComboboxPortal"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpComboboxPortal, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpComboboxPortal]',
                    exportAs: 'ngpComboboxPortal',
                }]
        }], ctorParameters: () => [] });

const defaultComboboxConfig = {
    placement: 'bottom',
    container: 'body',
};
const NgpComboboxConfigToken = new InjectionToken('NgpComboboxConfigToken');
/**
 * Provide the default Combobox configuration
 * @param config The Combobox configuration
 * @returns The provider
 */
function provideComboboxConfig(config) {
    return [
        {
            provide: NgpComboboxConfigToken,
            useValue: { ...defaultComboboxConfig, ...config },
        },
    ];
}
/**
 * Inject the Combobox configuration
 * @returns The global Combobox configuration
 */
function injectComboboxConfig() {
    return inject(NgpComboboxConfigToken, { optional: true }) ?? defaultComboboxConfig;
}

class NgpCombobox {
    constructor() {
        /** Access the combobox configuration. */
        this.config = injectComboboxConfig();
        /** @internal Access the combobox element. */
        this.elementRef = injectElementRef();
        /** Access the injector. */
        this.injector = inject(Injector);
        /** The value of the combobox. */
        this.value = input(undefined, {
            alias: 'ngpComboboxValue',
        });
        /** Event emitted when the value changes. */
        this.valueChange = output({
            alias: 'ngpComboboxValueChange',
        });
        /** Whether the combobox is multiple selection. */
        this.multiple = input(false, {
            alias: 'ngpComboboxMultiple',
            transform: booleanAttribute,
        });
        /** Whether the combobox is disabled. */
        this.disabled = input(false, {
            alias: 'ngpComboboxDisabled',
            transform: booleanAttribute,
        });
        /** Whether the combobox allows deselection in single selection mode. */
        this.allowDeselect = input(false, {
            alias: 'ngpComboboxAllowDeselect',
            transform: booleanAttribute,
        });
        /** Emit when the dropdown open state changes. */
        this.openChange = output({
            alias: 'ngpComboboxOpenChange',
        });
        /** The comparator function used to compare options. */
        this.compareWith = input(Object.is, {
            alias: 'ngpComboboxCompareWith',
        });
        /** The position of the dropdown. */
        this.placement = input(this.config.placement, {
            alias: 'ngpComboboxDropdownPlacement',
        });
        /** The container for the dropdown. */
        this.container = input(this.config.container, {
            alias: 'ngpComboboxDropdownContainer',
        });
        /**
         * Store the combobox input
         * @internal
         */
        this.input = signal(undefined);
        /**
         * Store the combobox button.
         * @internal
         */
        this.button = signal(undefined);
        /**
         * Store the combobox portal.
         * @internal
         */
        this.portal = signal(undefined);
        /**
         * Store the combobox dropdown.
         * @internal
         */
        this.dropdown = signal(undefined);
        /**
         * Store the combobox options.
         * @internal
         */
        this.options = signal([]);
        /**
         * Access the overlay
         * @internal
         */
        this.overlay = computed(() => this.portal()?.overlay());
        /**
         * The open state of the combobox.
         * @internal
         */
        this.open = computed(() => this.overlay()?.isOpen() ?? false);
        /**
         * The active key descendant manager.
         * @internal
         */
        this.activeDescendantManager = activeDescendantManager({
            // we must wrap the signal in a computed to ensure it is not used before it is defined
            disabled: computed(() => this.state.disabled()),
            items: this.options,
        });
        /** The control status */
        this.controlStatus = computed(() => this.input()?.controlStatus());
        /** The state of the combobox. */
        this.state = comboboxState(this);
        ngpInteractions({
            focus: true,
            focusWithin: true,
            hover: true,
            press: true,
            disabled: this.state.disabled,
        });
        // any time the active descendant changes, ensure we scroll it into view
        // perform after next render to ensure the DOM is updated
        // e.g. the dropdown is open before the option is scrolled into view
        afterRenderEffect({
            write: () => {
                const isPositioned = this.portal()?.overlay()?.isPositioned() ?? false;
                const activeItem = this.activeDescendantManager.activeItem();
                if (!isPositioned || !activeItem) {
                    return;
                }
                this.activeDescendantManager.activeItem()?.scrollIntoView?.();
            },
        });
    }
    /**
     * Open the dropdown.
     * @internal
     */
    async openDropdown() {
        if (this.state.disabled() || this.open()) {
            return;
        }
        this.openChange.emit(true);
        await this.portal()?.show();
        // if there is a selected option(s), set the active descendant to the first selected option
        const selectedOption = this.options().find(option => this.isOptionSelected(option));
        // if there is no selected option, set the active descendant to the first option
        const targetOption = selectedOption ?? this.options()[0];
        // if there is no target option, do nothing
        if (!targetOption) {
            return;
        }
        // activate the selected option or the first option
        this.activeDescendantManager.activate(targetOption);
    }
    /**
     * Close the dropdown.
     * @internal
     */
    closeDropdown() {
        if (!this.open()) {
            return;
        }
        this.openChange.emit(false);
        this.portal()?.detach();
        // clear the active descendant
        this.activeDescendantManager.reset();
    }
    /**
     * Toggle the dropdown.
     * @internal
     */
    async toggleDropdown() {
        if (this.open()) {
            this.closeDropdown();
        }
        else {
            await this.openDropdown();
        }
    }
    /**
     * Select an option.
     * @param option The option to select.
     * @internal
     */
    selectOption(option) {
        if (this.state.disabled()) {
            return;
        }
        if (!option) {
            this.state.value.set(undefined);
            this.closeDropdown();
            return;
        }
        // Handle select all functionality - only works in multiple selection mode
        if (option.value() === 'all') {
            if (!this.state.multiple()) {
                return; // Do nothing in single selection mode
            }
            // Get currently visible regular options (respects filtering)
            const regularOptions = this.options().filter(opt => opt.value() !== 'all' && opt.value() !== undefined);
            const allValues = regularOptions.map(opt => opt.value());
            this.state.value.set(allValues);
            this.valueChange.emit(allValues);
            return;
        }
        if (this.state.multiple()) {
            // if the option is already selected, do nothing
            if (this.isOptionSelected(option)) {
                return;
            }
            const value = [...this.state.value(), option.value()];
            // add the option to the value
            this.state.value.set(value);
            this.valueChange.emit(value);
        }
        else {
            this.state.value.set(option.value());
            this.valueChange.emit(option.value());
            // close the dropdown on single selection
            this.closeDropdown();
        }
    }
    /**
     * Deselect an option.
     * @param option The option to deselect.
     * @internal
     */
    deselectOption(option) {
        // if the combobox is disabled or the option is not selected, do nothing
        if (this.state.disabled() || !this.isOptionSelected(option)) {
            return;
        }
        // in single selection mode, only allow deselecting if allowDeselect is true
        if (!this.state.multiple() && !this.state.allowDeselect()) {
            return;
        }
        // Handle select all for deselect all functionality - only works in multiple selection mode
        if (option.value() === 'all') {
            if (!this.state.multiple()) {
                return; // Do nothing in single selection mode
            }
            this.state.value.set([]);
            this.valueChange.emit([]);
            return;
        }
        if (this.state.multiple()) {
            const values = this.state.value() ?? [];
            const newValue = values.filter(v => !this.state.compareWith()(v, option.value()));
            // remove the option from the value
            this.state.value.set(newValue);
            this.valueChange.emit(newValue);
        }
        else {
            // in single selection mode with allowDeselect enabled, set value to undefined
            this.state.value.set(undefined);
            this.valueChange.emit(undefined);
        }
    }
    /**
     * Toggle the selection of an option.
     * @param option The option to toggle.
     * @internal
     */
    toggleOption(option) {
        if (this.state.disabled()) {
            return;
        }
        // Handle select all for select/deselect all functionality - only works in multiple selection mode
        if (option.value() === 'all') {
            if (!this.state.multiple()) {
                return; // Do nothing in single selection mode
            }
            if (this.isOptionSelected(option)) {
                this.deselectOption(option);
            }
            else {
                this.selectOption(option);
            }
            return;
        }
        if (this.state.multiple()) {
            // In multiple selection mode, always allow toggling
            if (this.isOptionSelected(option)) {
                this.deselectOption(option);
            }
            else {
                this.selectOption(option);
            }
        }
        else {
            // In single selection mode, check if deselection is allowed
            if (this.isOptionSelected(option) && this.state.allowDeselect()) {
                // Deselect the option by setting value to undefined
                this.state.value.set(undefined);
                this.valueChange.emit(undefined);
            }
            else {
                // Select the option (works even if already selected to update the input)
                this.selectOption(option);
            }
        }
    }
    /**
     * Determine if an option is selected.
     * @param option The option to check.
     * @internal
     */
    isOptionSelected(option) {
        if (this.state.disabled()) {
            return false;
        }
        const optionValue = option.value();
        const value = this.state.value();
        // Handle select all functionality - only works in multiple selection mode
        if (optionValue === 'all') {
            if (!this.state.multiple()) {
                return false; // Never selected in single selection mode
            }
            const selectedValues = Array.isArray(value) ? value : [];
            return areAllOptionsSelected(this.options(), selectedValues, this.state.compareWith());
        }
        if (!value) {
            return false;
        }
        if (this.state.multiple()) {
            return value && value.some(v => this.state.compareWith()(optionValue, v));
        }
        return this.state.compareWith()(optionValue, value);
    }
    /**
     * Activate the next option in the list if there is one.
     * If there is no option currently active, activate the selected option or the first option.
     * @internal
     */
    activateNextOption() {
        if (this.state.disabled()) {
            return;
        }
        const options = this.options();
        // if there are no options, do nothing
        if (options.length === 0) {
            return;
        }
        // if there is no active option, activate the first option
        if (!this.activeDescendantManager.activeItem()) {
            const selectedOption = options.find(option => this.isOptionSelected(option));
            // if there is a selected option(s), set the active descendant to the first selected option
            const targetOption = selectedOption ?? options[0];
            this.activeDescendantManager.activate(targetOption);
            return;
        }
        // otherwise activate the next option
        this.activeDescendantManager.next();
    }
    /**
     * Activate the previous option in the list if there is one.
     * @internal
     */
    activatePreviousOption() {
        if (this.state.disabled()) {
            return;
        }
        const options = this.options();
        // if there are no options, do nothing
        if (options.length === 0) {
            return;
        }
        // if there is no active option, activate the last option
        if (!this.activeDescendantManager.activeItem()) {
            const selectedOption = options.find(option => this.isOptionSelected(option));
            // if there is a selected option(s), set the active descendant to the first selected option
            const targetOption = selectedOption ?? options[options.length - 1];
            this.activeDescendantManager.activate(targetOption);
            return;
        }
        // otherwise activate the previous option
        this.activeDescendantManager.previous();
    }
    /**
     * Register the dropdown portal with the combobox.
     * @param portal The dropdown portal.
     * @internal
     */
    registerPortal(portal) {
        this.portal.set(portal);
    }
    /**
     * Register the combobox input with the combobox.
     * @param input The combobox input.
     * @internal
     */
    registerInput(input) {
        this.input.set(input);
    }
    /**
     * Register the combobox button with the combobox.
     * @param button The combobox button.
     * @internal
     */
    registerButton(button) {
        this.button.set(button);
    }
    /**
     * Register the dropdown with the combobox.
     * @param dropdown The dropdown to register.
     * @internal
     */
    registerDropdown(dropdown) {
        this.dropdown.set(dropdown);
    }
    /**
     * Register an option with the combobox.
     * @param option The option to register.
     * @internal
     */
    registerOption(option) {
        this.options.update(options => [...options, option]);
    }
    /**
     * Unregister an option from the combobox.
     * @param option The option to unregister.
     * @internal
     */
    unregisterOption(option) {
        this.options.update(options => options.filter(o => o !== option));
    }
    /**
     * Focus the combobox.
     * When an input element is present, it will be focused.
     * Otherwise, the combobox element itself will be focused.
     * This enables keyboard navigation for comboboxes without input elements.
     * @internal
     */
    focus() {
        if (this.input()) {
            this.input()?.focus();
        }
        else {
            this.elementRef.nativeElement.focus();
        }
    }
    /**
     * Handle keydown events for keyboard navigation and accessibility.
     * Supports:
     * - Arrow Down: Open dropdown or navigate to next option
     * - Arrow Up: Open dropdown or navigate to previous option
     * - Home: Navigate to first option
     * - End: Navigate to last option
     * - Enter: Select the currently active option
     * - Escape: Close the dropdown
     * @param event - The keyboard event
     * @internal
     */
    handleKeydown(event) {
        // If the event originated from the input element, let the input handle it
        if (this.input() && event.target === this.input()?.elementRef.nativeElement) {
            return;
        }
        switch (event.key) {
            case 'ArrowDown':
                if (this.open()) {
                    this.activateNextOption();
                }
                else {
                    this.openDropdown();
                }
                event.preventDefault();
                break;
            case 'ArrowUp':
                if (this.open()) {
                    this.activatePreviousOption();
                }
                else {
                    this.openDropdown();
                    // Use setTimeout to ensure dropdown is rendered before selecting last item
                    setTimeout(() => this.activeDescendantManager.last());
                }
                event.preventDefault();
                break;
            case 'Home':
                if (this.open()) {
                    this.activeDescendantManager.first();
                }
                event.preventDefault();
                break;
            case 'End':
                if (this.open()) {
                    this.activeDescendantManager.last();
                }
                event.preventDefault();
                break;
            case 'Enter':
                if (this.open()) {
                    const activeItem = this.activeDescendantManager.activeItem();
                    if (activeItem) {
                        this.toggleOption(activeItem);
                    }
                }
                event.preventDefault();
                break;
            case 'Escape':
                if (this.open()) {
                    this.closeDropdown();
                }
                event.preventDefault();
                break;
            case ' ':
                if (!this.input()) {
                    this.toggleDropdown();
                    event.preventDefault();
                }
                break;
        }
    }
    /**
     * Handle blur events to manage dropdown closing behavior.
     * The dropdown will remain open if focus moves to:
     * - The dropdown itself
     * - The combobox button
     * - The combobox input
     * Otherwise, the dropdown will be closed.
     * @param event - The focus event
     * @internal
     */
    onBlur(event) {
        const relatedTarget = event.relatedTarget;
        // if the blur was caused by focus moving to the dropdown, don't close
        if (relatedTarget && this.dropdown()?.elementRef.nativeElement.contains(relatedTarget)) {
            return;
        }
        // if the blur was caused by focus moving to the button, don't close
        if (relatedTarget && this.button()?.elementRef.nativeElement.contains(relatedTarget)) {
            return;
        }
        // if the blur was caused by focus moving to the input, don't close
        if (relatedTarget && this.input()?.elementRef.nativeElement === relatedTarget) {
            return;
        }
        this.closeDropdown();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpCombobox, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpCombobox, isStandalone: true, selector: "[ngpCombobox]", inputs: { value: { classPropertyName: "value", publicName: "ngpComboboxValue", isSignal: true, isRequired: false, transformFunction: null }, multiple: { classPropertyName: "multiple", publicName: "ngpComboboxMultiple", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpComboboxDisabled", isSignal: true, isRequired: false, transformFunction: null }, allowDeselect: { classPropertyName: "allowDeselect", publicName: "ngpComboboxAllowDeselect", isSignal: true, isRequired: false, transformFunction: null }, compareWith: { classPropertyName: "compareWith", publicName: "ngpComboboxCompareWith", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpComboboxDropdownPlacement", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "ngpComboboxDropdownContainer", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { valueChange: "ngpComboboxValueChange", openChange: "ngpComboboxOpenChange" }, host: { listeners: { "keydown": "handleKeydown($event)", "blur": "onBlur($event)" }, properties: { "attr.tabindex": "input() ? -1 : (state.disabled() ? -1 : 0)", "attr.data-open": "state.open() ? \"\" : undefined", "attr.data-disabled": "state.disabled() ? \"\" : undefined", "attr.data-multiple": "state.multiple() ? \"\" : undefined", "attr.data-invalid": "controlStatus()?.invalid ? \"\" : undefined", "attr.data-valid": "controlStatus()?.valid ? \"\" : undefined", "attr.data-touched": "controlStatus()?.touched ? \"\" : undefined", "attr.data-pristine": "controlStatus()?.pristine ? \"\" : undefined", "attr.data-dirty": "controlStatus()?.dirty ? \"\" : undefined", "attr.data-pending": "controlStatus()?.pending ? \"\" : undefined" } }, providers: [provideComboboxState()], exportAs: ["ngpCombobox"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpCombobox, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpCombobox]',
                    exportAs: 'ngpCombobox',
                    providers: [provideComboboxState()],
                    host: {
                        '[attr.tabindex]': 'input() ? -1 : (state.disabled() ? -1 : 0)',
                        '[attr.data-open]': 'state.open() ? "" : undefined',
                        '[attr.data-disabled]': 'state.disabled() ? "" : undefined',
                        '[attr.data-multiple]': 'state.multiple() ? "" : undefined',
                        '[attr.data-invalid]': 'controlStatus()?.invalid ? "" : undefined',
                        '[attr.data-valid]': 'controlStatus()?.valid ? "" : undefined',
                        '[attr.data-touched]': 'controlStatus()?.touched ? "" : undefined',
                        '[attr.data-pristine]': 'controlStatus()?.pristine ? "" : undefined',
                        '[attr.data-dirty]': 'controlStatus()?.dirty ? "" : undefined',
                        '[attr.data-pending]': 'controlStatus()?.pending ? "" : undefined',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { handleKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }], onBlur: [{
                type: HostListener,
                args: ['blur', ['$event']]
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpCombobox, NgpComboboxButton, NgpComboboxDropdown, NgpComboboxInput, NgpComboboxOption, NgpComboboxPortal, injectComboboxState, provideComboboxConfig, provideComboboxState };
//# sourceMappingURL=ng-primitives-combobox.mjs.map
