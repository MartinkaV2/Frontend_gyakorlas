import { NG_VALUE_ACCESSOR, NgControl } from '@angular/forms';
import { inject, DestroyRef, signal, afterNextRender, afterRenderEffect, effect, untracked } from '@angular/core';
import { takeUntilDestroyed } from '@angular/core/rxjs-interop';
import { pipe, NEVER, EMPTY } from 'rxjs';
import { takeUntil, catchError, defaultIfEmpty } from 'rxjs/operators';

/**
 * A simple helper function to provide a value accessor for a given type.
 * @param type The type to provide the value accessor for
 */
function provideValueAccessor(type) {
    return { provide: NG_VALUE_ACCESSOR, useExisting: type, multi: true };
}

/**
 * The built-in `takeUntilDestroyed` operator does not handle the case when the component is destroyed before the source observable emits.
 * This operator ensures that the source observable completes gracefully without throwing an error.
 * https://github.com/angular/angular/issues/54527#issuecomment-2098254508
 *
 * @internal
 */
function safeTakeUntilDestroyed(destroyRef) {
    return pipe(takeUntil(NEVER.pipe(takeUntilDestroyed(destroyRef), catchError(() => EMPTY), defaultIfEmpty(null))));
}

function setStatusSignal(control, status) {
    if (!control?.control) {
        return;
    }
    status.set({
        valid: control?.control?.valid ?? null,
        invalid: control?.control?.invalid ?? null,
        pristine: control?.control?.pristine ?? null,
        dirty: control?.control?.dirty ?? null,
        touched: control?.control?.touched ?? null,
        pending: control?.control?.pending ?? null,
        disabled: control?.control?.disabled ?? null,
    });
}
function subscribeToControlStatus(control, status, destroyRef) {
    if (!control?.control) {
        return;
    }
    control.control.events
        .pipe(safeTakeUntilDestroyed(destroyRef))
        .subscribe(() => setStatusSignal(control, status));
}
/**
 * A utility function to get the status of an Angular form control as a reactive signal.
 * This function injects the NgControl and returns a signal that reflects the control's status.
 * @internal
 */
function controlStatus() {
    const control = inject(NgControl, { optional: true });
    const destroyRef = inject(DestroyRef);
    const status = signal({
        valid: null,
        invalid: null,
        pristine: null,
        dirty: null,
        touched: null,
        pending: null,
        disabled: null,
    });
    // Fallback if control is not yet available
    if (!control?.control) {
        // There is still a chance that the control will be available i.e. after executing OnInit lifecycle hook
        // in `formControlName` directive, so we set up an effect to subscribe to the control status
        afterNextRender({
            write: () => {
                // If control is still not available, we do nothing, otherwise we subscribe to the control status
                if (control?.control) {
                    subscribeToControlStatus(control, status, destroyRef);
                    // We re-set the status to ensure it reflects the current state on initialization
                    setStatusSignal(control, status);
                }
            },
        });
        return status;
    }
    subscribeToControlStatus(control, status);
    return status;
}

function booleanAttributeBinding(element, attribute, value) {
    if (!value) {
        return;
    }
    afterRenderEffect({
        write: () => value() ? element.setAttribute(attribute, '') : element.removeAttribute(attribute),
    });
}

/**
 * Disposable functions are a way to manage timers, intervals, and event listeners
 * that should be cleared when a component is destroyed.
 *
 * This is heavily inspired by Headless UI disposables:
 * https://github.com/tailwindlabs/headlessui/blob/main/packages/%40headlessui-react/src/utils/disposables.ts
 */
function injectDisposables() {
    const destroyRef = inject(DestroyRef);
    let isDestroyed = false;
    destroyRef.onDestroy(() => (isDestroyed = true));
    return {
        /**
         * Set a timeout that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @param delay The delay before the callback is executed
         * @returns A function to clear the timeout
         */
        setTimeout: (callback, delay) => {
            if (isDestroyed) {
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                return () => { };
            }
            const id = setTimeout(callback, delay);
            const cleanup = () => clearTimeout(id);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
        /**
         * Set an interval that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @param delay The delay before the callback is executed
         * @param target
         * @param type
         * @param listener
         * @param options
         * @returns A function to clear the interval
         */
        addEventListener: (target, type, 
        // eslint-disable-next-line @typescript-eslint/no-explicit-any
        listener, options) => {
            if (isDestroyed) {
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                return () => { };
            }
            target.addEventListener(type, listener, options);
            const cleanup = () => target.removeEventListener(type, listener, options);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
        /**
         * Set an interval that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @param delay The delay before the callback is executed
         * @returns A function to clear the interval
         */
        setInterval: (callback, delay) => {
            if (isDestroyed) {
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                return () => { };
            }
            const id = setInterval(callback, delay);
            const cleanup = () => clearInterval(id);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
        /**
         * Set a requestAnimationFrame that will be cleared when the component is destroyed.
         * @param callback The callback to execute
         * @returns A function to clear the requestAnimationFrame
         */
        requestAnimationFrame: (callback) => {
            if (isDestroyed) {
                // eslint-disable-next-line @typescript-eslint/no-empty-function
                return () => { };
            }
            const id = requestAnimationFrame(callback);
            const cleanup = () => cancelAnimationFrame(id);
            destroyRef.onDestroy(cleanup);
            return cleanup;
        },
    };
}

/**
 * Store a map of unique ids for elements so that there are no collisions.
 */
const uniqueIdMap = new Map();
/**
 * Generate a unique id for an element
 * @param prefix - The prefix to use for the id
 * @returns The generated id
 */
function uniqueId(prefix) {
    const id = uniqueIdMap.get(prefix) ?? 0;
    uniqueIdMap.set(prefix, id + 1);
    return `${prefix}-${id}`;
}

/**
 * Type validation utilities
 */
/**
 * Checks if a value is a string
 * @param value - The value to check
 * @returns true if the value is a string, false otherwise
 */
function isString(value) {
    return typeof value === 'string';
}
/**
 * Checks if a value is a number
 * @param value - The value to check
 * @returns true if the value is a number, false otherwise
 */
function isNumber(value) {
    return typeof value === 'number';
}
/**
 * Checks if a value is a boolean
 * @param value - The value to check
 * @returns true if the value is a boolean, false otherwise
 */
function isBoolean(value) {
    return typeof value === 'boolean';
}
/**
 * Checks if a value is a function
 * @param value - The value to check
 * @returns true if the value is a function, false otherwise
 */
function isFunction(value) {
    return typeof value === 'function';
}
/**
 * Checks if a value is a plain object (but not null or array)
 * @param value - The value to check
 * @returns true if the value is a plain object, false otherwise
 */
function isObject(value) {
    return !!value && typeof value === 'object' && !Array.isArray(value);
}
/**
 * Checks if a value is undefined
 * @param value - The value to check
 * @returns true if the value is undefined, false otherwise
 */
function isUndefined(value) {
    return typeof value === 'undefined';
}

/**
 * Listen for changes to a signal and call a function when the signal changes.
 * @param source
 * @param fn
 * @param options
 * @param options.injector
 * @internal
 */
function onChange(source, fn, options) {
    const previousValue = signal(source());
    effect(() => {
        const value = source();
        if (value !== previousValue()) {
            untracked(() => fn(value, previousValue()));
            previousValue.set(value);
        }
    }, { injector: options?.injector });
    // call the fn with the initial value
    fn(source(), null);
}
/**
 * Listen for changes to a boolean signal and call one of two functions when the signal changes.
 * @param source
 * @param onTrue
 * @param onFalse
 * @param options
 */
function onBooleanChange(source, onTrue, onFalse, options) {
    onChange(source, value => (value ? onTrue?.() : onFalse?.()), options);
}

/**
 * Generated bundle index. Do not edit.
 */

export { booleanAttributeBinding, controlStatus, injectDisposables, isBoolean, isFunction, isNumber, isObject, isString, isUndefined, onBooleanChange, onChange, provideValueAccessor, safeTakeUntilDestroyed, uniqueId };
//# sourceMappingURL=ng-primitives-utils.mjs.map
