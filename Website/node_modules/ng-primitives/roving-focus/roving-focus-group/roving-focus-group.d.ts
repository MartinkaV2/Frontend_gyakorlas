import { FocusOrigin } from '@angular/cdk/a11y';
import { BooleanInput } from '@angular/cdk/coercion';
import { NgpOrientation } from 'ng-primitives/common';
import { NgpRovingFocusItem } from '../roving-focus-item/roving-focus-item';
import * as i0 from "@angular/core";
/**
 * Apply the `ngpRovingFocusGroup` directive to an element to manage focus for a group of child elements.
 */
export declare class NgpRovingFocusGroup {
    /**
     * Access the directionality service.
     */
    private readonly directionality;
    /**
     * Determine the orientation of the roving focus group.
     * @default 'vertical'
     */
    readonly orientation: import("@angular/core").InputSignal<NgpOrientation>;
    /**
     * Determine if focus should wrap when the end or beginning is reached.
     */
    readonly wrap: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Determine if the home and end keys should navigate to the first and last items.
     */
    readonly homeEnd: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Determine if the roving focus group is disabled.
     */
    readonly disabled: import("@angular/core").InputSignalWithTransform<boolean, BooleanInput>;
    /**
     * Store the items in the roving focus group.
     */
    private readonly items;
    /**
     * Get the items in the roving focus group sorted by order.
     */
    private get sortedItems();
    /**
     * Store the active item in the roving focus group.
     * @internal
     */
    readonly activeItem: import("@angular/core").WritableSignal<NgpRovingFocusItem | null>;
    /**
     * The state of the roving focus group.
     */
    readonly state: import("ng-primitives/state").CreatedState<NgpRovingFocusGroup>;
    /**
     * Register an item with the roving focus group.
     * @param item The item to register
     * @internal
     */
    register(item: NgpRovingFocusItem): void;
    /**
     * Unregister an item with the roving focus group.
     * @param item The item to unregister
     * @internal
     */
    unregister(item: NgpRovingFocusItem): void;
    /**
     * Activate an item in the roving focus group.
     * @param item The item to activate
     * @param origin The origin of the focus change
     */
    setActiveItem(item: NgpRovingFocusItem | null, origin?: FocusOrigin): void;
    /**
     * Activate the first item in the roving focus group.
     * @param origin The origin of the focus change
     */
    private activateFirstItem;
    /**
     * Activate the last item in the roving focus group.
     * @param origin The origin of the focus change
     */
    private activateLastItem;
    /**
     * Activate the next item in the roving focus group.
     * @param origin The origin of the focus change
     */
    private activateNextItem;
    /**
     * Activate the previous item in the roving focus group.
     * @param origin The origin of the focus change
     */
    private activatePreviousItem;
    /**
     * Handle keyboard navigation for the roving focus group.
     * @param event The keyboard event
     * @internal
     */
    onKeydown(event: KeyboardEvent): void;
    static ɵfac: i0.ɵɵFactoryDeclaration<NgpRovingFocusGroup, never>;
    static ɵdir: i0.ɵɵDirectiveDeclaration<NgpRovingFocusGroup, "[ngpRovingFocusGroup]", ["ngpRovingFocusGroup"], { "orientation": { "alias": "ngpRovingFocusGroupOrientation"; "required": false; "isSignal": true; }; "wrap": { "alias": "ngpRovingFocusGroupWrap"; "required": false; "isSignal": true; }; "homeEnd": { "alias": "ngpRovingFocusGroupHomeEnd"; "required": false; "isSignal": true; }; "disabled": { "alias": "ngpRovingFocusGroupDisabled"; "required": false; "isSignal": true; }; }, {}, never, never, true, never>;
}
