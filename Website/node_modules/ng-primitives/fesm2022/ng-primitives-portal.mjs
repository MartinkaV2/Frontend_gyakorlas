import { FocusMonitor } from '@angular/cdk/a11y';
import { ViewportRuler } from '@angular/cdk/overlay';
import { DOCUMENT } from '@angular/common';
import { InjectionToken, inject, TemplateRef, DestroyRef, signal, computed, Injector, runInInjectionContext, afterRenderEffect } from '@angular/core';
import { autoUpdate, offset, shift, flip, arrow, computePosition } from '@floating-ui/dom';
import { setupExitAnimation, explicitEffect, fromResizeEvent, injectElementRef } from 'ng-primitives/internal';
import { isObject, isFunction, injectDisposables, uniqueId, safeTakeUntilDestroyed, isNil } from 'ng-primitives/utils';
import { Subject, fromEvent } from 'rxjs';
import { VERSION } from '@angular/cdk';
import { ComponentPortal, DomPortalOutlet, TemplatePortal } from '@angular/cdk/portal';
import { coerceCssPixelValue, coerceNumberProperty } from '@angular/cdk/coercion';

const NgpOverlayContextToken = new InjectionToken('NgpOverlayContextToken');
/**
 * Injects the context for the overlay.
 * @internal
 */
function injectOverlayContext() {
    return inject(NgpOverlayContextToken);
}
/**
 * Provides the context for the overlay.
 * @param value The value to provide as the context.
 * @internal
 */
function provideOverlayContext(value) {
    return { provide: NgpOverlayContextToken, useValue: value };
}

class NgpPortal {
    constructor(viewContainerRef, injector) {
        this.viewContainerRef = viewContainerRef;
        this.injector = injector;
    }
    /**
     * Angular v20 removes `_unusedComponentFactoryResolver` and `_document` from DomPortalOutlet's
     * constructor signature as they have been deprecated since v18, and replaced with optional
     * `_appRef` and `_defaultInjector` params.
     * This temporary change ensures consistent behaviour for consumers using ng v20+.
     * @see {@link https://github.com/angular/components/pull/24504 The implementing PR} for the new implementation.
     * @see {@link https://github.com/angular/components/blob/732a0d7ab69ec25925cc06a0fb17b0fb16a4b0ae/src/cdk/portal/dom-portal-outlet.ts#L27 The latest v20 version comments}
     * describe the importance of passing the `_appRef` and `_defaultInjector` when it comes to component portals
     */
    // todo: remove this compat fix once support for v19 is dropped when v21 is released
    //  - should aim to add appRef also to prevent unforeseen issues in certain edge cases
    // eslint-disable-next-line @typescript-eslint/no-explicit-any
    _getDomPortalOutletCtorParamsCompat() {
        return Number(VERSION.major) >= 20 ? [this.injector] : [undefined, this.injector];
    }
}
class NgpComponentPortal extends NgpPortal {
    constructor(component, viewContainerRef, injector) {
        super(viewContainerRef, injector);
        this.viewRef = null;
        this.isDestroying = false;
        this.exitAnimationRef = null;
        this.componentPortal = new ComponentPortal(component, viewContainerRef, injector);
    }
    /**
     * Attach the portal to a DOM element.
     * @param container The DOM element to attach the portal to.
     */
    attach(container) {
        const domOutlet = new DomPortalOutlet(container, undefined, ...this._getDomPortalOutletCtorParamsCompat());
        this.viewRef = domOutlet.attach(this.componentPortal);
        const element = this.viewRef.location.nativeElement;
        this.exitAnimationRef = setupExitAnimation({ element });
        return this;
    }
    /**
     * Get the root elements of the portal.
     */
    getElements() {
        return this.viewRef ? [this.viewRef.location.nativeElement] : [];
    }
    /**
     * Detect changes in the portal.
     */
    detectChanges() {
        this.viewRef?.changeDetectorRef.detectChanges();
    }
    /**
     * Whether the portal is attached to a DOM element.
     */
    getAttached() {
        return !!this.viewRef && this.viewRef.location.nativeElement.isConnected;
    }
    /**
     * Detach the portal from the DOM.
     */
    async detach() {
        if (this.isDestroying) {
            return;
        }
        this.isDestroying = true;
        // if there is an exit animation manager, wait for it to finish
        await this.exitAnimationRef?.exit();
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
class NgpTemplatePortal extends NgpPortal {
    constructor(template, viewContainerRef, injector, context) {
        super(viewContainerRef, injector);
        this.viewRef = null;
        this.exitAnimationRefs = [];
        this.isDestroying = false;
        this.templatePortal = new TemplatePortal(template, viewContainerRef, context, injector);
    }
    /**
     * Attach the portal to a DOM element.
     * @param container The DOM element to attach the portal to.
     */
    attach(container) {
        const domOutlet = new DomPortalOutlet(container, undefined, ...this._getDomPortalOutletCtorParamsCompat());
        this.viewRef = domOutlet.attach(this.templatePortal);
        for (const rootNode of this.viewRef.rootNodes) {
            if (rootNode instanceof HTMLElement) {
                // Setup exit animation for each root node
                const exitAnimationRef = setupExitAnimation({ element: rootNode });
                this.exitAnimationRefs.push(exitAnimationRef);
            }
        }
        return this;
    }
    /**
     * Get the root elements of the portal.
     */
    getElements() {
        return this.viewRef ? this.viewRef.rootNodes : [];
    }
    /**
     * Detect changes in the portal.
     */
    detectChanges() {
        this.viewRef?.detectChanges();
    }
    /**
     * Whether the portal is attached to a DOM element.
     */
    getAttached() {
        return !!this.viewRef && this.viewRef.rootNodes.length > 0;
    }
    /**
     * Detach the portal from the DOM.
     */
    async detach() {
        if (this.isDestroying) {
            return;
        }
        this.isDestroying = true;
        // if there is an exit animation manager, wait for it to finish
        await Promise.all(this.exitAnimationRefs.map(ref => ref.exit()));
        if (this.viewRef) {
            this.viewRef.destroy();
            this.viewRef = null;
        }
    }
}
function createPortal(componentOrTemplate, viewContainerRef, injector, context) {
    if (componentOrTemplate instanceof TemplateRef) {
        return new NgpTemplatePortal(componentOrTemplate, viewContainerRef, injector, context);
    }
    else {
        return new NgpComponentPortal(componentOrTemplate, viewContainerRef, injector);
    }
}

/**
 * This code is largely based on the CDK Overlay's scroll strategy implementation, however it
 * has been modified so that it does not rely on the CDK's global overlay styles.
 */
/** Cached result of the check that indicates whether the browser supports scroll behaviors. */
let scrollBehaviorSupported;
function supportsScrollBehavior() {
    if (scrollBehaviorSupported != null) {
        return scrollBehaviorSupported;
    }
    // If we're not in the browser, it can't be supported. Also check for `Element`, because
    // some projects stub out the global `document` during SSR which can throw us off.
    if (!isObject(document) || !document || !isFunction(Element) || !Element) {
        return (scrollBehaviorSupported = false);
    }
    // If the element can have a `scrollBehavior` style, we can be sure that it's supported.
    if ('scrollBehavior' in document.documentElement.style) {
        return (scrollBehaviorSupported = true);
    }
    // Check if scrollTo is supported and if it's been polyfilled
    const scrollToFunction = Element.prototype.scrollTo;
    if (!scrollToFunction) {
        return (scrollBehaviorSupported = false);
    }
    // We can detect if the function has been polyfilled by calling `toString` on it. Native
    // functions are obfuscated using `[native code]`, whereas if it was overwritten we'd get
    // the actual function source. Via https://davidwalsh.name/detect-native-function. Consider
    // polyfilled functions as supporting scroll behavior.
    return (scrollBehaviorSupported = !/\{\s*\[native code\]\s*\}/.test(scrollToFunction.toString()));
}
class BlockScrollStrategy {
    constructor(viewportRuler, document) {
        this.viewportRuler = viewportRuler;
        this.document = document;
        this.previousHTMLStyles = {
            top: '',
            left: '',
            position: '',
            overflowY: '',
            width: '',
        };
        this.previousScrollPosition = { top: 0, left: 0 };
        this.isEnabled = false;
    }
    /** Blocks page-level scroll while the attached overlay is open. */
    enable() {
        if (this.canBeEnabled()) {
            const root = this.document.documentElement;
            this.previousScrollPosition = this.viewportRuler.getViewportScrollPosition();
            // Cache the previous inline styles in case the user had set them.
            this.previousHTMLStyles.left = root.style.left || '';
            this.previousHTMLStyles.top = root.style.top || '';
            this.previousHTMLStyles.position = root.style.position || '';
            this.previousHTMLStyles.overflowY = root.style.overflowY || '';
            this.previousHTMLStyles.width = root.style.width || '';
            // Set the styles to block scrolling.
            root.style.position = 'fixed';
            // Necessary for the content not to lose its width. Note that we're using 100%, instead of
            // 100vw, because 100vw includes the width plus the scrollbar, whereas 100% is the width
            // that the element had before we made it `fixed`.
            root.style.width = '100%';
            // Note: this will always add a scrollbar to whatever element it is on, which can
            // potentially result in double scrollbars. It shouldn't be an issue, because we won't
            // block scrolling on a page that doesn't have a scrollbar in the first place.
            root.style.overflowY = 'scroll';
            // Note: we're using the `html` node, instead of the `body`, because the `body` may
            // have the user agent margin, whereas the `html` is guaranteed not to have one.
            root.style.left = coerceCssPixelValue(-this.previousScrollPosition.left);
            root.style.top = coerceCssPixelValue(-this.previousScrollPosition.top);
            root.setAttribute('data-scrollblock', '');
            this.isEnabled = true;
        }
    }
    /** Unblocks page-level scroll while the attached overlay is open. */
    disable() {
        if (this.isEnabled) {
            const html = this.document.documentElement;
            const body = this.document.body;
            const htmlStyle = html.style;
            const bodyStyle = body.style;
            const previousHtmlScrollBehavior = htmlStyle.scrollBehavior || '';
            const previousBodyScrollBehavior = bodyStyle.scrollBehavior || '';
            this.isEnabled = false;
            htmlStyle.left = this.previousHTMLStyles.left;
            htmlStyle.top = this.previousHTMLStyles.top;
            htmlStyle.position = this.previousHTMLStyles.position;
            htmlStyle.overflowY = this.previousHTMLStyles.overflowY;
            htmlStyle.width = this.previousHTMLStyles.width;
            html.removeAttribute('data-scrollblock');
            // Disable user-defined smooth scrolling temporarily while we restore the scroll position.
            // See https://developer.mozilla.org/en-US/docs/Web/CSS/scroll-behavior
            // Note that we don't mutate the property if the browser doesn't support `scroll-behavior`,
            // because it can throw off feature detections in `supportsScrollBehavior` which
            // checks for `'scrollBehavior' in documentElement.style`.
            if (scrollBehaviorSupported) {
                htmlStyle.scrollBehavior = bodyStyle.scrollBehavior = 'auto';
            }
            window.scroll(this.previousScrollPosition.left, this.previousScrollPosition.top);
            if (scrollBehaviorSupported) {
                htmlStyle.scrollBehavior = previousHtmlScrollBehavior;
                bodyStyle.scrollBehavior = previousBodyScrollBehavior;
            }
        }
    }
    canBeEnabled() {
        // Since the scroll strategies can't be singletons, we have to use a global CSS class
        // (`cdk-global-scrollblock`) to make sure that we don't try to disable global
        // scrolling multiple times.
        const html = this.document.documentElement;
        if (html.classList.contains('cdk-global-scrollblock') || this.isEnabled) {
            return false;
        }
        const viewport = this.viewportRuler.getViewportSize();
        return html.scrollHeight > viewport.height || html.scrollWidth > viewport.width;
    }
}
class NoopScrollStrategy {
    enable() {
        // No operation for enabling
    }
    disable() {
        // No operation for disabling
    }
}

/**
 * NgpOverlay manages the lifecycle and positioning of overlay UI elements.
 * It abstracts the common behavior shared by tooltips, popovers, menus, etc.
 * @internal
 */
class NgpOverlay {
    /**
     * Creates a new overlay instance
     * @param config Initial configuration for the overlay
     * @param destroyRef Reference for automatic cleanup
     */
    constructor(config) {
        this.config = config;
        this.disposables = injectDisposables();
        this.document = inject(DOCUMENT);
        this.destroyRef = inject(DestroyRef);
        this.viewportRuler = inject(ViewportRuler);
        this.focusMonitor = inject(FocusMonitor);
        /** Access any parent overlays */
        this.parentOverlay = inject(NgpOverlay, { optional: true });
        /** Signal tracking the portal instance */
        this.portal = signal(null);
        /** Signal tracking the overlay position */
        this.position = signal({
            x: undefined,
            y: undefined,
        });
        /**
         * Determine if the overlay has been positioned
         * @internal
         */
        this.isPositioned = computed(() => this.position().x !== undefined && this.position().y !== undefined);
        /** Signal tracking the trigger element width */
        this.triggerWidth = signal(null);
        /** The transform origin for the overlay */
        this.transformOrigin = signal('center center');
        /** Signal tracking the final placement of the overlay */
        this.finalPlacement = signal(undefined);
        /** Signal tracking whether the overlay is open */
        this.isOpen = signal(false);
        /** A unique id for the overlay */
        this.id = signal(uniqueId('ngp-overlay'));
        /** The aria-describedby attribute for accessibility */
        this.ariaDescribedBy = computed(() => (this.isOpen() ? this.id() : undefined));
        /** The scroll strategy */
        this.scrollStrategy = new NoopScrollStrategy();
        /** An observable that emits when the overlay is closing */
        this.closing = new Subject();
        /** Store the arrow element */
        this.arrowElement = null;
        /** @internal The position of the arrow */
        this.arrowPosition = signal({
            x: undefined,
            y: undefined,
        });
        // we cannot inject the viewContainerRef as this can throw an error during hydration in SSR
        this.viewContainerRef = config.viewContainerRef;
        // Listen for placement signal changes to update position
        if (config.placement) {
            explicitEffect([config.placement], () => this.updatePosition());
        }
        // this must be done after the config is set
        this.transformOrigin.set(this.getTransformOrigin());
        // Monitor trigger element resize
        const elementToMonitor = this.config.anchorElement || this.config.triggerElement;
        fromResizeEvent(elementToMonitor)
            .pipe(safeTakeUntilDestroyed(this.destroyRef))
            .subscribe(({ width, height }) => {
            this.triggerWidth.set(width);
            // if the element has been hidden, hide immediately
            if (width === 0 || height === 0) {
                this.hideImmediate();
            }
        });
        // if there is a parent overlay and it is closed, close this overlay
        this.parentOverlay?.closing.pipe(safeTakeUntilDestroyed(this.destroyRef)).subscribe(() => {
            if (this.isOpen()) {
                this.hideImmediate();
            }
        });
        // If closeOnOutsideClick is enabled, set up a click listener
        fromEvent(this.document, 'mouseup', { capture: true })
            .pipe(safeTakeUntilDestroyed(this.destroyRef))
            .subscribe(event => {
            if (!this.config.closeOnOutsideClick) {
                return;
            }
            const overlay = this.portal();
            if (!overlay || !this.isOpen()) {
                return;
            }
            const path = event.composedPath();
            const isInsideOverlay = overlay.getElements().some(el => path.includes(el));
            const isInsideTrigger = path.includes(this.config.triggerElement);
            const isInsideAnchor = this.config.anchorElement
                ? path.includes(this.config.anchorElement)
                : false;
            if (!isInsideOverlay && !isInsideTrigger && !isInsideAnchor) {
                this.hide();
            }
        });
        // If closeOnEscape is enabled, set up a keydown listener
        fromEvent(this.document, 'keydown', { capture: true })
            .pipe(safeTakeUntilDestroyed(this.destroyRef))
            .subscribe(event => {
            if (!this.config.closeOnEscape)
                return;
            if (event.key === 'Escape' && this.isOpen()) {
                this.hide({ origin: 'keyboard', immediate: true });
            }
        });
        // Ensure cleanup on destroy
        this.destroyRef.onDestroy(() => this.destroy());
    }
    /**
     * Show the overlay with the specified delay
     * @param showDelay Optional delay to override the configured showDelay
     */
    show() {
        return new Promise(resolve => {
            // If closing is in progress, cancel it
            if (this.closeTimeout) {
                this.closeTimeout();
                this.closeTimeout = undefined;
            }
            // Don't proceed if already opening or open
            if (this.openTimeout || this.isOpen()) {
                return;
            }
            // Use the provided delay or fall back to config
            const delay = this.config.showDelay ?? 0;
            this.openTimeout = this.disposables.setTimeout(() => {
                this.openTimeout = undefined;
                this.createOverlay();
                resolve();
            }, delay);
        });
    }
    /**
     * Stop any pending close operation. This is useful for example, if we move the mouse from the tooltip trigger to the tooltip itself.
     * This will prevent the tooltip from closing immediately when the mouse leaves the trigger.
     * @internal
     */
    cancelPendingClose() {
        if (this.closeTimeout) {
            this.closeTimeout();
            this.closeTimeout = undefined;
        }
    }
    /**
     * Hide the overlay with the specified delay
     * @param options Optional options for hiding the overlay
     */
    hide(options) {
        // If opening is in progress, cancel it
        if (this.openTimeout) {
            this.openTimeout();
            this.openTimeout = undefined;
        }
        // Don't proceed if already closing or closed unless immediate is true
        if ((this.closeTimeout && !options?.immediate) || !this.isOpen()) {
            return;
        }
        this.closing.next();
        const dispose = async () => {
            this.closeTimeout = undefined;
            if (this.config.restoreFocus) {
                this.focusMonitor.focusVia(this.config.triggerElement, options?.origin ?? 'program', {
                    preventScroll: true,
                });
            }
            await this.destroyOverlay();
        };
        if (options?.immediate) {
            // If immediate, dispose right away
            dispose();
        }
        else {
            this.closeTimeout = this.disposables.setTimeout(dispose, this.config.hideDelay ?? 0);
        }
    }
    /**
     * Update the configuration of this overlay
     * @param config New configuration (partial)
     */
    updateConfig(config) {
        this.config = { ...this.config, ...config };
        // If the overlay is already open, update its position
        if (this.isOpen()) {
            this.updatePosition();
        }
    }
    /**
     * Immediately hide the overlay without any delay
     */
    hideImmediate() {
        this.hide({ immediate: true });
    }
    /**
     * Toggle the overlay open/closed state
     */
    toggle() {
        if (this.isOpen()) {
            this.hide();
        }
        else {
            this.show();
        }
    }
    /**
     * Force update the position of the overlay
     */
    updatePosition() {
        const portal = this.portal();
        if (!portal) {
            return;
        }
        const elements = portal.getElements();
        if (elements.length === 0) {
            return;
        }
        const overlayElement = elements[0];
        // Compute new position
        this.computePosition(overlayElement);
    }
    /**
     * Completely destroy this overlay instance
     */
    destroy() {
        this.hideImmediate();
        this.disposePositioning?.();
        this.scrollStrategy.disable();
    }
    /**
     * Get the elements of the overlay
     */
    getElements() {
        return this.portal()?.getElements() ?? [];
    }
    /**
     * Internal method to create the overlay
     */
    createOverlay() {
        if (!this.config.content) {
            throw new Error('Overlay content must be provided');
        }
        // Create a new portal with context
        const portal = createPortal(this.config.content, this.viewContainerRef, Injector.create({
            parent: this.config.injector,
            providers: [
                ...(this.config.providers || []),
                { provide: NgpOverlay, useValue: this },
                provideOverlayContext(this.config.context),
            ],
        }), { $implicit: this.config.context });
        // Attach portal to container
        const container = this.resolveContainer();
        portal.attach(container);
        // Update portal signal
        this.portal.set(portal);
        // Ensure view is up to date
        portal.detectChanges();
        // find a dedicated outlet element
        // this is the element that has the `data-overlay` attribute
        // if no such element exists, we use the first element in the portal
        const outletElement = portal.getElements().find(el => el.hasAttribute('data-overlay')) ?? portal.getElements()[0];
        if (!outletElement) {
            throw new Error('Overlay element is not available.');
        }
        // Set up positioning
        this.setupPositioning(outletElement);
        // Mark as open
        this.isOpen.set(true);
        this.scrollStrategy =
            this.config.scrollBehaviour === 'block'
                ? new BlockScrollStrategy(this.viewportRuler, this.document)
                : new NoopScrollStrategy();
        this.scrollStrategy.enable();
    }
    /**
     * Internal method to setup positioning of the overlay
     */
    setupPositioning(overlayElement) {
        // Determine positioning strategy based on overlay element's CSS
        const strategy = getComputedStyle(overlayElement).position === 'fixed'
            ? 'fixed'
            : this.config.strategy || 'absolute';
        // Use anchor element for positioning if provided, otherwise use trigger element
        const referenceElement = this.config.anchorElement || this.config.triggerElement;
        // Setup auto-update for positioning
        this.disposePositioning = autoUpdate(referenceElement, overlayElement, () => this.computePosition(overlayElement, strategy));
    }
    /**
     * Compute the overlay position using floating-ui
     */
    async computePosition(overlayElement, strategy = 'absolute') {
        // Create middleware array
        const middleware = [offset(this.config.offset ?? 0), shift()];
        // Add flip middleware if requested
        if (this.config.flip !== false) {
            middleware.push(flip());
        }
        // Add any additional middleware
        if (this.config.additionalMiddleware) {
            middleware.push(...this.config.additionalMiddleware);
        }
        // If the arrow element is registered, add arrow middleware
        if (this.arrowElement) {
            middleware.push(arrow({ element: this.arrowElement }));
        }
        // Compute the position
        const placement = this.config.placement?.() ?? 'top';
        // Use anchor element for positioning if provided, otherwise use trigger element
        const referenceElement = this.config.anchorElement || this.config.triggerElement;
        const position = await computePosition(referenceElement, overlayElement, {
            placement,
            middleware,
            strategy,
        });
        // Update position signal
        this.position.set({ x: position.x, y: position.y });
        // Update final placement signal
        this.finalPlacement.set(position.placement);
        // Update arrow position if available
        if (this.arrowElement) {
            this.arrowPosition.set({
                x: position.middlewareData.arrow?.x,
                y: position.middlewareData.arrow?.y,
            });
        }
        // Ensure view is updated
        this.portal()?.detectChanges();
    }
    /**
     * Internal method to destroy the overlay portal
     */
    async destroyOverlay() {
        const portal = this.portal();
        if (!portal) {
            return;
        }
        // Clear portal reference to prevent double destruction
        this.portal.set(null);
        // Clean up positioning
        this.disposePositioning?.();
        this.disposePositioning = undefined;
        // Detach the portal
        await portal.detach();
        // Mark as closed
        this.isOpen.set(false);
        // Reset final placement
        this.finalPlacement.set(undefined);
        // disable scroll strategy
        this.scrollStrategy.disable();
        this.scrollStrategy = new NoopScrollStrategy();
    }
    /**
     * Get the transform origin for the overlay
     */
    getTransformOrigin() {
        const placement = this.config.placement?.() ?? 'top';
        const basePlacement = placement.split('-')[0]; // Extract "top", "bottom", etc.
        const alignment = placement.split('-')[1]; // Extract "start" or "end"
        const map = {
            top: 'bottom',
            bottom: 'top',
            left: 'right',
            right: 'left',
        };
        let x = 'center';
        let y = 'center';
        if (basePlacement === 'top' || basePlacement === 'bottom') {
            y = map[basePlacement];
            if (alignment === 'start')
                x = 'left';
            else if (alignment === 'end')
                x = 'right';
        }
        else {
            x = map[basePlacement];
            if (alignment === 'start')
                y = 'top';
            else if (alignment === 'end')
                y = 'bottom';
        }
        return `${y} ${x}`;
    }
    /**
     * Register the arrow element for positioning
     * @internal
     */
    registerArrow(arrowElement) {
        this.arrowElement = arrowElement;
    }
    /**
     * Remove the registered arrow element
     * @internal
     */
    unregisterArrow() {
        this.arrowElement = null;
    }
    /**
     * Resolve the container element from the configuration
     * @internal
     */
    resolveContainer() {
        if (!this.config.container) {
            return this.document.body;
        }
        if (typeof this.config.container === 'string') {
            const element = this.document.querySelector(this.config.container);
            if (!element) {
                // Fallback to document.body if the container is not found
                console.warn(`NgPrimitives: Container element with selector "${this.config.container}" not found. Falling back to document.body.`);
                return this.document.body;
            }
            return element;
        }
        return this.config.container;
    }
}
/**
 * Helper function to create an overlay in a single call
 * @internal
 */
function createOverlay(config) {
    // we run the overlay creation in the injector context to ensure that it can call the inject function
    return runInInjectionContext(config.injector, () => new NgpOverlay(config));
}
/**
 * Helper function to inject the NgpOverlay instance
 * @internal
 */
function injectOverlay() {
    return inject(NgpOverlay);
}

function setupOverlayArrow() {
    const overlay = injectOverlay();
    const element = injectElementRef();
    const destroyRef = inject(DestroyRef);
    // register the arrow element with the overlay
    overlay.registerArrow(element.nativeElement);
    // cleanup the arrow element on destroy
    destroyRef.onDestroy(() => overlay.unregisterArrow());
    // update the arrow position after the overlay is rendered
    afterRenderEffect(() => {
        const position = overlay.arrowPosition();
        element.nativeElement.style.setProperty('inset-inline-start', `${position.x}px`);
        element.nativeElement.style.setProperty('inset-block-start', `${position.y}px`);
        element.nativeElement.dataset['placement'] = overlay.finalPlacement();
    });
}

/**
 * Transform function to coerce offset input values to the correct type
 * @param value The input value to coerce
 * @returns The coerced offset value
 */
function coerceOffset(value) {
    if (isNil(value)) {
        return 0;
    }
    if (isObject(value)) {
        return value;
    }
    // Use CDK's coerceNumberProperty for consistent number coercion
    // This handles strings, numbers, and other input types just like Angular CDK inputs
    return coerceNumberProperty(value, 0);
}

/**
 * Generated bundle index. Do not edit.
 */

export { BlockScrollStrategy, NgpComponentPortal, NgpOverlay, NgpPortal, NgpTemplatePortal, NoopScrollStrategy, coerceOffset, createOverlay, createPortal, injectOverlay, injectOverlayContext, provideOverlayContext, setupOverlayArrow };
//# sourceMappingURL=ng-primitives-portal.mjs.map
