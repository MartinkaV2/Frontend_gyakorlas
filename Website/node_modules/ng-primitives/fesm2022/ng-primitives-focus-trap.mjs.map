{"version":3,"file":"ng-primitives-focus-trap.mjs","sources":["../../../../packages/ng-primitives/focus-trap/src/focus-trap/focus-trap-state.ts","../../../../packages/ng-primitives/focus-trap/src/focus-trap/focus-trap.ts","../../../../packages/ng-primitives/focus-trap/src/ng-primitives-focus-trap.ts"],"sourcesContent":["import {\n  createState,\n  createStateInjector,\n  createStateProvider,\n  createStateToken,\n} from 'ng-primitives/state';\nimport type { NgpFocusTrap } from './focus-trap';\n\n/**\n * The state token  for the FocusTrap primitive.\n */\nexport const NgpFocusTrapStateToken = createStateToken<NgpFocusTrap>('FocusTrap');\n\n/**\n * Provides the FocusTrap state.\n */\nexport const provideFocusTrapState = createStateProvider(NgpFocusTrapStateToken);\n\n/**\n * Injects the FocusTrap state.\n */\nexport const injectFocusTrapState = createStateInjector<NgpFocusTrap>(NgpFocusTrapStateToken);\n\n/**\n * The FocusTrap state registration function.\n */\nexport const focusTrapState = createState(NgpFocusTrapStateToken);\n","import { FocusMonitor, InteractivityChecker } from '@angular/cdk/a11y';\nimport { BooleanInput } from '@angular/cdk/coercion';\nimport {\n  afterNextRender,\n  booleanAttribute,\n  Directive,\n  ElementRef,\n  HostListener,\n  inject,\n  Injector,\n  input,\n  NgZone,\n  OnDestroy,\n  OnInit,\n} from '@angular/core';\nimport { NgpOverlay } from 'ng-primitives/portal';\nimport { safeTakeUntilDestroyed } from 'ng-primitives/utils';\nimport { focusTrapState, provideFocusTrapState } from './focus-trap-state';\n\n/**\n * This implementation is based on the Radix UI FocusScope:\n * https://github.com/radix-ui/primitives/blob/main/packages/react/focus-scope/src/FocusScope.tsx#L306\n */\n\nclass FocusTrap {\n  /**\n   * Whether the focus trap is active.\n   */\n  active: boolean = false;\n\n  /**\n   * Activates the focus trap.\n   */\n  activate(): void {\n    this.active = true;\n  }\n\n  /**\n   * Deactivates the focus trap.\n   */\n  deactivate(): void {\n    this.active = false;\n  }\n}\n\nclass FocusTrapStack {\n  /**\n   * The stack of focus traps.\n   */\n  private readonly stack: FocusTrap[] = [];\n\n  /**\n   * Adds a focus trap to the stack.\n   */\n  add(focusTrap: FocusTrap): void {\n    // deactivate the previous focus trap\n    this.stack.forEach(t => t.deactivate());\n\n    // add the new focus trap and activate it\n    this.stack.push(focusTrap);\n    focusTrap.activate();\n  }\n\n  /**\n   * Removes a focus trap from the stack.\n   */\n  remove(focusTrap: FocusTrap): void {\n    // remove the focus trap\n    const index = this.stack.indexOf(focusTrap);\n\n    if (index >= 0) {\n      this.stack.splice(index, 1);\n    }\n\n    // activate the previous focus trap\n    const previous = this.stack[this.stack.length - 1];\n\n    if (previous) {\n      previous.activate();\n    }\n  }\n}\n\n// create a global stack of focus traps\nconst focusTrapStack = new FocusTrapStack();\n\n/**\n * The `NgpFocusTrap` directive traps focus within the host element.\n */\n@Directive({\n  selector: '[ngpFocusTrap]',\n  exportAs: 'ngpFocusTrap',\n  providers: [provideFocusTrapState()],\n  host: {\n    '[attr.tabindex]': '-1',\n    '[attr.data-focus-trap]': '!disabled() ? \"\" : null',\n  },\n})\nexport class NgpFocusTrap implements OnInit, OnDestroy {\n  /**\n   * Access any parent overlay.\n   */\n  private readonly overlay = inject(NgpOverlay, { optional: true });\n\n  /**\n   * Create a new focus trap.\n   */\n  private readonly focusTrap = new FocusTrap();\n\n  /**\n   * Access the injector.\n   */\n  private readonly injector = inject(Injector);\n\n  /**\n   * Access the focus monitor.\n   */\n  private readonly focusMonitor = inject(FocusMonitor);\n\n  /**\n   * Access the interactivity checker.\n   */\n  private readonly interactivityChecker = inject(InteractivityChecker);\n\n  /**\n   * Get the focus trap container element.\n   */\n  private readonly elementRef = inject<ElementRef<HTMLElement>>(ElementRef);\n\n  /**\n   * Access NgZone to run the focus trap events outside of Angular's zone.\n   */\n  private readonly ngZone = inject(NgZone);\n\n  /**\n   * Store the mutation observer.\n   */\n  private mutationObserver: MutationObserver | null = null;\n\n  /**\n   * Store the last focused element.\n   */\n  private lastFocusedElement: HTMLElement | null = null;\n\n  /**\n   * Whether the focus trap is disabled.\n   */\n  readonly disabled = input<boolean, BooleanInput>(false, {\n    alias: 'ngpFocusTrapDisabled',\n    transform: booleanAttribute,\n  });\n\n  /**\n   * The focus trap state.\n   */\n  protected readonly state = focusTrapState<NgpFocusTrap>(this);\n\n  constructor() {\n    // if this is used within an overlay we must disable the focus trap as soon as the overlay is closing\n    this.overlay?.closing\n      .pipe(safeTakeUntilDestroyed())\n      .subscribe(() => this.focusTrap.deactivate());\n  }\n\n  ngOnInit(): void {\n    focusTrapStack.add(this.focusTrap);\n\n    this.mutationObserver = new MutationObserver(this.handleMutations.bind(this));\n\n    // setup event listeners\n    this.ngZone.runOutsideAngular(() => {\n      this.mutationObserver!.observe(this.elementRef.nativeElement, {\n        childList: true,\n        subtree: true,\n      });\n      document.addEventListener('focusin', this.handleFocusIn.bind(this));\n      document.addEventListener('focusout', this.handleFocusOut.bind(this));\n    });\n\n    const previouslyFocusedElement = document.activeElement as HTMLElement | null;\n    const hasFocusedCandidate = this.elementRef.nativeElement.contains(previouslyFocusedElement);\n\n    if (!hasFocusedCandidate) {\n      // we do this to ensure the content is rendered before we try to find the first focusable element\n      // and focus it\n      afterNextRender(\n        {\n          write: () => {\n            this.focusFirst();\n\n            // if the focus didn't change, focus the container\n            if (document.activeElement === previouslyFocusedElement) {\n              this.focus(this.elementRef.nativeElement);\n            }\n          },\n        },\n        { injector: this.injector },\n      );\n    }\n  }\n\n  ngOnDestroy(): void {\n    focusTrapStack.remove(this.focusTrap);\n    this.mutationObserver?.disconnect();\n    this.mutationObserver = null;\n    this.focusTrap.deactivate();\n  }\n\n  private handleFocusIn(event: FocusEvent): void {\n    if (!this.focusTrap.active || this.state.disabled()) {\n      return;\n    }\n\n    const target = event.target as HTMLElement | null;\n\n    if (this.elementRef.nativeElement.contains(target)) {\n      this.lastFocusedElement = target;\n    } else {\n      this.focus(this.lastFocusedElement);\n    }\n  }\n\n  /**\n   * Handles the `focusout` event.\n   */\n  private handleFocusOut(event: FocusEvent) {\n    if (!this.focusTrap.active || this.state.disabled() || event.relatedTarget === null) {\n      return;\n    }\n\n    const relatedTarget = event.relatedTarget as HTMLElement;\n\n    if (!this.elementRef.nativeElement.contains(relatedTarget)) {\n      this.focus(this.lastFocusedElement);\n    }\n  }\n\n  /**\n   * If the focused element gets removed from the DOM, browsers move focus back to the document.body.\n   * We move focus to the container to keep focus trapped correctly.\n   */\n  private handleMutations(mutations: MutationRecord[]): void {\n    const focusedElement = document.activeElement as HTMLElement | null;\n\n    if (focusedElement !== document.body) {\n      return;\n    }\n\n    for (const mutation of mutations) {\n      if (mutation.removedNodes.length > 0) {\n        this.focus(this.elementRef.nativeElement);\n      }\n    }\n  }\n\n  /**\n   * Handles the `keydown` event.\n   */\n  @HostListener('keydown', ['$event'])\n  protected handleKeyDown(event: KeyboardEvent): void {\n    if (!this.focusTrap.active || this.state.disabled()) {\n      return;\n    }\n\n    const isTabKey = event.key === 'Tab' && !event.altKey && !event.ctrlKey && !event.metaKey;\n    const focusedElement = document.activeElement as HTMLElement | null;\n\n    if (isTabKey && focusedElement) {\n      const container = event.currentTarget as HTMLElement;\n      const [first, last] = this.getTabbableEdges(container);\n      const hasTabbableElementsInside = first && last;\n\n      // we can only wrap focus if we have tabbable edges\n      if (!hasTabbableElementsInside) {\n        if (focusedElement === container) {\n          event.preventDefault();\n        }\n      } else {\n        if (!event.shiftKey && focusedElement === last) {\n          event.preventDefault();\n          this.focus(first);\n        } else if (event.shiftKey && focusedElement === first) {\n          event.preventDefault();\n          this.focus(last);\n        }\n      }\n    }\n  }\n\n  /**\n   * Returns the first and last tabbable elements inside a container.\n   */\n  private getTabbableEdges(container: HTMLElement) {\n    const candidates = this.getTabbableCandidates(container);\n    const first = this.findVisible(candidates);\n    const last = this.findVisible(candidates.reverse());\n    return [first, last] as const;\n  }\n\n  /**\n   * Returns a list of potential focusable elements inside a container.\n   */\n  private getTabbableCandidates(container: HTMLElement) {\n    const nodes: HTMLElement[] = [];\n    const walker = document.createTreeWalker(container, NodeFilter.SHOW_ELEMENT, {\n      acceptNode: (node: HTMLElement) =>\n        this.interactivityChecker.isFocusable(node)\n          ? NodeFilter.FILTER_ACCEPT\n          : NodeFilter.FILTER_SKIP,\n    });\n    while (walker.nextNode()) {\n      nodes.push(walker.currentNode as HTMLElement);\n    }\n    return nodes;\n  }\n\n  /**\n   * Returns the first visible element in a list..\n   */\n  private findVisible(elements: HTMLElement[]) {\n    return elements.find(element => this.interactivityChecker.isVisible(element)) ?? null;\n  }\n\n  private focus(element: HTMLElement | null): void {\n    if (!element) {\n      return;\n    }\n    // Its not great that we are relying on an internal API here, but we need to in order to\n    // try and best determine the focus origin when it is programmatically closed by the user.\n    this.focusMonitor.focusVia(element, (this.focusMonitor as any)._lastFocusOrigin, {\n      preventScroll: true,\n    });\n  }\n\n  private focusFirst(): void {\n    const previouslyFocusedElement = document.activeElement;\n\n    for (const candidate of this.getTabbableCandidates(this.elementRef.nativeElement)) {\n      this.focus(candidate);\n\n      if (document.activeElement !== previouslyFocusedElement) {\n        return;\n      }\n    }\n  }\n}\n","/**\n * Generated bundle index. Do not edit.\n */\n\nexport * from './index';\n"],"names":[],"mappings":"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"}