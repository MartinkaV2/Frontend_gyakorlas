import { setupOverlayArrow, coerceOffset, createOverlay, injectOverlay } from 'ng-primitives/portal';
export { injectOverlayContext as injectPopoverContext } from 'ng-primitives/portal';
import * as i0 from '@angular/core';
import { InjectionToken, inject, Directive, Injector, ViewContainerRef, input, booleanAttribute, numberAttribute, signal, computed, output } from '@angular/core';
import { injectElementRef, explicitEffect } from 'ng-primitives/internal';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import * as i1 from 'ng-primitives/focus-trap';
import { NgpFocusTrap } from 'ng-primitives/focus-trap';

const defaultPopoverConfig = {
    offset: 4,
    placement: 'bottom',
    showDelay: 0,
    hideDelay: 0,
    flip: true,
    container: 'body',
    closeOnOutsideClick: true,
    closeOnEscape: true,
    scrollBehavior: 'reposition',
};
const NgpPopoverConfigToken = new InjectionToken('NgpPopoverConfigToken');
/**
 * Provide the default Popover configuration
 * @param config The Popover configuration
 * @returns The provider
 */
function providePopoverConfig(config) {
    return [
        {
            provide: NgpPopoverConfigToken,
            useValue: { ...defaultPopoverConfig, ...config },
        },
    ];
}
/**
 * Inject the Popover configuration
 * @returns The global Popover configuration
 */
function injectPopoverConfig() {
    return inject(NgpPopoverConfigToken, { optional: true }) ?? defaultPopoverConfig;
}

class NgpPopoverArrow {
    constructor() {
        setupOverlayArrow();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPopoverArrow, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpPopoverArrow, isStandalone: true, selector: "[ngpPopoverArrow]", exportAs: ["ngpPopoverArrow"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPopoverArrow, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPopoverArrow]',
                    exportAs: 'ngpPopoverArrow',
                }]
        }], ctorParameters: () => [] });

/**
 * The state token  for the PopoverTrigger primitive.
 */
const NgpPopoverTriggerStateToken = createStateToken('PopoverTrigger');
/**
 * Provides the PopoverTrigger state.
 */
const providePopoverTriggerState = createStateProvider(NgpPopoverTriggerStateToken);
/**
 * Injects the PopoverTrigger state.
 */
const injectPopoverTriggerState = createStateInjector(NgpPopoverTriggerStateToken);
/**
 * The PopoverTrigger state registration function.
 */
const popoverTriggerState = createState(NgpPopoverTriggerStateToken);

/**
 * Apply the `ngpPopoverTrigger` directive to an element that triggers the popover to show.
 */
class NgpPopoverTrigger {
    constructor() {
        /**
         * Access the trigger element
         */
        this.trigger = injectElementRef();
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the view container reference.
         */
        this.viewContainerRef = inject(ViewContainerRef);
        /**
         * Access the global popover configuration.
         */
        this.config = injectPopoverConfig();
        /**
         * Access the popover template ref.
         */
        this.popover = input(undefined, {
            alias: 'ngpPopoverTrigger',
        });
        /**
         * Define if the trigger should be disabled.
         * @default false
         */
        this.disabled = input(false, {
            alias: 'ngpPopoverTriggerDisabled',
            transform: booleanAttribute,
        });
        /**
         * Define the placement of the popover relative to the trigger.
         * @default 'top'
         */
        this.placement = input(this.config.placement, {
            alias: 'ngpPopoverTriggerPlacement',
        });
        /**
         * Define the offset of the popover relative to the trigger.
         * Can be a number (applies to mainAxis) or an object with mainAxis, crossAxis, and alignmentAxis.
         * @default 0
         */
        this.offset = input(this.config.offset, {
            alias: 'ngpPopoverTriggerOffset',
            transform: coerceOffset,
        });
        /**
         * Define the delay before the popover is displayed.
         * @default 0
         */
        this.showDelay = input(this.config.showDelay, {
            alias: 'ngpPopoverTriggerShowDelay',
            transform: numberAttribute,
        });
        /**
         * Define the delay before the popover is hidden.
         * @default 0
         */
        this.hideDelay = input(this.config.hideDelay, {
            alias: 'ngpPopoverTriggerHideDelay',
            transform: numberAttribute,
        });
        /**
         * Define whether the popover should flip when there is not enough space for the popover.
         * @default true
         */
        this.flip = input(this.config.flip, {
            alias: 'ngpPopoverTriggerFlip',
            transform: booleanAttribute,
        });
        /**
         * Define the container in which the popover should be attached.
         * @default document.body
         */
        this.container = input(this.config.container, {
            alias: 'ngpPopoverTriggerContainer',
        });
        /**
         * Define whether the popover should close when clicking outside of it.
         * @default true
         */
        this.closeOnOutsideClick = input(this.config.closeOnOutsideClick, {
            alias: 'ngpPopoverTriggerCloseOnOutsideClick',
            transform: booleanAttribute,
        });
        /**
         * Define whether the popover should close when the escape key is pressed.
         * @default true
         */
        this.closeOnEscape = input(this.config.closeOnEscape, {
            alias: 'ngpPopoverTriggerCloseOnEscape',
            transform: booleanAttribute,
        });
        /**
         * Defines how the popover behaves when the window is scrolled.
         * @default 'reposition'
         */
        this.scrollBehavior = input(this.config.scrollBehavior, {
            alias: 'ngpPopoverTriggerScrollBehavior',
        });
        /**
         * Provide context to the popover. This can be used to pass data to the popover content.
         */
        this.context = input(undefined, {
            alias: 'ngpPopoverTriggerContext',
        });
        /**
         * Define an anchor element for positioning the popover.
         * If provided, the popover will be positioned relative to this element instead of the trigger.
         */
        this.anchor = input(null, {
            alias: 'ngpPopoverTriggerAnchor',
        });
        /**
         * The overlay that manages the popover
         * @internal
         */
        this.overlay = signal(null);
        /**
         * The open state of the popover.
         * @internal
         */
        this.open = computed(() => this.overlay()?.isOpen() ?? false);
        /**
         * Event emitted when the popover open state changes.
         */
        this.openChange = output({
            alias: 'ngpPopoverTriggerOpenChange',
        });
        /**
         * The popover trigger state.
         */
        this.state = popoverTriggerState(this);
    }
    ngOnDestroy() {
        this.overlay()?.destroy();
    }
    toggle(event) {
        // if the trigger is disabled then do not toggle the popover
        if (this.state.disabled()) {
            return;
        }
        // determine the origin of the event, 0 is keyboard, 1 is mouse
        const origin = event.detail === 0 ? 'keyboard' : 'mouse';
        // if the popover is open then hide it
        if (this.open()) {
            this.hide(origin);
        }
        else {
            this.show();
        }
    }
    /**
     * Show the popover.
     * @returns A promise that resolves when the popover has been shown
     */
    async show() {
        // If the trigger is disabled, don't show the popover
        if (this.state.disabled()) {
            return;
        }
        // Create the overlay if it doesn't exist yet
        if (!this.overlay()) {
            this.createOverlay();
        }
        // Show the overlay
        await this.overlay()?.show();
        if (this.open()) {
            this.openChange.emit(true);
        }
    }
    /**
     * @internal
     * Hide the popover.
     * @returns A promise that resolves when the popover has been hidden
     */
    async hide(origin = 'program') {
        // If the trigger is disabled or the popover is not open, do nothing
        if (this.state.disabled() || !this.open()) {
            return;
        }
        // Hide the overlay
        await this.overlay()?.hide({ origin });
        this.openChange.emit(false);
    }
    /**
     * Create the overlay that will contain the popover
     */
    createOverlay() {
        const popover = this.state.popover();
        if (!popover) {
            throw new Error('Popover must be either a TemplateRef or a ComponentType');
        }
        // Create config for the overlay
        const config = {
            content: popover,
            triggerElement: this.trigger.nativeElement,
            anchorElement: this.state.anchor(),
            injector: this.injector,
            context: this.state.context,
            container: this.state.container(),
            placement: this.state.placement,
            offset: this.state.offset(),
            flip: this.state.flip(),
            showDelay: this.state.showDelay(),
            hideDelay: this.state.hideDelay(),
            closeOnOutsideClick: this.state.closeOnOutsideClick(),
            closeOnEscape: this.state.closeOnEscape(),
            restoreFocus: true,
            scrollBehaviour: this.state.scrollBehavior(),
            viewContainerRef: this.viewContainerRef,
        };
        this.overlay.set(createOverlay(config));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPopoverTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPopoverTrigger, isStandalone: true, selector: "[ngpPopoverTrigger]", inputs: { popover: { classPropertyName: "popover", publicName: "ngpPopoverTrigger", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpPopoverTriggerDisabled", isSignal: true, isRequired: false, transformFunction: null }, placement: { classPropertyName: "placement", publicName: "ngpPopoverTriggerPlacement", isSignal: true, isRequired: false, transformFunction: null }, offset: { classPropertyName: "offset", publicName: "ngpPopoverTriggerOffset", isSignal: true, isRequired: false, transformFunction: null }, showDelay: { classPropertyName: "showDelay", publicName: "ngpPopoverTriggerShowDelay", isSignal: true, isRequired: false, transformFunction: null }, hideDelay: { classPropertyName: "hideDelay", publicName: "ngpPopoverTriggerHideDelay", isSignal: true, isRequired: false, transformFunction: null }, flip: { classPropertyName: "flip", publicName: "ngpPopoverTriggerFlip", isSignal: true, isRequired: false, transformFunction: null }, container: { classPropertyName: "container", publicName: "ngpPopoverTriggerContainer", isSignal: true, isRequired: false, transformFunction: null }, closeOnOutsideClick: { classPropertyName: "closeOnOutsideClick", publicName: "ngpPopoverTriggerCloseOnOutsideClick", isSignal: true, isRequired: false, transformFunction: null }, closeOnEscape: { classPropertyName: "closeOnEscape", publicName: "ngpPopoverTriggerCloseOnEscape", isSignal: true, isRequired: false, transformFunction: null }, scrollBehavior: { classPropertyName: "scrollBehavior", publicName: "ngpPopoverTriggerScrollBehavior", isSignal: true, isRequired: false, transformFunction: null }, context: { classPropertyName: "context", publicName: "ngpPopoverTriggerContext", isSignal: true, isRequired: false, transformFunction: null }, anchor: { classPropertyName: "anchor", publicName: "ngpPopoverTriggerAnchor", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { openChange: "ngpPopoverTriggerOpenChange" }, host: { listeners: { "click": "toggle($event)" }, properties: { "attr.aria-expanded": "open() ? \"true\" : \"false\"", "attr.data-open": "open() ? \"\" : null", "attr.data-placement": "state.placement()", "attr.data-disabled": "state.disabled() ? \"\" : null", "attr.aria-describedby": "overlay()?.ariaDescribedBy()" } }, providers: [providePopoverTriggerState({ inherit: false })], exportAs: ["ngpPopoverTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPopoverTrigger, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPopoverTrigger]',
                    exportAs: 'ngpPopoverTrigger',
                    providers: [providePopoverTriggerState({ inherit: false })],
                    host: {
                        '[attr.aria-expanded]': 'open() ? "true" : "false"',
                        '[attr.data-open]': 'open() ? "" : null',
                        '[attr.data-placement]': 'state.placement()',
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                        '[attr.aria-describedby]': 'overlay()?.ariaDescribedBy()',
                        '(click)': 'toggle($event)',
                    },
                }]
        }] });

/**
 * Apply the `ngpPopover` directive to an element that represents the popover. This typically would be a `div` inside an `ng-template`.
 */
class NgpPopover {
    constructor() {
        /**
         * Access the overlay.
         */
        this.overlay = injectOverlay();
        /**
         * The unique id of the tooltip.
         */
        this.id = input(this.overlay.id());
        explicitEffect([this.id], ([id]) => this.overlay.id.set(id));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPopover, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPopover, isStandalone: true, selector: "[ngpPopover]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "dialog", "data-overlay": "" }, properties: { "id": "id()", "style.left.px": "overlay.position().x", "style.top.px": "overlay.position().y", "style.--ngp-popover-trigger-width.px": "overlay.triggerWidth()", "style.--ngp-popover-transform-origin": "overlay.transformOrigin()", "attr.data-placement": "overlay.finalPlacement()" } }, exportAs: ["ngpPopover"], hostDirectives: [{ directive: i1.NgpFocusTrap }], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPopover, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPopover]',
                    exportAs: 'ngpPopover',
                    hostDirectives: [NgpFocusTrap],
                    host: {
                        role: 'dialog',
                        '[id]': 'id()',
                        '[style.left.px]': 'overlay.position().x',
                        '[style.top.px]': 'overlay.position().y',
                        '[style.--ngp-popover-trigger-width.px]': 'overlay.triggerWidth()',
                        '[style.--ngp-popover-transform-origin]': 'overlay.transformOrigin()',
                        '[attr.data-placement]': 'overlay.finalPlacement()',
                        'data-overlay': '',
                    },
                }]
        }], ctorParameters: () => [] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpPopover, NgpPopoverArrow, NgpPopoverTrigger, injectPopoverTriggerState, providePopoverConfig, providePopoverTriggerState };
//# sourceMappingURL=ng-primitives-popover.mjs.map
