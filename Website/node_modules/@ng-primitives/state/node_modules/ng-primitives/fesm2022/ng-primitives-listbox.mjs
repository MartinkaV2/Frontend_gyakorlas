import * as i0 from '@angular/core';
import { input, Directive, booleanAttribute, signal, computed, effect, contentChild, HostListener, inject, Injector, DestroyRef, output } from '@angular/core';
import { NgpHeaderToken } from 'ng-primitives/common';
import { uniqueId, safeTakeUntilDestroyed } from 'ng-primitives/utils';
import { setupInteractions } from 'ng-primitives/interactions';
import { injectElementRef, onDomRemoval, scrollIntoViewIfNeeded, setupFocusVisible, explicitEffect } from 'ng-primitives/internal';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';
import { injectPopoverTriggerState } from 'ng-primitives/popover';
import { ActiveDescendantKeyManager } from '@angular/cdk/a11y';

class NgpListboxHeader {
    constructor() {
        /**
         * The id of the listbox header.
         */
        this.id = input(uniqueId('ngp-listbox-header'));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxHeader, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpListboxHeader, isStandalone: true, selector: "[ngpListboxHeader]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "presentation" }, properties: { "attr.id": "id()" } }, providers: [{ provide: NgpHeaderToken, useExisting: NgpListboxHeader }], exportAs: ["ngpListboxHeader"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxHeader, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpListboxHeader]',
                    exportAs: 'ngpListboxHeader',
                    host: {
                        role: 'presentation',
                        '[attr.id]': 'id()',
                    },
                    // temporary until we remove NgpHeader completely - this prevents breaking changes
                    providers: [{ provide: NgpHeaderToken, useExisting: NgpListboxHeader }],
                }]
        }] });

/**
 * The state token  for the Listbox primitive.
 */
const NgpListboxStateToken = createStateToken('Listbox');
/**
 * Provides the Listbox state.
 */
const provideListboxState = createStateProvider(NgpListboxStateToken);
/**
 * Injects the Listbox state.
 */
const injectListboxState = createStateInjector(NgpListboxStateToken, {
    deferred: true,
});
/**
 * The Listbox state registration function.
 */
const listboxState = createState(NgpListboxStateToken);

class NgpListboxOption {
    /**
     * @internal
     * Whether the option is disabled - this is used by the `Highlightable` interface.
     */
    get disabled() {
        return this._disabled();
    }
    constructor() {
        this.listbox = injectListboxState();
        this.elementRef = injectElementRef();
        /**
         * The id of the listbox.
         */
        this.id = input(uniqueId('ngp-listbox-option'));
        /**
         * The value of the option.
         */
        this.value = input.required({
            alias: 'ngpListboxOptionValue',
        });
        /**
         * Whether the option is disabled.
         */
        this.optionDisabled = input(false, {
            alias: 'ngpListboxOptionDisabled',
            transform: booleanAttribute,
        });
        /**
         * Whether the option is active.
         */
        this.active = signal(false);
        /**
         * @internal
         * Whether the option is selected.
         */
        this.selected = computed(() => this.listbox()?.isSelected(this.value()));
        /**
         * Whether the option is disabled.
         */
        this._disabled = computed(() => this.optionDisabled() || (this.listbox()?.disabled() ?? false));
        setupInteractions({
            hover: true,
            press: true,
            focusVisible: true,
            focus: true,
            disabled: this._disabled,
        });
        // the listbox may not be available when the option is initialized
        // so we need to add the option when the listbox is available
        effect(() => this.listbox()?.addOption(this));
        // any time the element is removed from the dom, we need to remove the option from the listbox
        // and we also want to reset the active state
        onDomRemoval(this.elementRef.nativeElement, () => {
            this.listbox()?.removeOption(this);
            this.setInactiveStyles();
        });
    }
    ngOnDestroy() {
        this.listbox()?.removeOption(this);
    }
    /**
     * @internal
     * Sets the active state of the option.
     */
    setActiveStyles() {
        this.active.set(true);
        scrollIntoViewIfNeeded(this.elementRef.nativeElement);
    }
    /**
     * @internal
     * Sets the inactive state of the option.
     */
    setInactiveStyles() {
        this.active.set(false);
    }
    /**
     * @internal
     * Gets the label of the option, used by the `Highlightable` interface.
     */
    getLabel() {
        return this.elementRef.nativeElement.textContent ?? '';
    }
    /**
     * @internal
     * Selects the option.
     */
    select(origin) {
        this.listbox()?.selectOption(this.value(), origin);
    }
    /**
     * @internal
     * Activate the current options.
     */
    activate() {
        if (this._disabled()) {
            return;
        }
        this.listbox()?.activateOption(this.value());
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxOption, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpListboxOption, isStandalone: true, selector: "[ngpListboxOption]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpListboxOptionValue", isSignal: true, isRequired: true, transformFunction: null }, optionDisabled: { classPropertyName: "optionDisabled", publicName: "ngpListboxOptionDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { attributes: { "role": "option" }, listeners: { "click": "select(\"mouse\")", "mouseenter": "activate()", "keydown.enter": "select(\"keyboard\")", "keydown.space": "select(\"keyboard\")" }, properties: { "attr.id": "id()", "attr.aria-disabled": "optionDisabled()", "attr.data-active": "listbox()?.isFocused() && active() ? \"\" : undefined", "attr.data-selected": "selected() ? \"\" : undefined", "attr.data-disabled": "optionDisabled() ? \"\" : undefined" } }, exportAs: ["ngpListboxOption"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxOption, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpListboxOption]',
                    exportAs: 'ngpListboxOption',
                    host: {
                        role: 'option',
                        '[attr.id]': 'id()',
                        '[attr.aria-disabled]': 'optionDisabled()',
                        '[attr.data-active]': 'listbox()?.isFocused() && active() ? "" : undefined',
                        '[attr.data-selected]': 'selected() ? "" : undefined',
                        '[attr.data-disabled]': 'optionDisabled() ? "" : undefined',
                        '(click)': 'select("mouse")',
                        '(mouseenter)': 'activate()',
                        '(keydown.enter)': 'select("keyboard")',
                        '(keydown.space)': 'select("keyboard")',
                    },
                }]
        }], ctorParameters: () => [] });

class NgpListboxSection {
    constructor() {
        /**
         * Access the header of the section if it exists.
         */
        this.header = contentChild(NgpHeaderToken, { descendants: true });
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxSection, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.2.0", version: "19.2.11", type: NgpListboxSection, isStandalone: true, selector: "[ngpListboxSection]", host: { attributes: { "role": "group" }, properties: { "attr.aria-labelledby": "header()?.id()" } }, queries: [{ propertyName: "header", first: true, predicate: NgpHeaderToken, descendants: true, isSignal: true }], exportAs: ["ngpListboxSection"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxSection, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpListboxSection]',
                    exportAs: 'ngpListboxSection',
                    host: {
                        role: 'group',
                        '[attr.aria-labelledby]': 'header()?.id()',
                    },
                }]
        }] });

class NgpListboxTrigger {
    constructor() {
        /**
         * There must also be a popover trigger directive associated with this element.
         */
        this.popoverTrigger = injectPopoverTriggerState();
    }
    /**
     * When the up or down arrow key is pressed, open the popover.
     */
    openPopover(event) {
        if (event.key === 'ArrowDown' || event.key === 'ArrowUp') {
            this.popoverTrigger().show();
            event.preventDefault();
        }
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxTrigger, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "14.0.0", version: "19.2.11", type: NgpListboxTrigger, isStandalone: true, selector: "[ngpListboxTrigger]", host: { listeners: { "keydown": "openPopover($event)" } }, exportAs: ["ngpListboxTrigger"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListboxTrigger, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpListboxTrigger]',
                    exportAs: 'ngpListboxTrigger',
                }]
        }], propDecorators: { openPopover: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

class NgpListbox {
    constructor() {
        /**
         * Access the injector.
         */
        this.injector = inject(Injector);
        /**
         * Access the destroy ref.
         */
        this.destroyRef = inject(DestroyRef);
        /**
         * The listbox may be used within a popover, which we may want to close on selection.
         */
        this.popoverTrigger = injectPopoverTriggerState({ optional: true });
        /**
         * The id of the listbox.
         */
        this.id = input(uniqueId('ngp-listbox'));
        /**
         * The listbox selection mode.
         */
        this.mode = input('single', {
            alias: 'ngpListboxMode',
        });
        /**
         * The listbox selection.
         */
        this.value = input([], {
            alias: 'ngpListboxValue',
        });
        /**
         * Emits when the listbox selection changes.
         */
        this.valueChange = output({
            alias: 'ngpListboxValueChange',
        });
        /**
         * The listbox disabled state.
         */
        this.disabled = input(false, {
            alias: 'ngpListboxDisabled',
            transform: booleanAttribute,
        });
        /**
         * The comparator function to use when comparing values.
         * If not provided, strict equality (===) is used.
         */
        this.compareWith = input((a, b) => a === b, {
            alias: 'ngpListboxCompareWith',
        });
        /**
         * The tabindex of the listbox.
         */
        this.tabindex = computed(() => (this.state.disabled() ? -1 : 0));
        /**
         * Access the options in the listbox.
         */
        this.options = signal([]);
        /**
         * The active descendant of the listbox.
         */
        this.keyManager = new ActiveDescendantKeyManager(this.options, this.injector);
        /**
         * Gets the active descendant of the listbox.
         */
        this.activeDescendant = signal(undefined);
        /**
         * @internal
         * Whether the listbox is focused.
         */
        this.isFocused = signal(false);
        /**
         * The listbox state
         */
        this.state = listboxState(this);
        setupFocusVisible({ disabled: this.state.disabled });
    }
    ngAfterContentInit() {
        this.keyManager.withHomeAndEnd().withTypeAhead().withVerticalOrientation();
        this.keyManager.change
            .pipe(safeTakeUntilDestroyed(this.destroyRef))
            .subscribe(() => this.activeDescendant.set(this.keyManager.activeItem?.id()));
        // On initialization, set the first selected option as the active descendant if there is one.
        this.updateActiveItem();
        // if the options change, update the active item, for example the item that was previously active may have been removed
        // any time the value changes we should make sure that the active item is updated
        explicitEffect([this.options], () => this.updateActiveItem(), {
            injector: this.injector,
        });
    }
    updateActiveItem() {
        const selectedOption = this.options().find(o => o.selected());
        if (selectedOption) {
            this.keyManager.setActiveItem(selectedOption);
        }
        else {
            this.keyManager.setFirstItemActive();
        }
    }
    onKeydown(event) {
        this.keyManager.onKeydown(event);
        // if the keydown was enter or space, select the active descendant if there is one
        if (event.key === 'Enter' || event.key === ' ') {
            this.keyManager.activeItem?.select('keyboard');
        }
        // if this is an arrow key or selection key, prevent the default action to prevent the page from scrolling
        if (event.key === 'ArrowDown' ||
            event.key === 'ArrowUp' ||
            event.key === 'Enter' ||
            event.key === ' ') {
            event.preventDefault();
        }
    }
    /**
     * @internal
     * Selects an option in the listbox.
     */
    selectOption(value, origin) {
        if (this.state.mode() === 'single') {
            const newValue = [value];
            this.state.value.set(newValue);
            this.valueChange.emit(newValue);
        }
        else {
            // if the value is already selected, remove it, otherwise add it
            if (this.isSelected(value)) {
                const newValue = this.state.value().filter(v => !this.state.compareWith()(v, value));
                this.state.value.set(newValue);
                this.valueChange.emit(newValue);
            }
            else {
                const newValue = [...this.state.value(), value];
                this.state.value.set(newValue);
                this.valueChange.emit(newValue);
            }
        }
        // Set the active descendant to the selected option.
        const option = this.options().find(o => this.state.compareWith()(o.value(), value));
        if (option) {
            this.keyManager.setActiveItem(option);
        }
        // If the listbox is within a popover, close the popover on selection if it is not in a multiple selection mode.
        if (this.state.mode() !== 'multiple') {
            this.popoverTrigger()?.hide(origin);
        }
    }
    /**
     * @internal
     * Determine if an option is selected using the compareWith function.
     */
    isSelected(value) {
        return this.state.value().some(v => this.state.compareWith()(v, value));
    }
    /**
     * @internal
     * Activate an option in the listbox.
     */
    activateOption(value) {
        const option = this.options().find(o => this.state.compareWith()(o.value(), value));
        if (option) {
            this.keyManager.setActiveItem(option);
        }
    }
    /**
     * Registers an option with the listbox.
     * @internal
     */
    addOption(option) {
        // if the option already exists, do not add it again
        if (!this.options().includes(option)) {
            this.options.update(options => [...options, option]);
        }
    }
    /**
     * Deregisters an option with the listbox.
     * @internal
     */
    removeOption(option) {
        this.options.update(options => options.filter(o => o !== option));
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListbox, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpListbox, isStandalone: true, selector: "[ngpListbox]", inputs: { id: { classPropertyName: "id", publicName: "id", isSignal: true, isRequired: false, transformFunction: null }, mode: { classPropertyName: "mode", publicName: "ngpListboxMode", isSignal: true, isRequired: false, transformFunction: null }, value: { classPropertyName: "value", publicName: "ngpListboxValue", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpListboxDisabled", isSignal: true, isRequired: false, transformFunction: null }, compareWith: { classPropertyName: "compareWith", publicName: "ngpListboxCompareWith", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { valueChange: "ngpListboxValueChange" }, host: { attributes: { "role": "listbox" }, listeners: { "focusin": "isFocused.set(true)", "focusout": "isFocused.set(false)", "keydown": "onKeydown($event)" }, properties: { "id": "state.id()", "attr.tabindex": "tabindex()", "attr.aria-disabled": "state.disabled()", "attr.aria-multiselectable": "state.mode() === \"multiple\"", "attr.aria-activedescendant": "activeDescendant()" } }, providers: [provideListboxState()], exportAs: ["ngpListbox"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpListbox, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpListbox]',
                    exportAs: 'ngpListbox',
                    providers: [provideListboxState()],
                    host: {
                        '[id]': 'state.id()',
                        role: 'listbox',
                        '[attr.tabindex]': 'tabindex()',
                        '[attr.aria-disabled]': 'state.disabled()',
                        '[attr.aria-multiselectable]': 'state.mode() === "multiple"',
                        '[attr.aria-activedescendant]': 'activeDescendant()',
                        '(focusin)': 'isFocused.set(true)',
                        '(focusout)': 'isFocused.set(false)',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { onKeydown: [{
                type: HostListener,
                args: ['keydown', ['$event']]
            }] } });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpListbox, NgpListboxHeader, NgpListboxOption, NgpListboxSection, NgpListboxTrigger, injectListboxState, provideListboxState };
//# sourceMappingURL=ng-primitives-listbox.mjs.map
