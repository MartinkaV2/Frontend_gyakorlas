import * as i0 from '@angular/core';
import { input, numberAttribute, booleanAttribute, computed, HostListener, Directive, output } from '@angular/core';
import { setupButton } from 'ng-primitives/button';
import { createStateToken, createStateProvider, createStateInjector, createState } from 'ng-primitives/state';

/**
 * The state token  for the Pagination primitive.
 */
const NgpPaginationStateToken = createStateToken('Pagination');
/**
 * Provides the Pagination state.
 */
const providePaginationState = createStateProvider(NgpPaginationStateToken);
/**
 * Injects the Pagination state.
 */
const injectPaginationState = createStateInjector(NgpPaginationStateToken);
/**
 * The Pagination state registration function.
 */
const paginationState = createState(NgpPaginationStateToken);

/**
 * The `NgpPaginationButton` directive is used to create a pagination button.
 */
class NgpPaginationButton {
    constructor() {
        /**
         * Access the pagination state.
         */
        this.paginationState = injectPaginationState();
        /**
         * Define the page this button represents.
         */
        this.page = input.required({
            alias: 'ngpPaginationButtonPage',
            transform: numberAttribute,
        });
        /**
         * Whether the button is disabled.
         */
        this.buttonDisabled = input(false, {
            alias: 'ngpPaginationButtonDisabled',
            transform: booleanAttribute,
        });
        /**
         * Whether the button is disabled.
         */
        this.disabled = computed(() => this.buttonDisabled() || this.paginationState().disabled());
        /**
         * Whether this page is the currently selected page.
         */
        this.selected = computed(() => this.page() === this.paginationState().page());
        setupButton({ disabled: this.disabled });
    }
    /**
     * Go to the page this button represents.
     */
    goToPage() {
        if (this.disabled()) {
            return;
        }
        this.paginationState().goToPage(this.page());
    }
    /**
     * A click event may not be fired if this is on an anchor tag and the href is empty.
     * This is a workaround to ensure the click event is fired.
     */
    onEnter(event) {
        event.preventDefault();
        event.stopPropagation();
        this.goToPage();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationButton, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPaginationButton, isStandalone: true, selector: "[ngpPaginationButton]", inputs: { page: { classPropertyName: "page", publicName: "ngpPaginationButtonPage", isSignal: true, isRequired: true, transformFunction: null }, buttonDisabled: { classPropertyName: "buttonDisabled", publicName: "ngpPaginationButtonDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "goToPage()", "keydown.enter": "onEnter($event)", "keydown.space": "onEnter($event)" }, properties: { "tabindex": "disabled() ? -1 : 0", "attr.data-page": "page()", "attr.data-selected": "selected() ? \"\" : null", "attr.aria-current": "selected()" } }, exportAs: ["ngpPaginationButton"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationButton, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPaginationButton]',
                    exportAs: 'ngpPaginationButton',
                    host: {
                        '[tabindex]': 'disabled() ? -1 : 0',
                        '[attr.data-page]': 'page()',
                        '[attr.data-selected]': 'selected() ? "" : null',
                        '[attr.aria-current]': 'selected()',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { goToPage: [{
                type: HostListener,
                args: ['click']
            }], onEnter: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });

/**
 * The `NgpPaginationFirst` directive is used to create a pagination button that navigates to the first page.
 */
class NgpPaginationFirst {
    constructor() {
        /**
         * Access the pagination state.
         */
        this.paginationState = injectPaginationState();
        /**
         * Whether the button is disabled.
         */
        this.buttonDisabled = input(false, {
            alias: 'ngpPaginationFirstDisabled',
            transform: booleanAttribute,
        });
        this.disabled = computed(() => this.buttonDisabled() ||
            this.paginationState().disabled() ||
            this.paginationState().firstPage());
        setupButton({ disabled: this.disabled });
    }
    /**
     * Go to the first page.
     */
    goToFirstPage() {
        if (this.disabled()) {
            return;
        }
        this.paginationState().goToPage(1);
    }
    /**
     * A click event may not be fired if this is on an anchor tag and the href is empty.
     * This is a workaround to ensure the click event is fired.
     */
    onEnter(event) {
        event.preventDefault();
        event.stopPropagation();
        this.goToFirstPage();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationFirst, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPaginationFirst, isStandalone: true, selector: "[ngpPaginationFirst]", inputs: { buttonDisabled: { classPropertyName: "buttonDisabled", publicName: "ngpPaginationFirstDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "goToFirstPage()", "keydown.enter": "onEnter($event)", "keydown.space": "onEnter($event)" }, properties: { "tabindex": "disabled() ? -1 : 0", "attr.data-first-page": "paginationState().firstPage() ? \"\" : null" } }, exportAs: ["ngpPaginationFirst"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationFirst, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPaginationFirst]',
                    exportAs: 'ngpPaginationFirst',
                    host: {
                        '[tabindex]': 'disabled() ? -1 : 0',
                        '[attr.data-first-page]': 'paginationState().firstPage() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { goToFirstPage: [{
                type: HostListener,
                args: ['click']
            }], onEnter: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });

/**
 * The `NgpPaginationLast` directive is used to create a pagination button that navigates to the last page.
 */
class NgpPaginationLast {
    constructor() {
        /**
         * Access the pagination state.
         */
        this.paginationState = injectPaginationState();
        /**
         * Whether the button is disabled.
         */
        this.buttonDisabled = input(false, {
            alias: 'ngpPaginationLastDisabled',
            transform: booleanAttribute,
        });
        this.disabled = computed(() => this.buttonDisabled() ||
            this.paginationState().disabled() ||
            this.paginationState().lastPage());
        setupButton({ disabled: this.disabled });
    }
    /**
     * Go to the last page.
     */
    goToLastPage() {
        if (this.disabled()) {
            return;
        }
        this.paginationState().goToPage(this.paginationState().pageCount());
    }
    /**
     * A click event may not be fired if this is on an anchor tag and the href is empty.
     * This is a workaround to ensure the click event is fired.
     */
    onEnter(event) {
        event.preventDefault();
        event.stopPropagation();
        this.goToLastPage();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationLast, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPaginationLast, isStandalone: true, selector: "[ngpPaginationLast]", inputs: { buttonDisabled: { classPropertyName: "buttonDisabled", publicName: "ngpPaginationLastDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "goToLastPage()", "keydown.enter": "onEnter($event)", "keydown.space": "onEnter($event)" }, properties: { "tabindex": "disabled() ? -1 : 0", "attr.data-last-page": "paginationState().lastPage() ? \"\" : null" } }, exportAs: ["ngpPaginationLast"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationLast, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPaginationLast]',
                    exportAs: 'ngpPaginationLast',
                    host: {
                        '[tabindex]': 'disabled() ? -1 : 0',
                        '[attr.data-last-page]': 'paginationState().lastPage() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { goToLastPage: [{
                type: HostListener,
                args: ['click']
            }], onEnter: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });

/**
 * The `NgpPaginationNext` directive is used to create a pagination button that navigates to the next page.
 */
class NgpPaginationNext {
    constructor() {
        /**
         * Access the pagination state.
         */
        this.paginationState = injectPaginationState();
        /**
         * Whether the button is disabled.
         */
        this.buttonDisabled = input(false, {
            alias: 'ngpPaginationNextDisabled',
            transform: booleanAttribute,
        });
        /**
         * Whether the button is disabled.
         */
        this.disabled = computed(() => this.buttonDisabled() ||
            this.paginationState().disabled() ||
            this.paginationState().lastPage());
        setupButton({ disabled: this.disabled });
    }
    /**
     * Go to the next page.
     */
    goToNextPage() {
        if (this.disabled()) {
            return;
        }
        this.paginationState().goToPage(this.paginationState().page() + 1);
    }
    /**
     * A click event may not be fired if this is on an anchor tag and the href is empty.
     * This is a workaround to ensure the click event is fired.
     */
    onEnter(event) {
        event.preventDefault();
        event.stopPropagation();
        this.goToNextPage();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationNext, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPaginationNext, isStandalone: true, selector: "[ngpPaginationNext]", inputs: { buttonDisabled: { classPropertyName: "buttonDisabled", publicName: "ngpPaginationNextDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "goToNextPage()", "keydown.enter": "onEnter($event)", "keydown.space": "onEnter($event)" }, properties: { "tabindex": "disabled() ? -1 : 0", "attr.data-last-page": "paginationState().lastPage() ? \"\" : null" } }, exportAs: ["ngpPaginationNext"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationNext, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPaginationNext]',
                    exportAs: 'ngpPaginationNext',
                    host: {
                        '[tabindex]': 'disabled() ? -1 : 0',
                        '[attr.data-last-page]': 'paginationState().lastPage() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { goToNextPage: [{
                type: HostListener,
                args: ['click']
            }], onEnter: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });

/**
 * The `NgpPaginationPrevious` directive is used to create a pagination button that navigates to the previous page.
 */
class NgpPaginationPrevious {
    constructor() {
        /**
         * Access the pagination state.
         */
        this.paginationState = injectPaginationState();
        /**
         * Whether the button is disabled.
         */
        this.buttonDisabled = input(false, {
            alias: 'ngpPaginationPreviousDisabled',
            transform: booleanAttribute,
        });
        /**
         * Whether the button is disabled.
         */
        this.disabled = computed(() => this.buttonDisabled() ||
            this.paginationState().disabled() ||
            this.paginationState().firstPage());
        setupButton({ disabled: this.disabled });
    }
    /**
     * Go to the previous page.
     */
    goToPreviousPage() {
        if (this.disabled()) {
            return;
        }
        this.paginationState().goToPage(this.paginationState().page() - 1);
    }
    /**
     * A click event may not be fired if this is on an anchor tag and the href is empty.
     * This is a workaround to ensure the click event is fired.
     */
    onEnter(event) {
        event.preventDefault();
        event.stopPropagation();
        this.goToPreviousPage();
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationPrevious, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPaginationPrevious, isStandalone: true, selector: "[ngpPaginationPrevious]", inputs: { buttonDisabled: { classPropertyName: "buttonDisabled", publicName: "ngpPaginationPreviousDisabled", isSignal: true, isRequired: false, transformFunction: null } }, host: { listeners: { "click": "goToPreviousPage()", "keydown.enter": "onEnter($event)", "keydown.space": "onEnter($event)" }, properties: { "tabindex": "disabled() ? -1 : 0", "attr.data-first-page": "paginationState().firstPage() ? \"\" : null" } }, exportAs: ["ngpPaginationPrevious"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPaginationPrevious, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPaginationPrevious]',
                    exportAs: 'ngpPaginationPrevious',
                    host: {
                        '[tabindex]': 'disabled() ? -1 : 0',
                        '[attr.data-first-page]': 'paginationState().firstPage() ? "" : null',
                    },
                }]
        }], ctorParameters: () => [], propDecorators: { goToPreviousPage: [{
                type: HostListener,
                args: ['click']
            }], onEnter: [{
                type: HostListener,
                args: ['keydown.enter', ['$event']]
            }, {
                type: HostListener,
                args: ['keydown.space', ['$event']]
            }] } });

/**
 * The `NgpPagination` directive is used to create a pagination control.
 */
class NgpPagination {
    constructor() {
        /**
         * The currently selected page.
         */
        this.page = input(1, {
            alias: 'ngpPaginationPage',
            transform: numberAttribute,
        });
        /**
         * The event that is fired when the page changes.
         */
        this.pageChange = output({
            alias: 'ngpPaginationPageChange',
        });
        /**
         * The total number of pages.
         */
        this.pageCount = input(0, {
            alias: 'ngpPaginationPageCount',
            transform: numberAttribute,
        });
        /**
         * Whether the pagination is disabled.
         */
        this.disabled = input(false, {
            alias: 'ngpPaginationDisabled',
            transform: booleanAttribute,
        });
        /**
         * Determine if we are on the first page.
         * @internal
         */
        this.firstPage = computed(() => this.state.page() === 1);
        /**
         * Determine if we are on the last page.
         * @internal
         */
        this.lastPage = computed(() => this.state.page() === this.state.pageCount());
        /**
         * The control state for the pagination.
         * @internal
         */
        this.state = paginationState(this);
    }
    /**
     * Go to the specified page.
     * @param page The page to go to.
     */
    goToPage(page) {
        // check if the page is within the bounds of the pagination
        if (page < 1 || page > this.state.pageCount()) {
            return;
        }
        this.state.page.set(page);
        this.pageChange.emit(page);
    }
    static { this.ɵfac = i0.ɵɵngDeclareFactory({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPagination, deps: [], target: i0.ɵɵFactoryTarget.Directive }); }
    static { this.ɵdir = i0.ɵɵngDeclareDirective({ minVersion: "17.1.0", version: "19.2.11", type: NgpPagination, isStandalone: true, selector: "[ngpPagination]", inputs: { page: { classPropertyName: "page", publicName: "ngpPaginationPage", isSignal: true, isRequired: false, transformFunction: null }, pageCount: { classPropertyName: "pageCount", publicName: "ngpPaginationPageCount", isSignal: true, isRequired: false, transformFunction: null }, disabled: { classPropertyName: "disabled", publicName: "ngpPaginationDisabled", isSignal: true, isRequired: false, transformFunction: null } }, outputs: { pageChange: "ngpPaginationPageChange" }, host: { attributes: { "role": "navigation" }, properties: { "attr.data-page": "state.page()", "attr.data-page-count": "state.pageCount()", "attr.data-first-page": "firstPage() ? \"\" : null", "attr.data-last-page": "lastPage() ? \"\" : null", "attr.data-disabled": "state.disabled() ? \"\" : null" } }, providers: [providePaginationState()], exportAs: ["ngpPagination"], ngImport: i0 }); }
}
i0.ɵɵngDeclareClassMetadata({ minVersion: "12.0.0", version: "19.2.11", ngImport: i0, type: NgpPagination, decorators: [{
            type: Directive,
            args: [{
                    selector: '[ngpPagination]',
                    exportAs: 'ngpPagination',
                    providers: [providePaginationState()],
                    host: {
                        role: 'navigation',
                        '[attr.data-page]': 'state.page()',
                        '[attr.data-page-count]': 'state.pageCount()',
                        '[attr.data-first-page]': 'firstPage() ? "" : null',
                        '[attr.data-last-page]': 'lastPage() ? "" : null',
                        '[attr.data-disabled]': 'state.disabled() ? "" : null',
                    },
                }]
        }] });

/**
 * Generated bundle index. Do not edit.
 */

export { NgpPagination, NgpPaginationButton, NgpPaginationFirst, NgpPaginationLast, NgpPaginationNext, NgpPaginationPrevious, injectPaginationState, providePaginationState };
//# sourceMappingURL=ng-primitives-pagination.mjs.map
